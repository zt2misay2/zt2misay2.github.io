[{"title":"TGCTF2025","url":"/2025/04/22/TGCTF2025/","content":"EZRSAfrom secrets import flag, get_random_emojiiiiiifrom Crypto.Util.number import *def genarate_emojiiiiii_prime(nbits, base=0):    while True:        p = getPrime(base // 32 * 32) if base &gt;= 3 else 0        for i in range(nbits // 8 // 4 - base // 32):            p = (p &lt;&lt; 32) + get_random_emojiiiiii() # çŒœä¸€çŒœ        if isPrime(p):            return pm = bytes_to_long(flag.encode()+ \"\".join([long_to_bytes(get_random_emojiiiiii()).decode() for _ in range(5)]).encode())p = genarate_emojiiiiii_prime(512, 224)q = genarate_emojiiiiii_prime(512)n = p * qe = \"ğŸ’¯\"c = pow(m, bytes_to_long(e.encode()), n)print(\"p0 =\", long_to_bytes(p % 2 ** 256).decode())print(\"n =\", n)print(\"c =\", c)# p0 = ğŸ˜˜ğŸ˜¾ğŸ˜‚ğŸ˜‹ğŸ˜¶ğŸ˜¾ğŸ˜³ğŸ˜·# n = 156583691355552921614631145152732482393176197132995684056861057354110068341462353935267384379058316405283253737394317838367413343764593681931500132616527754658531492837010737718142600521325345568856010357221012237243808583944390972551218281979735678709596942275013178851539514928075449007568871314257800372579# c = 47047259652272336203165844654641527951135794808396961300275905227499051240355966018762052339199047708940870407974724853429554168419302817757183570945811400049095628907115694231183403596602759249583523605700220530849961163557032168735648835975899744556626132330921576826526953069435718888223260480397802737401\nä»\np = genarate_emojiiiiii_prime(512, 224)q = genarate_emojiiiiii_prime(512)\nåˆ‡å…¥ï¼Œç»“åˆè¿™ä¸ªå‡½æ•°ï¼Œä¸éš¾åˆ†æå‡ºï¼Œqå°±æ˜¯18ä¸ªemojiå—ï¼Œè€Œpçš„ç¬¬288ä½éƒ½æ˜¯emojiå—ï¼ˆå…±8ä¸ªï¼‰ï¼Œè€Œpå·²çŸ¥ä½256ä½ï¼Œå¹¶ä¸”è§‚å¯Ÿç”Ÿæˆpçš„emojiå—çš„ç»„æˆï¼Œåä½æ•°è¡¨ç¤ºéƒ½æ˜¯40369911??æ‰€ä»¥è¯´åªç”¨çˆ†ç ´ç¬¬å…«ä¸ªemojiçš„æœ€å2ä½ï¼Œå³å¯å¾—åˆ°pçš„ä½288ä½ï¼Œç„¶åå¯¹é«˜ä½å†æ‰“ä¸€ç»„copperï¼Œæ­¤æ—¶æ˜¯å¯ä»¥è§£çš„ï¼Œè§£å‡ºæ¥ï¼Œè¿™é‡Œcopperçš„æ€è·¯æ˜¯ï¼Œå½“xç¡®å®šï¼Œåœ¨$GF(n)$æˆ‘ä»¬å¯ä»¥ç”¨å¤šé¡¹å¼\n\np=f(x)=x*2^{288}+(a+i)*2^{256}+pp\\equiv0\\\\æ¥çº¦æŸx,ä»è€Œcopperå‡ºå¯èƒ½çš„å€¼ï¼Œå†ç”¨æ•´é™¤æ€§éªŒè¯å³å¯ï¼Œè„šæœ¬å¦‚ä¸‹\nfrom Crypto.Util.number import *from tqdm import tqdmp0 = \"ğŸ˜˜ğŸ˜¾ğŸ˜‚ğŸ˜‹ğŸ˜¶ğŸ˜¾ğŸ˜³ğŸ˜·\"n = 156583691355552921614631145152732482393176197132995684056861057354110068341462353935267384379058316405283253737394317838367413343764593681931500132616527754658531492837010737718142600521325345568856010357221012237243808583944390972551218281979735678709596942275013178851539514928075449007568871314257800372579c = 47047259652272336203165844654641527951135794808396961300275905227499051240355966018762052339199047708940870407974724853429554168419302817757183570945811400049095628907115694231183403596602759249583523605700220530849961163557032168735648835975899744556626132330921576826526953069435718888223260480397802737401e = \"ğŸ’¯\"ee = bytes_to_long(e.encode())a=4036991100pp = bytes_to_long(p0.encode())for i in tqdm(range(100)):    PR.&lt;x&gt; = PolynomialRing(Zmod(n))    f = x * 2^288 + pp + (a+i) * 2^256    f = f.monic()    roots = f.small_roots(X=2^224, beta=0.4, eplison=0.04)    if roots:        x = roots[0]        p_may = int(x * 2^288 + pp + (a+i) * 2^256)        if n%p_may == 0:            print(\"p_may = \", p_may)            print(\"q_may = \", n // p_may)            break# p_may =  12424840247075830662687097292458444573014198016321428995092662043898159667123240573630892907827505266982898641483333170032514244713840745287869771915696311# q_may =  12602471198163266643743702664647336358595911975665358584258749238146841559843060594842063473155049870396568542257767865369797827796765830093256146584311989# ç”¨æ—¶0.2s\nè§£å‡ºp,qä¹‹åå°±æ˜¯e,phiä¸äº’ç´ çš„RSAäº†,æ„Ÿè°¢ä¸çŸ¥é“æˆ˜é˜Ÿçš„å¸ˆå‚…æä¾›çš„ä¸€ç§ç®€æ´çš„å†™æ³•TGCTF25 ä¸çŸ¥é“ WP | ä¸çŸ¥é“ã®blog (idontknowctf.xyz)\nphi = (p-1)*(q-1)# GCD = gcd(ee, phi)  15d = inverse(ee//15, phi)c = pow(c, d, n)R.&lt;y&gt;=Zmod(p)[]f=y^15-cf=f.monic()m1=f.roots()R.&lt;z&gt;=Zmod(q)[]f=z^15-cf=f.monic()m2=f.roots()for i in m1:    for j in m2:        m=crt([int(i[0]),int(j[0])],[int(p),int(q)])        # print(long_to_bytes(int(m)))        if b'TGCTF' in long_to_bytes(int(m)):            print(long_to_bytes(int(m)).decode())# TGCTF{ğŸ™‡ğŸ®ğŸ¤Ÿ_ğŸ«¡ğŸ«¡ğŸ«¡_ğŸš©ğŸš©ğŸš©}ğŸ˜ƒğŸ˜–ğŸ˜˜ğŸ˜¨ğŸ˜¢\nLLLCGfrom hashlib import sha256from Crypto.Util.number import getPrime, inverse, bytes_to_long, isPrimefrom random import randintimport socketserverfrom secret import flag, dsa_p, dsa_qclass TripleLCG:    def __init__(self, seed1, seed2, seed3, a, b, c, d, n):        self.state = [seed1, seed2, seed3]        self.a = a        self.b = b        self.c = c        self.d = d        self.n = n    def next(self):        new = (self.a * self.state[-3] + self.b * self.state[-2] + self.c * self.state[-1] + self.d) % self.n        self.state.append(new)        return newclass DSA:    def __init__(self):        # while True:            # self.q = getPrime(160)            # t = 2 * getPrime(1024 - 160) * self.q            # if isPrime(t + 1):            #    self.p = t + 1            #    break        self.p = dsa_p        self.q = dsa_q        self.g = pow(2, (self.p - 1) // self.q, self.p)        self.x = randint(1, self.q - 1)        self.y = pow(self.g, self.x, self.p)    def sign(self, msg, k):        h = bytes_to_long(sha256(msg).digest())        r = pow(self.g, k, self.p) % self.q        s = (inverse(k, self.q) * (h + self.x * r)) % self.q        return (r, s)    def verify(self, msg, r, s):        if not (0 &lt; r &lt; self.q and 0 &lt; s &lt; self.q):            return False        h = bytes_to_long(sha256(msg).digest())        w = inverse(s, self.q)        u1 = (h * w) % self.q        u2 = (r * w) % self.q        v = ((pow(self.g, u1, self.p) * pow(self.y, u2, self.p)) % self.p) % self.q        return v == rclass Task(socketserver.BaseRequestHandler):    def _recvall(self):        BUFF_SIZE = 2048        data = b''        while True:            part = self.request.recv(BUFF_SIZE)            data += part            if len(part) &lt; BUFF_SIZE:                break        return data.strip()    def send(self, msg, newline=True):        if newline:            msg += b'\\n'        self.request.sendall(msg)    def recv(self, prompt=b'[-] '):        self.send(prompt, newline=False)        return self._recvall()    def handle(self):        n = getPrime(128)        a, b, c, d = [randint(1, n - 1) for _ in range(4)]        seed1, seed2, seed3 = [randint(1, n - 1) for _ in range(3)]        lcg = TripleLCG(seed1, seed2, seed3, a, b, c, d, n)        dsa = DSA()        self.send(b\"Welcome to TGCTF Challenge!\\n\")        self.send(f\"p = {dsa.p}, q = {dsa.q}, g = {dsa.g}, y = {dsa.y}\".encode())        small_primes = [59093, 65371, 37337, 43759, 52859, 39541, 60457, 61469, 43711]        used_messages = set()        for o_v in range(3):            self.send(b\"Select challenge parts: 1, 2, 3\\n\")            parts = self.recv().decode().split()            if '1' in parts:                self.send(b\"Part 1\\n\")                for i in range(12):                    self.send(f\"Message {i + 1}: \".encode())                    msg = self.recv()                    used_messages.add(msg)                    k = lcg.next()                    r, s = dsa.sign(msg, k)                    self.send(f\"r = {r}, ks = {[k % p for p in small_primes]}\\n\".encode())            if '2' in parts:                self.send(b\"Part 2\\n\")                for _ in range(307):                    k = lcg.next()                for i in range(10):                    self.send(f\"Message {i + 1}: \".encode())                    msg = self.recv()                    k = lcg.next() % dsa.q                    r, s = dsa.sign(msg, k)                    self.send(f\"Signature: r = {r}, s = {s}\\n\".encode())                    used_messages.add(msg)            if '3' in parts:                self.send(b\"Part 3\\n\")                self.send(b\"Forged message: \")                final_msg = self.recv()                self.send(b\"Forged r: \")                r = int(self.recv())                self.send(b\"Forged s: \")                s = int(self.recv())                if final_msg in used_messages:                    self.send(b\"Message already signed!\\n\")                elif dsa.verify(final_msg, r, s):                    self.send(f\"Good! Your flag: {flag}\\n\".encode())                else:                    self.send(b\"Invalid signature.\\n\")###Welcome to TGCTF Challenge!p = 184352699172192576270535944394450689601424152593934253476634864667530549943623545663040121406222033469867822007490624607150449533351028007649079671823930639894259153639431593427418637301705583834256344087212849054820629604266938603002612952530534395948672534275310804229044744624757608906107492972246321630467, q = 1427475768627039429244287846531087092897981204933, g = 179483243075904419855912998377411172058265425529332248345132802466991524049692135618377118498301129461020930474539980424661227889497234584809425572665861532126589551010542468047939006056449514768312598585142121764108071687257917794156000007175743318015987068492602701013540262918705248846831651675444456948643, y = 65387748521549843710283006626280200692251144711420678211108890034468688391999964987744284367851744917929187743649125947284992180212308979307495115040557673902928236192043216997090684739998860758466653879269647032285760519012600075468974154258734633743042931772136088467213651982608545621578498333319665003265Select challenge parts: 1, 2, 3###\næ•°å­—ç­¾åé—®é¢˜ï¼Œé¢˜å¹²ç»™å‡ºäº†ä¸€ä¸ªä¸‰é‡LCGè®¡ç®—ç±»ï¼Œè®¡ç®—å…¬å¼æ˜¯\n\ns_{i+3}\\equiv as_{i}+bs_{i+1}+cs_{i+2}+d\\;mod\\;n\\\\\ns_1=seed_1\\;s_2=seed_2\\;s_2=seed_2\\\\\næˆ‘ä»¬å…ˆçœ‹part1ï¼Œæˆ‘ä»¬æ¯è¾“å…¥ä¸€ä¸ªï¼Œéƒ½ä¼šç”Ÿæˆä¸€ä¸ª,å¹¶ä¸”ç”¨è¿›è¡Œç­¾åï¼Œç„¶åå†è¾“å‡º\n\n\n[k_i\\;mod\\;p_j,....](0","categories":["å¤ç°"],"tags":["CTF","RSA","LCG","DSA"]},{"title":"RSA--eä¸phiä¸äº’ç´ ","url":"/2025/04/28/RSA-e%E4%B8%8Ephi%E4%B8%8D%E4%BA%92%E7%B4%A0/","content":"å‰è¨€æˆ‘ä»¬çŸ¥é“ï¼Œåœ¨RSAç³»ç»Ÿä¸­ï¼Œè§£å¯†ä¾èµ–äºæ¬§æ‹‰å®šç†\n\na^{\\phi(p)}\\equiv1\\;mod\\;p\\;,\\;(a,p)=1\\\\ä»¥åŠåŒä½™ç­‰å¼\n\ned\\equiv1\\;mod\\;\\phi(n)\\\\,é‚£ä¹ˆåœ¨å·²çŸ¥\n\nc\\equiv\\;m^{e}\\;mod\\;nä¸‹ï¼Œå®¹æ˜“å¾—åˆ°\n\nc^{d}\\equiv\\;(m^{e})^{d}\\;mod\\;n\\\\\ned=1+k\\phi(n)\\\\\nc^{d}\\equiv\\;m*m^{k\\phi(n)}\\;\\equiv\\;m*1\\;mod\\;n\\\\ä½†æ˜¯å½“ä¸äº’ç´ çš„æƒ…å†µä¸‹ï¼Œç§é’¥å°±æ— æ³•æ­£å¸¸è®¡ç®—ï¼Œåœ¨æ­¤ä¹‹ä¸‹æƒ³è¦é¡ºåˆ©æ±‚è§£æ˜æ–‡,è¡ç”Ÿäº†ä¸€ç³»åˆ—é—®é¢˜ï¼Œæœ¬æ–‡åŸºäºç¬”è€…æ—¥å¸¸ä¸­é‡åˆ°çš„ç›¸å…³é¢˜å‹ï¼Œç»™å‡ºå¯¹åº”çš„å¤„ç†æ–¹æ³•\nä»ç®€å•æƒ…å†µå‡ºå‘æˆ‘ä»¬ä¸å¦¨ä»¤\n\ngcd(e,\\phi)=t\\\\\nte^{'}=e\\\\é‚£ä¹ˆè€ƒè™‘è½¬åŒ–ä¸ºå…¬é’¥æŒ‡æ•°ä¸ºçš„RSAï¼Œæœ‰\n\ne^{'}d^{'}\\equiv1mod\\phi(n)\\\\\nc\\equiv\\;m^{e}\\equiv\\;m^{te^{'}}\\;mod\\;n\\\\\nc^{d^{'}}\\equiv\\;m^{te^{'}d^{'}}\\;\\equiv\\;m^{t}\\;mod\\;n\\\\æ˜¾ç„¶æ­¤æ—¶æˆ‘ä»¬èƒ½å¤Ÿè®¡ç®—\n\nc^{d^{'}}\\;mod\\;n\\\\å¦‚æœä¸æ˜¯å¾ˆå¤§ï¼ˆä¸ªä½æ•°ï¼‰ï¼Œå½“çš„æ—¶å€™ï¼Œæˆ‘ä»¬ç›´æ¥èƒ½å¾—åˆ°\n\nc^{d^{'}}\\;mod\\;n=m^{t}\\\\ï¼Œç›´æ¥å¼€æ¬¡æ–¹å°±èƒ½å¾—åˆ°\nå¦‚æœä¸é‚£ä¹ˆå¤§çš„è¯ï¼Œæˆ‘ä»¬å§‘ä¸”è¿˜èƒ½å°è¯•çˆ†ç ´\n\nc^{d^{'}}=kn+m^{t}\\\\ï¼Œä½†æ˜¯å¦‚æœæ•°æ®ä¸æ”¯æŒï¼Œå¤§åˆ°çˆ†ç ´ä¸äº†ï¼Œæˆ‘ä»¬å°±å¾—è¿›ä¸€æ­¥è§‚å¯Ÿå·²æœ‰æ•°æ®ä¸­çš„ä»£æ•°ç»“æ„äº†\nå¦‚æœåŒæ—¶ä¸ï¼Œäº’è´¨ï¼ˆCRTåŠ é€ŸRSAé—®é¢˜ï¼‰è¿™é‡Œä¹Ÿå°±æ˜¯åœ¨RSAä¸­ä½¿ç”¨CRTç®—æ³•åŠ é€Ÿè¿ç®—çš„ä¾‹å­ï¼Œæˆ‘ä»¬éƒ½æ¥è®²è®²å¦‚ä½•æ“ä½œ\n\nä¸ºä»€ä¹ˆè¦ç”¨CRTï¼Ÿ\n\nåœ¨RSAçš„è®¡ç®—ä¸­ï¼Œæˆ‘ä»¬æœ‰\n\ned\\equiv1\\;mod\\;\\phi(n)\\\\\nc\\equiv\\;m^d\\;modn\\\\ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œå¾€å¾€éå¸¸å¤§ï¼Œé‚£ä¹ˆè®¡ç®—ä¸Šé¢ä¸¤ä¸ªå¼å­å°±éå¸¸çš„æ¶ˆè€—æ—¶é—´ï¼Œè€Œä¸”ä¹Ÿéœ€è¦,æˆ‘ä»¬æ³¨æ„åˆ°ä¹Ÿæ˜¯ä¸¤ä¸ªå¤§è´¨æ•°ï¼Œå¾ˆæœ‰å¯èƒ½ä¸å³   ;   å³ä¹Ÿäº’ç´ ï¼Œé‚£ä¹ˆæˆ‘èƒ½å°±èƒ½æŠŠé—®é¢˜è½¬åŒ–åˆ°æ¨¡ ä¸‹æ¥è®¨è®ºï¼Œä¸‹é¢æ˜¯æ¨å¯¼è¿‡ç¨‹\n\nç”±c\\equiv\\;m^{e}\\;mod\\;n\\\\\nc\\equiv\\;m^p\\;mod\\;p\\\\\nc\\equiv\\;m^q\\;mod\\;q\\\\è¿™æ˜¯ç”±äºä¹Ÿå°±æ˜¯æ¨¡çš„ä¼ é€’æ€§ï¼Œé‚£ä¹ˆæˆ‘ä»¬è½¬è¿‡æ¥è®¡ç®—åœ¨æ¨¡ä¸‹çš„ç§é’¥ï¼Œå³\n\nedp\\equiv1\\;mod\\;\\phi(p)\\\\\ned_q\\equiv1\\;mod\\;\\phi(q)\\\\é‚£ä¹ˆåœ¨è§£å¯†çš„æ—¶å€™å°±æœ‰\n\nc^{d_p}\\equiv\\;m^{ed_p}\\equiv\\;m^{1+k\\phi(p)}\\;\\equiv\\;m\\;mod\\;p\\\\\nc^{d_q}\\equiv\\;m^{ed_q}\\equiv\\;m^{1+k\\phi(q)}\\;\\equiv\\;m\\;mod\\;q\\\\\nè®°c^{d_p}\\equiv\\;m\\;mod\\;p\\;\\;=m_1\\;\\;c^{d_q}\\equiv\\;m\\;mod\\;q\\;\\;=m_2\\\\è¿™é‡Œæ˜¯å› ä¸ºå¯èƒ½æ¯”è¦å¤§ï¼Œæ‰€ä»¥æˆ‘ä»¬æ— æ³•ç›´æ¥è§£å‡ºæ¥ï¼Œç„¶åæˆ‘ä»¬æ ¹æ®ä¸­å›½å‰©ä½™å®šç†å¯ä»¥æ„é€ å‡ºä¸€ä¸ªå¯¹çš„è§£ï¼Œå¦‚ä¸‹\nç”±ç¬¬äºŒä¸ªåŒä½™å¼ä¸å¦¨è®¾\n\nm=m_2+hq\\;\\\\æˆ‘ä»¬è¿›è€Œåªéœ€è¦è§£å‡ºæ¥,æŠŠè¿™ä¸ªå¼å­å¸¦å…¥å¦ä¸€ä¸ªåŒä½™å¼\n\nm_2+hq\\equiv\\;m_1mod\\;p\\\\\nhq\\equiv(m_1-m_2)\\;mod\\;p\\\\æˆ‘ä»¬åªéœ€è®¡ç®—\n\nI_q\\equiv\\;q^{-1}\\;mod\\;p\\\\é‚£ä¹ˆæœ‰\n\nh\\equiv\\;I_q(m_1-m_2)\\;mod\\;p\\\\å¾—åˆ°ä¹‹åå›ä»£å³å¯æˆåŠŸæ±‚å‡º\nå¯è§è¿™é‡Œæˆ‘ä»¬çš„è®¡ç®—éƒ½æ˜¯åœ¨æ¨¡çš„å¼å­ä¸­è¿›è¡Œçš„ï¼Œä¹˜æ³•è¿ç®—çš„æ¬¡æ•°å°‘äº†ä¸å°‘ï¼Œå®ç°äº†åŠ é€Ÿ\nè¯´å›æ­£é¢˜ï¼Œä»ä¸Šé¢ä¸éš¾çœ‹å‡ºï¼Œæˆ‘ä»¬è‡ªå§‹è‡³ç»ˆéƒ½æ²¡æœ‰å°è¯•è®¡ç®—ï¼ŒæˆåŠŸå›é¿äº†è¿™ä¸ªé—®é¢˜\næ¥ä¸ªä¾‹å­â€”é»‘ç›¾æ¯ 2020-Factor\nn = 3454083680130687060405946528826790951695785465926614724373e = 3c = 1347530713288996422676156069761604101177635382955634367208gcd(m, n) = 1\nè¿™é‡Œnä¸æ˜¯å¾ˆå¤§ï¼Œç®€å•åˆ†è§£åèƒ½å¾—åˆ°ä¸‰ä¸ªç´ å› å­ï¼Œæˆ‘ä»¬è®°ä¸ºpqrï¼Œå¦‚ä¸‹\np=11761833764528579549q=17100682436035561357r=17172929050033177661print(n-p*q*r) # 0print(gcd(e,phi)) # 3print(gcd(e,p-1)) # 1print(gcd(e,q-1)) # 3print(gcd(e,r-1)) # 1print(gcd(e,(p-1)*(r-1))) # 1\nç®€å•æ£€æŸ¥äº†å…³ç³»ï¼Œå¦‚ä¸Šï¼Œè¿™é¢˜æ–¹æ³•å¾ˆå¤šï¼Œåœ¨ä¸Šé¢çš„è§£æ³•ä¸‹å³åˆ©ç”¨æ¥ä½¿ç”¨CRTæ±‚è§£ï¼Œä»£ç å¦‚ä¸‹\n#sagedp=inverse(e,p-1)dr=inverse(e,r-1)m1=pow(c,dp,p)m2=pow(c,dr,r)Ir=pow(r,-1,p)h=pow(Ir*(m1-m2),1,p)m=m2+h*rprint(long_to_bytes(m))# CMISCCTF{3_RSA}\nè¿™é‡Œä¹Ÿèƒ½è½¬åŒ–åˆ°åœ¨æ¨¡ä¸‹å°è¯•æ±‚è§£ï¼Œä½†æ˜¯é‚£å¯¹æ˜æ–‡çš„å¤§å°æœ‰ä¸€å®šè¦æ±‚ï¼Œæˆ‘ä»¬è¿˜æ˜¯ä½¿ç”¨é€šæ³•ï¼Œè¿™é‡Œåªè¦èƒ½æ‰¾åˆ°ä¸¤ä¸ªæ»¡è¶³è¦æ±‚çš„å› å­å°±è¡Œï¼Œä½†æ˜¯è¿™ä¸æ˜¯ä»€ä¹ˆæ—¶å€™éƒ½èƒ½ç”Ÿæ•ˆï¼Œè¯·çœ‹ä¸‹é¢˜\nå¼ºç½‘æ¯2022â€”[ASR]\nfrom Crypto.Util.number import getPrimefrom secret import falgpad = lambda s:s + bytes([(len(s)-1)%16+1]*((len(s)-1)%16+1))n = getPrime(128)**2 * getPrime(128)**2 * getPrime(128)**2 * getPrime(128)**2e = 3flag = pad(flag)print(flag)assert(len(flag) &gt;= 48)m = int.from_bytes(flag,'big')c = pow(m,e,n)print(f'n = {n}')print(f'e = {e}')print(f'c = {c}')n = 8250871280281573979365095715711359115372504458973444367083195431861307534563246537364248104106494598081988216584432003199198805753721448450911308558041115465900179230798939615583517756265557814710419157462721793864532239042758808298575522666358352726060578194045804198551989679722201244547561044646931280001e = 3c = 945272793717722090962030960824180726576357481511799904903841312265308706852971155205003971821843069272938250385935597609059700446530436381124650731751982419593070224310399320617914955227288662661442416421725698368791013785074809691867988444306279231013360024747585261790352627234450209996422862329513284149\næ³¨æ„åˆ°è¿™é‡Œç‰¹åˆ«å¯¹mè¿›è¡Œäº†å¡«å……ï¼Œå°±æ˜¯ä¿è¯mæ¯”nçš„å› å­å¤§ï¼Œæ— æ³•è½¬åŒ–ä¸ºåœ¨å°å› å­çš„åŸŸä¸‹æ±‚è§£ï¼Œçœ‹çœ‹ä¸‹é¢è¿™æ®µå¤±è´¥çš„exp\nfrom Crypto.Util.number import *e = 3n = 8250871280281573979365095715711359115372504458973444367083195431861307534563246537364248104106494598081988216584432003199198805753721448450911308558041115465900179230798939615583517756265557814710419157462721793864532239042758808298575522666358352726060578194045804198551989679722201244547561044646931280001c = 945272793717722090962030960824180726576357481511799904903841312265308706852971155205003971821843069272938250385935597609059700446530436381124650731751982419593070224310399320617914955227288662661442416421725698368791013785074809691867988444306279231013360024747585261790352627234450209996422862329513284149p = 225933944608558304529179430753170813347q = 260594583349478633632570848336184053653r = 218566259296037866647273372633238739089t = 223213222467584072959434495118689164399print(gcd(e,p-1)) # 3print(gcd(e,q-1)) # 1print(gcd(e,r-1)) # 3print(gcd(e,t-1)) # 1dt=inverse(e,t-1)dq=inverse(e,q-1)m1=pow(c,dt,t)m2=pow(c,dq,q)Iq=pow(q,-1,t)h=pow(Iq*(m1-m2),1,t)m=m2+h*qprint(long_to_bytes(m))\nè¿™é‡Œçš„ç¡®æ‰¾åˆ°äº†æ»¡è¶³çš„ä¸¤ä¸ªå› å­ï¼Œä½†æ˜¯æˆ‘ä»¬æ³¨æ„åˆ°ï¼Œè‹¥åˆ,æ‰€ä»¥æˆ‘ä»¬åœ¨ä¸Šè¿°ä»£ç ä¸­è§£å‡ºæ¥çš„æ»¡è¶³ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœçš„æ—¶å€™ï¼Œè¿™ä¸ªæ–¹æ³•å°±æš‚æ—¶å¤±æ•ˆäº†ï¼Œè¿™æ˜¯åœ¨å¤šå› å­RSAä¸‹ç‰¹åˆ«çš„é—®é¢˜ï¼Œæ³¨æ„åˆ°æˆ‘ä»¬è¿˜æœ‰ä¸¤ä¸ªå› å­æ²¡æœ‰ä½¿ç”¨ï¼Œä¸ºäº†ä¹Ÿèƒ½ä½¿ç”¨ä¸Šå®ƒä»¬ï¼Œæˆ‘ä»¬ç»™å‡ºæ›´åŠ ä¸€èˆ¬çš„æ–¹æ³•\næœ‰é™åŸŸå¼€æ ¹æƒ³æƒ³æˆ‘ä»¬çš„æ ¸å¿ƒç›®æ ‡æ˜¯ä»€ä¹ˆï¼Ÿâ€”æ±‚è§£ é‚£ä¹ˆæˆ‘ä»¬ä¸ºä»€ä¹ˆè¦æ‰¾åˆ°è¿™ä¸ªçš„?é‡æ–°æ‹ä¸€éè¿‡ç¨‹ï¼Œæˆ‘ä»¬å°±å‘ç°ï¼Œæ˜¯ä¸ºäº†å»è®¡ç®—æ¥æ±‚è§£æ»¡è¶³çš„,æ¢è¨€ä¹‹ï¼Œæˆ‘ä»¬è¿˜æ˜¯åœ¨æ±‚æ¨¡ä¸åŒç´ å› å­ä¸‹çš„,æˆ‘ä»¬ä¸å¦¨æƒ³ä¸€ä¸‹ï¼ŒçœŸçš„é‡è¦å—ï¼Ÿ,æˆ‘ä»¬çœ‹è¿™ä¸ªæ–¹ç¨‹\n\nm^e-c\\equiv0\\;mod\\;a_i\\\\è¿™ä¸å°±æ˜¯åœ¨ä¸‹çš„æ–¹ç¨‹å—ï¼Ÿè¿™é‡Œè¿˜éå¸¸å°ï¼Œå®Œå…¨å¯ä»¥åœ¨è¿™ä¸ªæœ‰é™åŸŸä¸‹æ¥å¼€æ ¹æ±‚è§£æ‰€æœ‰ç¬¦åˆé¢˜æ„çš„çš„å–å€¼é›†åˆï¼Œæ˜¾ç„¶å¯èƒ½æœ‰å¤šè§£ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä¾æ¬¡æšä¸¾ä¸­çš„å€¼ï¼Œç”±ä¸Šè¿°åˆ†æï¼Œè‹¥ï¼Œé‚£ä¹ˆå¦åˆ™ä¹Ÿæœ‰\né‚£ä¹ˆæˆ‘ä»¬æšä¸¾è¿™å››ä¸ªé›†åˆï¼Œä¸€å®šèƒ½æ‰¾åˆ°æ»¡è¶³æˆ‘ä»¬éœ€è¦çš„\n\n\\begin{cases}m_1=m\\;mod\\;a_1\\\\m_2=m\\;mod\\;a_2\\\\m_3=m\\;mod\\;a_3\\\\m_4=m\\;mod\\;a_4\\\\\\end{cases}è¿™å°±æ˜¯ä¸­å›½å‰©ä½™å®šç†äº†ï¼Œæˆ‘ä»¬ç›´æ¥æ‰“CRTå°±èƒ½è§£å‡ºæ¥mï¼Œè€Œä¸”æˆ‘ä»¬ç”¨åˆ°äº†æ‰€æœ‰çš„å› å­ï¼Œå‡ ä¹å¯ä»¥ä¿è¯è¿™é‡Œæ˜¯å”¯ä¸€çš„ï¼Œå¦‚æœä¸æ˜¯å”¯ä¸€çš„ï¼Œæˆ‘ä»¬ç¡®å®šä¸€ä¸‹ä¸­çš„ï¼Œè½¬åŒ–åˆ°æ¨¡ä¸‹å°±è¡Œï¼Œä¸‹é¢æ˜¯ä¿®æ”¹åçš„exp\n# sagefrom Crypto.Util.number import *from itertools import product# Given parameterse = 3n = 8250871280281573979365095715711359115372504458973444367083195431861307534563246537364248104106494598081988216584432003199198805753721448450911308558041115465900179230798939615583517756265557814710419157462721793864532239042758808298575522666358352726060578194045804198551989679722201244547561044646931280001c = 945272793717722090962030960824180726576357481511799904903841312265308706852971155205003971821843069272938250385935597609059700446530436381124650731751982419593070224310399320617914955227288662661442416421725698368791013785074809691867988444306279231013360024747585261790352627234450209996422862329513284149# Prime factorsp = 225933944608558304529179430753170813347q = 260594583349478633632570848336184053653r = 218566259296037866647273372633238739089t = 223213222467584072959434495118689164399# Create polynomial rings and find roots in each fieldR.&lt;x&gt; = Zmod(p)[]f = x^e - cres_p = f.monic().roots()R.&lt;x&gt; = Zmod(q)[]f = x^e - cres_q = f.monic().roots()R.&lt;x&gt; = Zmod(r)[]f = x^e - cres_r = f.monic().roots()R.&lt;x&gt; = Zmod(t)[]f = x^e - cres_t = f.monic().roots()# Iterate through all possible combinations of rootsfor (m_p, _) in res_p:    for (m_q, _) in res_q:        for (m_r, _) in res_r:            for (m_t, _) in res_t:                # Combine using CRT in stages                # First combine p and q                m_pq = crt(int(m_p), int(m_q), p, q)                # Then combine r and t                m_rt = crt(int(m_r), int(m_t), r, t)                # Finally combine the two results                m = crt(m_pq, m_rt, p*q, r*t)                                mes = long_to_bytes(m)                print(mes)        # b'flag{Fear_can_hold_you_prisoner_Hope_can_set_you_free}\\x06\\x06\\x06\\x06\\x06\\x06'\n","categories":["Crypto"],"tags":["RSA","Crypto"]},{"title":"UCSCCTF2025","url":"/2025/04/20/UCSCCTF2025/","content":"\n1.XR4import base64import randomfrom secret import flagimport numpy as npdef init_sbox(key):    s_box = list(range(256))    j = 0    for i in range(256):        j = (j + s_box[i] + ord(key[i % len(key)])) % 256        s_box[i], s_box[j] = s_box[j], s_box[i]    return s_boxdef decrypt(cipher, box):    res = []    i = j = 0    cipher_bytes = base64.b64decode(cipher)    for s in cipher_bytes:        i = (i + 1) % 256        j = (j + box[i]) % 256        box[i], box[j] = box[j], box[i]        t = (box[i] + box[j]) % 256        k = box[t]        res.append(chr(s ^ k))    return (''.join(res))def random_num(seed_num):    random.seed(seed_num)    for i in range(36):        print(chr(int(str(random.random()*10000)[0:2]) ^ (data[i])))if __name__ == '__main__':    ciphertext = \"MjM184anvdA=\"    key = \"XR4\"    box = init_sbox(key)    a=decrypt(ciphertext, box)    random_num(int(a))# transposed_matrix=(data.reshape(6*6))^T# transposed_matrix=[[  1 111  38 110  95  44]#  [ 11  45  58  39  84   1]#  [116  19 113  60  91 118]#  [ 33  98  38  57  10  29]#  [ 68  52 119  56  43 125]#  [ 32  32   7  26  41  41]]\nç±»ä¼¼RC4çš„æµå¯†ç ï¼Œè§£å¯†æ€è·¯æ˜¯ç”¨å¯†é’¥XR4è§£å¯†å¯†æ–‡MjM184anvdA=è¿˜åŸå‡ºéšæœºæ•°ç§å­ï¼Œç”¨æ¥é‡ç½®éšæœºæ•°ç”Ÿæˆå™¨ï¼Œå†æ¢å¤çŸ©é˜µï¼Œæœ€åç”Ÿæˆéšæœºæ•°æµé€ä½å¼‚æˆ–å°±èƒ½å¾—åˆ°ç­”æ¡ˆï¼Œexp\nimport base64import randomimport numpy as np# RC4åˆå§‹åŒ–å‡½æ•°def init_sbox(key):    s_box = list(range(256))    j = 0    for i in range(256):        j = (j + s_box[i] + ord(key[i % len(key)])) % 256        s_box[i], s_box[j] = s_box[j], s_box[i]    return s_box# RC4è§£å¯†å‡½æ•°def decrypt(cipher, box):    res = []    i = j = 0    cipher_bytes = base64.b64decode(cipher)    for s in cipher_bytes:        i = (i + 1) % 256        j = (j + box[i]) % 256        box[i], box[j] = box[j], box[i]        t = (box[i] + box[j]) % 256        k = box[t]        res.append(s ^ k)    return bytes(res)if __name__ == '__main__':    # å·²çŸ¥å‚æ•°    ciphertext = \"MjM184anvdA=\"    key = \"XR4\"    transposed_matrix = np.array([        [1, 111, 38, 110, 95, 44],        [11, 45, 58, 39, 84, 1],        [116, 19, 113, 60, 91, 118],        [33, 98, 38, 57, 10, 29],        [68, 52, 119, 56, 43, 125],        [32, 32, 7, 26, 41, 41]    ])    # Step 1: è§£å¯†RC4è·å–ç§å­    box = init_sbox(key)    seed_bytes = decrypt(ciphertext, box.copy())    seed = int(seed_bytes.decode())    print(f\"[+] è§£å¯†ç§å­å€¼: {seed}\") # 78910112    # Step 2: æ¢å¤åŸå§‹çŸ©é˜µ    original_matrix = transposed_matrix.T.reshape(-1)  # è½¬ç½®æ¢å¤åŸå§‹é¡ºåº        # Step 3: ç”Ÿæˆéšæœºæ•°åºåˆ—    random.seed(seed)    flag_chars = []    for num in original_matrix:        rand_val = int(str(random.random() * 10000)[:2])  # ç”Ÿæˆå‰ä¸¤ä½æ•°å­—        flag_char = chr(rand_val ^ num)        flag_chars.append(flag_char)    # Step 4: ç»„åˆflag    flag = ''.join(flag_chars)    print(f\"\\n[+] è§£å¯†ç»“æœ: {flag}\") # c570ee41-8b09-11ef-ac4a-a4b1c1c5a2d2\nflag{c570ee41-8b09-11ef-ac4a-a4b1c1c5a2d2}\n2.essentialfrom Crypto.Util.number import *import sympyfrom flag import flaga=getPrime(512)p=sympy.nextprime(13*a)q=sympy.prevprime(25*a)number2=p*qdef crypto01(number1, number2, number3):    number4 = 1    while number2 &gt; 0:        if number2 % 2:             number4 = (number4 * number1) % number3        number1 = number1 ** 2 % number3        number2 //= 2    return number4# n1^n2 mod n3def crypto02(number1, number2):    number3 = number1    number4 = number2    giao = 1    giaogiao = 0    while number4 &gt; 0:        number7 = number3 // number4        giao, giaogiao = giaogiao, giao - giaogiao*number7        number3, number4 = number4, number3 - number4*number7    while giao&lt;0:        giao = giao + number2    return giao#pow(n1,-1,n2)def crypto03(number1, number2, number3):    number4 = crypto01(number3, number1, number2)    return number4# n3^n1 mod n2def crypto05(number1,number2):    return pow(number1,0xe18e,number2)# n1^e mod n2number2 = 20163906788220322201451577848491140709934459544530540491496316478863216041602438391240885798072944983762763612154204258364582429930908603435291338810293235475910630277814171079127000082991765275778402968190793371421104016122994314171387648385459262396767639666659583363742368765758097301899441819527512879933947number1 = 6035830951309638186877554194461701691293718312181839424149825035972373443231514869488117139554688905904333169357086297500189578624512573983935412622898726797379658795547168254487169419193859102095920229216279737921183786260128443133977458414094572688077140538467216150378641116223616640713960883880973572260683number3 = int.from_bytes(flag[0:19].encode(\"utf-8\"), \"big\")number4 = int.from_bytes(flag[19:39].encode(\"utf-8\"), \"big\")print(crypto03(number1, number2, number3))print(crypto05(number4,number2))#6624758244437183700228793390575387439910775985543869953485120951825790403986028668723069396276896827302706342862776605008038149721097476152863529945095435498809442643082504012461883786296234960634593997098236558840899107452647003306820097771301898479134315680273315445282673421302058215601162967617943836306076  p1#204384474875628990804496315735508023717499220909413449050868658084284187670628949761107184746708810539920536825856744947995442111688188562682921193868294477052992835394998910706435735040133361347697720913541458302074252626700854595868437809272878960638744881154520946183933043843588964174947340240510756356766  p2\nå¥—å±‚çš®çš„RSAï¼Œcrypto01è®¡ç®—çš„æ˜¯\n\nn_1^{n_2}\\;mod\\;n_3\\\\ crypto02è®¡ç®—çš„æ˜¯\n\nn_1^{-1}\\;mod\\;n_2\\\\ crypto03è®¡ç®—çš„æ˜¯\n\nn_3^{n_1}\\;mod\\;n_2\\\\ crypto05è®¡ç®—çš„æ˜¯\n\nn_1^e\\;mod\\;n_2\\\\è¿™é‡Œç»™å‡ºäº†\n\nn_1=pq,æ³¨æ„åˆ°aå°±512ä½ï¼Œä¸”è€ƒè™‘åˆ°è´¨æ•°åˆ†æ­¥åœ¨500å¤šä½ä¸‹éƒ½å¾ˆå¯†é›†ï¼Œpåº”è¯¥å¾ˆæ¥è¿‘13aï¼Œqå¾ˆæ¥è¿‘25aï¼Œé‚£ä¹ˆå°±å¯ä»¥å¯¹n1é™¤å»13*25å†å¼€æ ¹ï¼Œå¾—åˆ°ä¸€ä¸ªaçš„åˆæ­¥ä¼°è®¡ï¼Œå†å°è¯•æœç´¢å‡ºp,qçš„å€¼ï¼Œè„šæœ¬å¦‚ä¸‹\ndef find_a(n):    a_approx = gmpy2.isqrt(n // 325)    for delta in range(-1000, 1000):  # æœç´¢åç§»èŒƒå›´        a_candidate = int(a_approx) + delta        p = sympy.nextprime(13 * a_candidate)        q = sympy.prevprime(25 * a_candidate)        if p * q == n:            return a_candidate, p, q    return Nonea, p, q = find_a(n)print(f\"[+] Found a: {a}\")print(f\"p = {p}\\nq = {q}\")```[+] Found a: 7876724580534791771835430594434627088013471560469412207736963203935537053220379418645369259714178145931522503674390087394035229717461111762112820042426110p = 102397419546952293033860597727650152144175130286102358700580521651161981691864932442389800376284315897109792547767071136122457986326994452907466660551539601q = 196918114513369794295885764860865677200336789011735305193424080098388426330509485466134231492854453648288062591859752184850880742936527794052820501060652747```\næœ‰äº†p,qä¹‹åå°±æ˜¯å¾ˆåŸºç¡€çš„RSAè§£æ˜æ–‡äº†ï¼Œæ³¨æ„åˆ°eä¸phiä¸äº’ç´ ï¼Œä½†æ˜¯gcdå¾ˆå°ï¼Œå…ˆè¯•ç€ç”¨e//2ç®—ï¼Œå®åœ¨ä¸è¡Œå†å°è¯•æœ‰é™åŸŸå¼€æ ¹ï¼Œæ‰€å¹¸è¿™é‡Œç›´æ¥å°±ç®—å‡ºæ¥äº†,exp\np = 102397419546952293033860597727650152144175130286102358700580521651161981691864932442389800376284315897109792547767071136122457986326994452907466660551539601q = 196918114513369794295885764860865677200336789011735305193424080098388426330509485466134231492854453648288062591859752184850880742936527794052820501060652747number2 = 20163906788220322201451577848491140709934459544530540491496316478863216041602438391240885798072944983762763612154204258364582429930908603435291338810293235475910630277814171079127000082991765275778402968190793371421104016122994314171387648385459262396767639666659583363742368765758097301899441819527512879933947number1 = 6035830951309638186877554194461701691293718312181839424149825035972373443231514869488117139554688905904333169357086297500189578624512573983935412622898726797379658795547168254487169419193859102095920229216279737921183786260128443133977458414094572688077140538467216150378641116223616640713960883880973572260683c1 = 6624758244437183700228793390575387439910775985543869953485120951825790403986028668723069396276896827302706342862776605008038149721097476152863529945095435498809442643082504012461883786296234960634593997098236558840899107452647003306820097771301898479134315680273315445282673421302058215601162967617943836306076c2 = 204384474875628990804496315735508023717499220909413449050868658084284187670628949761107184746708810539920536825856744947995442111688188562682921193868294477052992835394998910706435735040133361347697720913541458302074252626700854595868437809272878960638744881154520946183933043843588964174947340240510756356766e=0xe18ephi = (p-1)*(q-1)print(GCD(number1,phi))d1 = inverse(number1,phi)m1 = pow(c1,d1,number2)d2 = inverse(e//2,phi)M2 = pow(c2,d2,number2)m2 = int(gmpy2.iroot(M2,2)[0])print(long_to_bytes(m1)+long_to_bytes(m2))#b'flag{75811c6d95770d56092817b75f15df05}'\nflag{75811c6d95770d56092817b75f15df05}\n3.EZ-calculatefrom Crypto.Util.number import *from random import randintfrom hashlib import md5flag1 = b'xxx'flag2 = b'xxx'Flags = 'flag{' + md5(flag1+flag2).hexdigest()[::-1] + '}'def backpack_encrypt_flag(flag_bytes, M, group_len):    bits = []    for byte in flag_bytes:        bits.extend([int(b) for b in format(byte, \"08b\")])    while len(bits) % group_len != 0:        bits.append(0)    S_list = []    for i in range(0, len(bits), group_len):        group = bits[i:i + group_len]        S = sum(bit * m for bit, m in zip(group, M))        S_list.append(S)    return S_listdef backpack(flag_bytes):    R = [10]    while len(R) &lt; 8:        next_val = randint(2 * R[-1], 3 * R[-1])        R.append(next_val)    B = randint(2 * R[-1] + 1, 3 * R[-1])    A = getPrime(100)    M = [A * ri % B for ri in R]    S_list = backpack_encrypt_flag(flag_bytes, M, len(M))    return R, A, B, M, S_listp = getPrime(512)q = getPrime(512)n = p*qe = 0x10000m = bytes_to_long(flag1)k = randint(1, 999)problem1 = (pow(p,e,n)-pow(q,e,n)) % nproblem2 = pow(p-q,e,n)*pow(e,k,n)c = pow(m,e,n)R, A, B, M, S_list = backpack(flag2)with open(r\"C:\\Users\\Rebirth\\Desktop\\data.txt\", \"w\") as f:    f.write(f\"problem1 = {problem1}\\n\")    f.write(f\"problem2 = {problem2}\\n\")    f.write(f\"n = {n}\\n\")    f.write(f\"c = {c}\\n\")    f.write(\"-------------------------\\n\")    f.write(f\"R = {R}\\n\")    f.write(f\"A = {A}\\n\")    f.write(f\"B = {B}\\n\")    f.write(f\"M = {M}\\n\")    f.write(f\"S_list = {S_list}\\n\")    f.write(\"-------------------------\\n\")    f.write(f\"What you need to submit is Flags!\\n\")\n\npart1\nRSA,é¢˜ç›®ç»™å‡ºçš„æ˜¯\n\np_1=(p^e-q^e)\\;mod\\;n\\\\\np_2=(p-q)^e\\;mod\\;n\\;\\;*\\;\\;e^k\\;mod\\;n\\\\\n\n  è¿™é‡Œæˆ‘ä»¬çš„æ€è·¯æ˜¯æšä¸¾kçš„å–å€¼ï¼Œè®¡ç®—å‡ºpow(e,k,n)ä¹‹åç”¨p2æ¥é™¤å®ƒï¼Œå¾—åˆ°Pï¼Œé‚£ä¹ˆç”±äºŒé¡¹å¼å®šç†\n\n  \\frac{p_2}{e^kmodn}=P\\;=(p-q)^e\\;mod\\;n=p^e+q^emod\\;n\\\\  ä¸Šä¸‹ç›¸åŠ ï¼Œå®¹æ˜“å¾—åˆ°\n\n  p_1+P=2p^emod\\;n\\\\\n  p=gcd(p_1+P,n)\\\\  åŒæ ·çš„æ–¹æ³•æˆ‘ä»¬ä¹Ÿèƒ½æšä¸¾å‡ºqï¼Œå†ç”¨ä½æ•°å’Œæ­£è´Ÿå·ä½œä¸ºåˆ¶çº¦å°±èƒ½çˆ†ç ´å‡ºp,qçš„å€¼ï¼Œè„šæœ¬å¦‚ä¸‹\n  problem1 = 24819077530766367166035941051823834496451802693325219476153953490742162231345380863781267094224914358021972805811737102184859249919313532073566493054398702269142565372985584818560322911207851760003915310535736092154713396343146403645986926080307669092998175883480679019195392639696872929250699367519967334248problem2 = 20047847761237831029338089120460407946040166929398007572321747488189673799484690384806832406317298893135216999267808940360773991216254295946086409441877930687132524014042802810607804699235064733393301861594858928571425025486900981252230771735969897010173299098677357738890813870488373321839371734457780977243838253195895485537023584305192701526016n = 86262122894918669428795269753754618836562727502569381672630582848166228286806362453183099819771689423205156909662196526762880078792845161061353312693752568577607175166060900619163231849790003982326663277243409696279313372337685740601191870965951317590823292785776887874472943335746122798330609540525922467021c = 74962027356320017542746842438347279031419999636985213695851878703229715143667648659071242394028952959096683055640906478244974899784491598741415530787571499313545501736858104610426804890565497123850685161829628373760791083545457573498600656412030353579510452843445377415943924958414311373173951242344875240776e=65536for i in range(1,1000):    k = pow(e,i,n)    Pr2 = problem2//k    # print(isinstance(Pr2,int))    sum = problem1+Pr2    sub = Pr2 - problem1    if sub&gt;0 :        q = GCD(sub,n)        print(q)# çˆ†ç ´p q#p = 9586253455468582613875015189854230646329578628731744411408644831684238720919107792959420247980417763684885397749546095133107188260274536708721056484419031#q = 8998523072192453101232205847855618180700579235012899613083663121402246420191771909612939404791268078655630846054784775118256720627970477420936836352759291\n  ç„¶åè¿™é‡Œeæ˜¯65536ï¼Œä¸å’Œphiäº’ç´ ï¼Œgcdæ˜¯4ï¼Œå°±è€ƒè™‘æœ‰é™åŸŸå¼€æ ¹ç„¶åç”¨crtç®—å¯èƒ½çš„è§£äº†ï¼Œè„šæœ¬å¦‚ä¸‹\n  from Crypto.Util.number import *from math import gcdfrom sage.all import *# ç»™å®šå‚æ•°p = 9586253455468582613875015189854230646329578628731744411408644831684238720919107792959420247980417763684885397749546095133107188260274536708721056484419031q = 8998523072192453101232205847855618180700579235012899613083663121402246420191771909612939404791268078655630846054784775118256720627970477420936836352759291n = p * qe = 65536c = 74962027356320017542746842438347279031419999636985213695851878703229715143667648659071242394028952959096683055640906478244974899784491598741415530787571499313545501736858104610426804890565497123850685161829628373760791083545457573498600656412030353579510452843445377415943924958414311373173951242344875240776possible_m = []def decrypt_rsa_with_coprime_e(p, q, e, c):    # è®¡ç®—æ¨¡på’Œæ¨¡qçš„cå€¼    c_p = c % p    c_q = c % q    # å¤„ç†æ¨¡pä¸‹çš„è§£    s_p = (p - 1) // 2  # å› ä¸ºp-1çš„2çš„æŒ‡æ•°ä¸º1    d_p = pow(e, -1, s_p)    m_p = pow(c_p, d_p, p)    solutions_p = [m_p, (-m_p) % p]    # å¤„ç†æ¨¡qä¸‹çš„è§£    s_q = (q - 1) // 2  # q-1çš„2çš„æŒ‡æ•°ä¸º1    d_q = pow(e, -1, s_q)    m_q = pow(c_q, d_q, q)    solutions_q = [m_q, (-m_q) % q]    # ä½¿ç”¨CRTç»„åˆæ‰€æœ‰å¯èƒ½çš„è§£    from itertools import product    possible_m = []    for mp, mq in product(solutions_p, solutions_q):        m = CRT([mp, mq], [p, q])        possible_m.append(m)    return possible_m    # æ‰§è¡Œè§£å¯†possible_m = decrypt_rsa_with_coprime_e(p, q, e, c)for m in possible_m:    print(long_to_bytes(m))# b'CRYPTO_ALGORIT'\n  ä¸è¿‡è·‘å‡ºæ¥bâ€™CRYPTO_ALGORITâ€™å°±æ˜¯ç¬¬ä¸€ä¸ªï¼Œæœ‰å¯èƒ½å¼€æ ¹ä¹Ÿèƒ½åšå‘¢\n\npart2\nèƒŒåŒ…åŠ å¯†ï¼Œä¸è¿‡è¯¥ç»™çš„éƒ½ç»™äº†ï¼ŒæŒ‰ç…§åŠ å¯†è¿‡ç¨‹åè¿‡æ¥å†™å¾ˆå¿«å°±èƒ½æå‡ºæ¥\nfrom Crypto.Util.number import long_to_bytesimport math# å·²çŸ¥å‚æ•°R = [10, 29, 83, 227, 506, 1372, 3042, 6163]A = 1253412688290469788410859162653B = 16036M = [10294, 12213, 10071, 4359, 1310, 4376, 7622, 14783]S_list = [13523, 32682, 38977, 44663, 43353, 31372, 17899, 17899, 44663, 16589, 40304, 25521, 31372]def backpack_decrypt(S_list, A, B, M):    # 1. éªŒè¯Aä¸Bäº’è´¨    assert math.gcd(A, B) == 1, \"A and B must be coprime\"        # 2. è®¡ç®—Açš„æ¨¡é€†å…ƒ    inv_A = pow(A, -1, B)        # 3. æ¢å¤è¶…é€’å¢åºåˆ—R    R_recovered = [(m * inv_A) % B for m in M]    print(\"æ¢å¤çš„R:\", R_recovered)  # åº”ç­‰äºåŸå§‹R        # 4. è§£å¯†æ¯ä¸ªSå€¼    bits = []    for S in S_list:        # å°†Sè½¬æ¢ä¸ºè¶…é€’å¢èƒŒåŒ…é—®é¢˜        S_prime = (S * inv_A) % B                # è´ªå¿ƒç®—æ³•è§£èƒŒåŒ…        group = []        remaining = S_prime        for r in reversed(R_recovered):            if remaining &gt;= r:                group.append(1)                remaining -= r            else:                group.append(0)        bits.extend(group[::-1])  # åè½¬ååŠ å…¥        # 5. è½¬æ¢äºŒè¿›åˆ¶ä¸ºå­—èŠ‚    bytes_data = b''    for i in range(0, len(bits), 8):        byte_bits = bits[i:i+8]        if len(byte_bits) &lt; 8:            byte_bits += [0]*(8 - len(byte_bits))        byte = int(''.join(map(str, byte_bits)), 2)        bytes_data += bytes([byte])        # 6. å»é™¤å¡«å……çš„é›¶    return bytes_data.rstrip(b'\\x00')# æ‰§è¡Œè§£å¯†flag2 = backpack_decrypt(S_list, A, B, M)print(\"è§£å¯†ç»“æœ:\", flag2.decode())# HMS_WELL_DONE\næœ€åå¯¹ä¸¤ä¸ªflagæ‹¼æ¥ä¹‹åå–md5ï¼Œflag{64f67374264b7621650b1de4dbc5f924}\n\n\n4.merge_ECC#t.sageimport randomfrom sympy import nextprimedef part1():    p = random_prime(2^512, 2^513)    a = random.randint(0, p-1)    b = random.randint(0, p-1)    while (4 * a**3 + 27 * b**2) % p == 0:        a = random.randint(0, p-1)        b = random.randint(0, p-1)    E = EllipticCurve(GF(p), [a, b])#æ„é€ ä¸€ä¸ªæ¨¡pç¯ä¸‹çš„å…³äºa,bçš„æ¤­åœ†æ›²çº¿    P=E.random_point()#æ›²çº¿ä¸Šçš„éšæœºä¸€ä¸ªç‚¹    n = [random.randint(1, 2**20) for _ in range(3)] #éšæœºçš„ä¸€ä¸ªç‚¹    assert part1=''.join([hex(i)[2:] for i in n])    cipher = [n[i] * P for i in range(3)]    print(f\"N = {p}\")    print(f\"a = {a}, b = {b}\")    print(f\"P = {P}\")    for i in range(3):        print(f\"cipher{i} = {cipher[i]}\")# CRTdef part2():    p =  839252355769732556552066312852886325703283133710701931092148932185749211043    a =  166868889451291853349533652847942310373752202024350091562181659031084638450    b =  168504858955716283284333002385667234985259576554000582655928538041193311381    P = E.random_point()    Q = key*P    print(\"p = \",p)    print(\"a = \",a)    print(\"b = \",b)    print(\"P = \",P)    print(\"Q = \",Q)    assert part2=keypart1()print(\"-------------------------------------------\")part2()assert flag=\"flag{\"+str(part1)+\"-\"+str(part2)+\"}\"\nè€ƒå¯Ÿçš„æ˜¯æœ‰å…³ECCçš„ä¸¤ç§ç‰¹æ®Šæ”»å‡»æ–¹æ³•\n\npart1\næ”»å‡»çš„æ€è·¯æ˜¯Pohlig-Hellmanæ”»å‡»ï¼Œè¦æ±‚æ˜¯æ›²çº¿çš„é˜¶æœ‰å°å› æ•°ï¼Œè¿™é‡ŒE.orderè®¡ç®—å‡ºæ¥æ˜¯512ä½ï¼Œä¸¢yafuåˆ†è§£ä¹‹åå‘ç°æœ‰7ä¸ªå› å­ï¼Œå…¶ä¸­5ä¸ªæ¯”è¾ƒå°ï¼Œä¸”å…¨éƒ¨ä¹˜èµ·æ¥ä¹‹åæ˜¯æ¯”è¦å¤§çš„ï¼Œå› æ­¤æˆ‘ä»¬å°±å¯ä»¥å–å°çš„5ä¸ªå› å­æ¥è¿›è¡Œæ”»å‡»ï¼Œè„šæœ¬å¦‚ä¸‹\nfrom sage.all import *from Crypto.Util.number import *n = 8186762541745429544201163537921168767557829030115874801599552603320381728161178278432652391299286759969365150578265902315058515370390070500719061057476940print(n.bit_length())# 2*2*5*11*499*683*124696170958113532210068667*875618937758378886905025632349007870524674918888468835522805095350653442872611049093102429356717528012933133846029979343# æ¤­åœ†æ›²çº¿å‚æ•°p = 8186762541745429544201163537921168767557829030115874801599552603320381728161132002130533050721684554609459754424458805702284922582219134865036743485620797a = 1495420997701481377470828570661032998514190598989197201754979317255564287604311958150666812378959018880028977121896929545639701195491870774156958755735447b = 5991466901412408757938889677965118882508317970919705053385317474407117921506012065861844241307270755999163280442524251782766457119443496954015171881396147E = EllipticCurve(GF(p), [a, b])# ç”Ÿæˆå…ƒå’Œå¯†æ–‡ç‚¹P = E(    6053058761132539206566092359337778642106843252217768817197593657660613775577674830119685211727923302909194735842939382758409841779476679807381619373546323,    7059796954840479182074296506322819844555365317950589431690683736872390418673951275875742138479119268529134101923865062199776716582160225918885119415223226)cipher0 = E(    4408587937721811766304285221308758024881057826193901720202053016482471785595442728924925855745045433966244594468163087104593409425316538804577603801023861,    5036207336371623412617556622231677184152618465739959524167001889273208946091746905245078901669335908442289383798546066844566618503786766455892065155724816)cipher1 = E(    2656427748146837510897512086140712942840881743356863380855689945832188909581954790770797146584513962618190767634822273749569907212145053676352384889228875,    4010263650619965046904980178893999473955022015118149348183137418914551275841596653682626506158128955577872592363930977349664669161585732323838763793957500)cipher2 = E(    1836350123050832793309451054411760401335561429787905037706697802971381859410503854213212757333551949694177845513529651742217132039482986693213175074097638,    1647556471109115097539227566131273446643532340029032358996281388864842086424490493200350147689138143951529796293632149050896423880108194903604646084656434)# å·²çŸ¥é˜¶çš„åˆ†è§£ï¼ˆæ’é™¤æœ€åä¸¤ä¸ªå¤§å› å­ï¼‰primes = [4, 5, 11, 499, 683]  # 2^2, 5, 11, 499, 683def pohlig_hellman(P, Q, primes):    dlogs = []    for fac in primes:        t = P.order() // fac        PP = t * P        QQ = t * Q        dlog = PP.discrete_log(QQ)  # è‡ªåŠ¨é€‰æ‹©æœ€ä½³ç®—æ³•        dlogs.append(dlog)        print(f\"Factor: {fac}, Discrete Log: {dlog}\")    return crt(dlogs, primes)# è®¡ç®—ä¸‰ä¸ªç¦»æ•£å¯¹æ•°print(\"è®¡ç®—n0:\")n0 = pohlig_hellman(P, cipher0, primes)print(\"\\nè®¡ç®—n1:\")n1 = pohlig_hellman(P, cipher1, primes)print(\"\\nè®¡ç®—n2:\")n2 = pohlig_hellman(P, cipher2, primes)# éªŒè¯ç»“æœassert cipher0 == n0 * Passert cipher1 == n1 * Passert cipher2 == n2 * P# æ‹¼æ¥ç»“æœpart1 = hex(n0)[2:] + hex(n1)[2:] + hex(n2)[2:]print(\"\\nè§£å¯†ç»“æœ:\", part1)# f61bd9f152e65ac\n\npart2\nsmartæ”»å‡»ï¼Œè¿™é‡Œæ›²çº¿è®¡ç®—å‡ºæ¥é˜¶å’Œæ¨¡æ•°ç›¸åŒï¼Œè„šæœ¬å¦‚ä¸‹\nfrom sage.all import *from Crypto.Util.number import *from gmpy2 import *p =  839252355769732556552066312852886325703283133710701931092148932185749211043a =  166868889451291853349533652847942310373752202024350091562181659031084638450b =  168504858955716283284333002385667234985259576554000582655928538041193311381E = EllipticCurve(GF(p), [a, b])r = E.order()# 839252355769732556552066312852886325703283133710701931092148932185749211043print(r)P =  E(547842233959736088159936218561804098153493246314301816190854370687622130932 , 259351987899983557442340376413545600148150183183773375317113786808135411950 )Q =  E(52509027983019069214323702207915994504051708473855890224511139305828303028 , 520507172059483331872189759719244369795616990414416040196069632909579234481 )def SmartAttack(P,Q,p):    E = P.curve()    Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ])    P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True)    for P_Qp in P_Qps:        if GF(p)(P_Qp.xy()[1]) == P.xy()[1]:            break    Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True)    for Q_Qp in Q_Qps:        if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]:            break    p_times_P = p*P_Qp    p_times_Q = p*Q_Qp    x_P,y_P = p_times_P.xy()    x_Q,y_Q = p_times_Q.xy()    phi_P = -(x_P/y_P)    phi_Q = -(x_Q/y_Q)    k = phi_Q/phi_P    return ZZ(k)r = SmartAttack(P, Q, p)print(r)# 7895892011\nflag{f61bd9f152e65ac-7895892011}\n\n\n\n\n*5.logos2023èµ£æ”¿æ¯åŸé¢˜ï¼Œè¿™é‡Œæ˜¯åˆ«çš„å¸ˆå‚…å†™çš„åšå®¢2023èµ£æ”¿æ¯ â€”- Crypto_èµ£æ”¿æ¯2023-CSDNåšå®¢\nè¿˜åœ¨è¢«sagemathå„ç§ç¯å¢ƒé—®é¢˜æŠ˜ç£¨ï¼Œå°±æš‚æ—¶ä¸ç»†å†™äº†\n","categories":["WP"],"tags":["CTF","Crypto","ECC","DLP"]},{"title":"WHUCTF2025","url":"/2025/04/14/WHUCTF2025/","content":"WHUCTF2025å¤ç›˜\n\nLSFR_Signin\n\nåŸé¢˜ä»£ç å¦‚ä¸‹\nfrom Crypto.Util.number import *flag = b\"whuctf{}\"flag = list(bin(bytes_to_long(flag))[2:])assert(len(flag) == 255)for i in range(len(flag)):    flag[i] = int(flag[i])for i in range(2025):    flag.append(flag[i] ^ flag[i+20] ^ flag[i+25] ^ flag[i+250] ^ flag[-1])    print(flag[-1], end=\"\")\nå·²çŸ¥flagä¸º255ä½ï¼Œå¯¹äºçº¿æ€§å¯„å­˜å™¨ï¼Œæ ¹æ®i i+20 i+25 i+250 ä»¥åŠæœ€åä¸€ä½å°±èƒ½è§£å‡ºä¸‹ä¸€ä½ï¼Œäºæ˜¯æˆ‘ä»¬ä»ç¬¬256ä½å¼€å§‹å¾€åï¼Œæœ‰\n\nflag_i = flag_{i+20} xor flag_{i+25}xorflag_{i+250}xorflag_{i+254}xorflag_{i+256}iå–0åˆ°254ï¼Œè€Œæˆ‘ä»¬å·²çŸ¥255~2280ä½ï¼Œå–255~510ä½æ¥è§£å¯†å°±å¯ä»¥ï¼Œè„šæœ¬å¦‚ä¸‹\nfrom Crypto.Util.number import long_to_bytes# åˆå§‹åŒ–é•¿åº¦ä¸º255çš„å…¨0æ•°ç»„s = [0] * 255# ç»™å®šçš„01ä¸²bit_string = \"110000011011110000010101100011111101011011111111111111101011000111001010111000101111101100011011000110011000100010011111110111010110000111111111111101111011011101000000010011110010111000110100110011101110101010110001110100111001100011100001001000000011010011001101001000000000110110100101000110000011011100011100001000010001110000111110000110010001110001101011101110100011010000101101000000000001101111111001010100011110110001101010010100011010011010010110010110100011001100010010010110110010010001111010111100011101100001111111110101011010011111110101000110010000101011011101000000111000001011010010001010101101111111001100010001001011100100111000010100011001001111011110111111101100111001011100001110110110100010011010011111110010111001101000011000011111001101100111001111000010011110011111001010001111110001010100100011001000100011001010010111010000011101011001111111010010010101001010011010000010000100001010111000000000010011011110110001101010010101001010100100010110001001000101000001011111010110101110111100101001100101011000010000101010001010111010111010010110001111010000001101101100101111001010010010011010101110001101001111011010001000010111010011010001011011011000111101010001101110000100100011010011111110110000001101100010011000110100010101010010101100101011001001100010100111011101111100010111100010001101100101100111110101001111101000010110110011000111100110101001111001100110111100111111000101101101000011110011001101100111100111001001001001100101111101110111011111110110101000001100010110101101100100001110100110101100101011010101101101100011011000001111001010001110000110001001011001001110111110000001000011000011000101010101010010010100010011011000011100111011101111110100101111111001011010110010010011101011001011110001101110110110111110100000100001111100101000001101010000011001001100100010101111010100000010110010010111000000010010101001011001011001111001000100010100101000011110110101001011111011111001010111101111000001101101100101111010101100110000111011101100100000011001110011000110110100101010100\"# å°†01ä¸²æ·»åŠ åˆ°æ•°ç»„åé¢for i in range(len(bit_string)):    s.append(int(bit_string[i]))# ä»i=254å¼€å§‹å‘å‰è®¡ç®—for i in range(254, -1, -1):    s[i] = s[i+20] ^ s[i+25] ^ s[i+250] ^ s[i+254] ^ s[i+255]# æˆªå–å‰255ä½å¹¶è½¬æ¢ä¸ºå­—ç¬¦ä¸²result_bits = ''.join(str(bit) for bit in s[:255])# è½¬æ¢ä¸ºé•¿æ•´å‹ç„¶åè½¬ä¸ºå­—èŠ‚result_long = int(result_bits, 2)result_bytes = long_to_bytes(result_long)print(result_bytes)#whuctf{quit3_ea5y_Sign1n_R1ght?}\n\nRSAASR\n\né¢˜å¹²ï¼š\nfrom Crypto.Util.number import getPrime, isPrime, bytes_to_long, long_to_bytesdef generate(bit):    while True:        p = getPrime(bit)        q = rev(p)        if isPrime(q):            break    return p, qrev = lambda x: int(bin(x)[:1:-1], 2)  # äºŒè¿›åˆ¶åè½¬æ•´æ•°flag = b\"??????\"p, q = generate(512)n = p * qe = 65537c = pow(bytes_to_long(flag), e, n)print(f\"n={n}\")print(f\"e={e}\")print(f\"c={c}\")\npå’ŒqäºŒè¿›åˆ¶é¢ å€’ï¼Œé‡‡ç”¨çˆ†ç ´çš„æ€è·¯ï¼ŒåŒæ—¶ä¼°è®¡p qçš„èŒƒå›´ï¼Œå¹¶ä¸”æ¯æ¬¡å–p qçš„ä½kä½ï¼ˆkä¸ºå·²ç»çˆ†ç ´å‡ºæ¥çš„ä½ï¼‰ç›¸ä¹˜ï¼Œå¯¹ç»“æœå–ä½kä½ï¼Œå¦‚æœå’Œnçš„ä½kä½ç›¸åŒå°±ç»§ç»­ï¼Œä¸åŒå°±å‰ªå»ï¼Œä»£ç å¦‚ä¸‹ï¼Œæ¿å­å‚ç…§åšå®¢ï¼šCryptoè¶£é¢˜-å‰ªæ | ç³–é†‹å°é¸¡å—çš„blog (tangcuxiaojikuai.xyz)\nfrom Crypto.Util.number import *import syssys.setrecursionlimit(1500)n=89260288112458610375700543707493254232809306221431627423709616690294586688526862549905410606087786699242563057156677052913617284849136716660502920085006747882186134482309361626185003661858419446057779826705477210404882478906671799290032009310469036065257789664458482249297907582602310789531951177426393110643e=65537c=34953739673730018843655174314108340461262205663805875643136393046216892771730195951086950749299233260612871271352091804579992550715616098448464010205976283620661044089962336249776561849400241337436006809354102892524119722533361144592982143227173415365371111087024439252557012289555411199194971295453523635612def find(ph,qh):    l = len(ph)    pl = qh[::-1]    ql = ph[::-1]    p_max = ph + (512-2*l)*'1' + pl    q_max = qh + (512-2*l)*'1' + ql    p_min = ph + (512-2*l)*'0' + pl    q_min = qh + (512-2*l)*'0' + ql    if(int(p_max,2) * int(q_max,2) &lt; n):        return    if(int(p_min,2) * int(q_min,2) &gt; n):        return    if(int(pl,2) * int(ql,2)  %  (2**(l-1)) != n % (2**(l-1))):        return        if(l == 256):        pp0 = int(p_max,2)        if(n % pp0 == 0):            pf = pp0            qf = n//pp0            phi = (pf - 1)*(qf - 1)            d = inverse(e,phi)            m1 = pow(c,d,n)            print(long_to_bytes(m1))            exit()    else:        find(ph+'1',qh+'1')        find(ph+'1',qh+'0')        find(ph+'0',qh+'1')        find(ph+'0',qh+'0')find('1','1')# WHUCTF{cryptography_and_reverse}\n\n*ez_lattice\n\næ ¼å¯†ç ç›¸å…³ï¼Œé¢˜å¹²\nfrom Crypto.Util.number import *flag = b\"whuctf{}\"blen = 512l = len(flag) // 4 #æœªçŸ¥n = 2X = []a = [bytes_to_long(flag[i * l: i * l + l]) for i in range(2)] #åˆ‡æˆä¸¤éƒ¨åˆ†b = 0p = getPrime(blen)for i in range(2):    X.append(getRandomNBitInteger(blen))    b = (a[i] * X[i]) % p       assert b.bit_length() &lt; 110print(\"p =\", p)print(\"X =\", X) # p = 12478746590758967738992827236548867094406642228843048782158822830242432957850861746109083849369751421558416546441433265483311369062332823391326650330844473# X = [4370703796271085517745653374714633557060694569231794372714420305839580193452505356598920188429238758568075323630107438853033389535935767953293146851021439, 5636765597544539887670148818611437395262628189014720546978418282055551396918915796702935478309173130501906553399905160951176701403838275497327658585404887]n = 2X = []a = [bytes_to_long(flag[i * l: i * l + l]) for i in range(2, 4)]print(a)p = getPrime(blen)for i in range(n):    X.append(getRandomNBitInteger(blen))    b = (a[i] * X[i]) % p    assert b.bit_length() &lt;= 55s = getRandomNBitInteger(55)P = p - sprint(\"P =\", P)print(\"X =\", X)# P = 8064317391291915578249751043887298750752952396481901402238164933671762816998644264248732894561122039999833298392825353792148892469165631966482732750535761# X = [6042201174605160506707043360458329015685676206288676104013330039569480295420873678739841513174948925787517746114885517054730046775608073287427260847787072, 6232867934334525782602291010514616748943593081406115516232887372014738839717093295759414233886061184914495957664550361507367497641317336980894814940037711]\nç®€å•åˆ†æå¯çŸ¥åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼Œå‰åŠæ®µæ˜¯\n\nb = kp+a_iX_iæœ¬è´¨æ˜¯ä¸¤ä¸ªæ–¹ç¨‹ï¼Œè¿™é‡Œæœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥è§£å†³ï¼Œéƒ½å†™ä¸€ä¸‹\n\n1.æ ¹æ®ä¸¤ä¸ªæ–¹ç¨‹é€ 3*3çš„æ ¼å­\nå°†ä¸Šå¼å±•å¼€ï¼Œæœ‰\n\n\\begin{aligned}\nb &= kp + a_1 X_1 \\\\\nb &= kp + a_2 X_2\n\\end{aligned}è§‚å¯Ÿå¼å­ï¼Œä¸éš¾å¾—åˆ°çŸ©é˜µè¿ç®—å¼\n\n(a_1,a_2,k)\\begin{pmatrix}\n1&0&X_1\\\\\n0&1&X_2\\\\\n0&0&p\n\\end{pmatrix}=(a_1,a_2,2b)æ¥ä¸‹æ¥è¿ç”¨Hermite\nä¸Šç•Œä¸º ,å¤§æ¦‚æ˜¯170ä½ï¼Œå³è¾¹çš„ç›®æ ‡å‘é‡é•¿åº¦å–å†³äºa1,a2,bä½†è‚¯å®šä¸ä¼šè¶…è¿‡ä¸Šç•Œï¼Œæˆ‘ä»¬å¯ä»¥å…ˆè§£ä¸€ä¸‹çœ‹çœ‹\n\n\nX1 = X[0]X2 = X[1]# æ„é€  3Ã—3 æ ¼åŸºL = Matrix(ZZ, [    [1, 0, X1],    [0, 1, X2],    [0, 0, p]])a1 = L.LLL()[0][0]a2 = L.LLL()[0][1]a1 = abs(a1)a2 = abs(a2)print(long_to_bytes(a1))print(long_to_bytes(a2))#b'whuctf{'#b'Lattice'\n\nä¸€ä¸ªæ€è·¯æ›´ç®€å•çš„æ€è·¯ï¼Œæ„Ÿè°¢(zijeff (github.com))\n\nL0 = Matrix(ZZ,[    [1,X[0]],    [0,p]])M0 = L0.LLL()[0]  v0 = L0.solve_left(M0) for i in range(1,10000):    a0 = abs(v0[0]) * i    m0 = long_to_bytes(int(a0))    tag = True    for m in m0:        if not chr(m) in string.printable:            tag = false            break    if tag:        print(long_to_bytes(int(a0)))\n\n*pollard&amp;williams\n\nfrom Crypto.Util.number import *import osflag = b'whuctf{}'blen = 256def rsa(p, q, message):    n = p * q    e = 65537    pad_length = n.bit_length() // 8 - len(message) - 2 #å—é•¿ä¸º nçš„é•¿åº¦é™¤8ï¼ˆå­—èŠ‚æ•°ï¼‰ å‡å»mesé•¿åº¦å†å‡2    message += os.urandom(pad_length) #ç”Ÿæˆpad_lengthä¸ªéšæœºå­—èŠ‚    m = bytes_to_long(message)    return n, pow(m, e, n)def part1(message1, message2):    while True:        p1 = getPrime(blen)        p2 = (p1 - 1) // 2 #ç›¸å½“äºp1å³ç§»ä¸€ä½ï¼Œä¸”æ”¾æ‰æœ€ä½ä½        if isPrime(p2):            break    q1 = getPrime(blen)    q2 = getPrime(blen)    return rsa(p1, q1, message1), rsa(p2, q2, message2)def part2(message1, message2):    while True:        p1 = getPrime(blen)        p2 = (p1 + 1) // 2 #æ²¡æœ‰æ˜æ˜¾å…³ç³»        if isPrime(p2):            break    q1 = getPrime(blen)    q2 = getPrime(blen)    return rsa(p1, q1, message1), rsa(p2, q2, message2)assert len(flag) == 44l = len(flag) // 4m1, m2, m3, m4 = [flag[i * l: i * l + l] for i in range(4)]# åˆ‡æˆå››æ®µc1, c2 = part1(m1, m2)c3, c4 = part2(m3, m4)print(f'{c1 = }')print(f'{c2 = }')print(f'{c3 = }')print(f'{c4 = }')# c1 = (6053032598894343876848386724367478876865502990878797490385487692233771017587839889683279773931697102081210221515871925626229356354906807395177342943323369, 4066195854081844630643812355140109730178549671457699640787009592379117222130777528564788537029636082768525403919530491221982157867347461546035515101540809)# c2 = (3881600892538209342174115382004433032693183438455968854185245139152150453077746028435728337685187304179257593974737056409431270271087770400534952463611803, 3170419555737452151768856928448822332346045957475336562622244748908867061340721719260259808765271614258250388620180512676045609008728482012225062330421389)# c3 = (12299016617136978588548772285625358530978334196485520160172325214608426825374255755330322407319092229940503630270734074076341447314630647646764214262929507, 318163940794629731124968470499655451861010987042419720693423620230895540439020747998494269609254222775880714679954773027280497632868550785421041286883861)# c4 = (4549315768074822845197072475333248869579555413221208949230121240611191001190288208256119819724334902434536556333152862828649067092565476816480268615884657, 1882968780168858989700488482275734089425710600149658668167954773629584030303631176914870357507995175067079535271674721507969999430710585448040194277936142)\nåŸºäºpollard p-1å’Œwillams p+1ä¸¤ä¸ªå¤§æ•°åˆ†è§£ç®—æ³•\n\n1\nå¯çŸ¥ ç”±æ¬§æ‹‰å®šç†ä¸éš¾å¾—åˆ°\n\n2^{2n_2} = 2^{p_1-1} \\equiv 1 \\;(modp_1)\\\\\np_1\\;|\\;2^{2n_2}-1\\\\\np_1 = gcd(n_1,2^{2n_2-1})ç›´æ¥ç®—å°±è¡Œï¼Œä»£ç å¦‚ä¸‹\np1 = gmpy2.gcd(gmpy2.powmod(3, 2 * n2, n1) - 1, n1)p2 = (p1 - 1) // 2q1 = n1 // p1q2 = n2 // p2\n\n2\nè¯æ˜æ¯”è¾ƒç¹çï¼Œå…ˆç»™å‡ºç»“è®º\nå¯¹äºå¦‚ä¸‹Lucasåºåˆ—\n\nV_0 = 2\\\\\nV_1 = A\\\\\nV_n = AV_{n-1}-V_{n-2}\\\\ä»¤,è‹¥  æœ‰ \n\np\\;| gcd(V_m-2,n) \\;\\; p|n\\;\\;å…¶ä¸­p-(\\frac D p )|m\\;\\;(\\frac D p )ä¸ºå‹’è®©å¾·ç¬¦å·\n\næ€è·¯å°±æ˜¯ï¼Œæšä¸¾Aï¼Œ1åˆ°15å¾€å¾€å°±å¤Ÿäº†ï¼Œæ‰¾åˆ°ä¸€ä¸ªDä¸æ˜¯pçš„äºŒæ¬¡å‰©ä½™ï¼Œä¹Ÿå°±æ˜¯æœ‰\nè¿™é‡Œæˆ‘ä»¬å®¹æ˜“å‘ç°,é‚£ä¹ˆ2n2å°±æ˜¯æˆ‘ä»¬ä»£å…¥çš„mï¼Œæ¥ä¸‹æ¥ç”¨æˆ‘ä»¬æšä¸¾çš„A,æ‰¾åˆ°çš„mæ¥è¿­ä»£è¿ç®—lucasåºåˆ—ï¼Œæ±‚å‡ºæ¥ä¹‹ååšä¸¤æ¬¡gcdå³å¯ï¼Œæœ€ç»ˆ\n\np_1 = gcd(gcd(V_{2n_2}\\;-\\;2,n_1)\\;,\\;n_1)è„šæœ¬åœ¨è¿™é‡Œ\ndef lucas_v(a,n):    v0 = 2    v1 = a    R = ZZ     M = matrix(R,[[a,-1],[1,0]])     v = M**(n-1) * vector(R,[v1,v0])    return v[0]for a in range(2,10):    p3 = ZZ(gcd(lucas_v(a,2 * n4) - 2, n3))    if 1&lt; p3 &lt; n3:        breakp4 = (p3+1) // 2q3 = n3 // p3q4 = n4 // p4     \n\n*seistaâ€™s revenge\n\nfrom Crypto.Util.Padding import padfrom Crypto.Util.number import *from Crypto.Cipher import AESfrom hashlib import *flag = b\"whuctf{}\"blen = 512p = getPrime(blen)s = getRandomNBitInteger(100)P = p + st = 2X = []a = [getPrime(160) for _ in range(t)]for i in range(t):    X.append(inverse(a[i], p))key = sha256(str(a[0]*a[1]).encode()).digest()[:16]iv = b\"0\" * 16AES = AES.new(key, AES.MODE_CBC, iv)print(\"X =\", X)print(\"P =\", P)print(\"ct =\", AES.encrypt(pad(flag, AES.block_size)))# X = [1266403423628708294851978766647131186574350037928491893316575383770634141679199238688724846443316942748685589080912612989737322832820423142859211423222170, 10633805933378187507165706136587361125130747673943368523389315948924728188453225153073019422908293191827053741582511390426559341625596650317484672418362991]# P = 12727949469666331910572325155797935927989546075198211256583307434798528241134917675474139742863165705376701853130873014549089300596914514323642506815012401# ct = b'\\xe9\\x87\\x942\\xbc\\x94`t\\x85^r\\xb8\\xd2\\x00\\xfb\\xb0Ni\\x08\\xcf\\x07\\xf1\\xae\\x95U{\\xf1\\xd4\\xda}@H'# Lattice\nez_latticeçš„part2ç¨å¾®æ”¹äº†ä¸€ä¸‹ä¸Šæ¥çš„ï¼Œæ±‚a0,a1å°±å¯ä»¥äº†\nè¿™é‡Œæœ‰\n\na_iX_i \\equiv 1\\;\\;mod p\\\\å…¶å®ä¸è®ºbæ€ä¹ˆæ ·ï¼Œæˆ‘ä»¬éƒ½æ˜¯ç”¨ç±»ä¼¼çš„æ–¹æ³•æ±‚è§£\nfrom Crypto.Util.number import *import gmpy2from sage.all import *import libnumimport stringfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadfrom hashlib import sha256X = [1266403423628708294851978766647131186574350037928491893316575383770634141679199238688724846443316942748685589080912612989737322832820423142859211423222170, 10633805933378187507165706136587361125130747673943368523389315948924728188453225153073019422908293191827053741582511390426559341625596650317484672418362991]P = 12727949469666331910572325155797935927989546075198211256583307434798528241134917675474139742863165705376701853130873014549089300596914514323642506815012401ct = b'\\xe9\\x87\\x942\\xbc\\x94`t\\x85^r\\xb8\\xd2\\x00\\xfb\\xb0Ni\\x08\\xcf\\x07\\xf1\\xae\\x95U{\\xf1\\xd4\\xda}@H'# è¿™é‡Œsåªæœ‰100ä½ï¼Œå¯ä»¥ä¼°è®¡äºŒè€…æ˜¯å‡ ä¹ç›¸ç­‰çš„L0 = Matrix(ZZ,[    [1,X[0]],    [0,P]])M0 = L0.LLL()W0 = M0[0]v0 = L0.solve_left(W0) L1 = Matrix(ZZ,[    [1,X[1]],    [0,P]])M1 = L1.LLL()W1 = M1[0]v1 = L1.solve_left(W1)for i in range(1,10000):    a = abs(v0[0] * v1[0]) * i    key = sha256(str(a).encode()).digest()[:16]    iv = b\"0\" * 16    AES_cipher = AES.new(key, AES.MODE_CBC, iv)    decrypted_data = unpad(AES_cipher.decrypt(ct), AES.block_size)    m0 = decrypted_data.decode()    tag = True    for m in m0:        if not m in string.printable:            tag = false            break    if tag:        print(m0)        # whuctf{You_w1ll_never_kn0w_1t!}\n\nonlyAES\n\näº¤äº’é¢˜ï¼Œä»£ç å¦‚ä¸‹\nimport osimport socketimport threadingfrom Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad, unpadfrom string import ascii_lowercaseglobal flagdef xor(a, b):    if len(a) &lt; len(b):        a, b = b, a    c = []    for i in range(len(a)):        c.append(a[i] ^ b[i % len(b)])    return bytes(c)class myAES:    def __init__(self):        self.flag = flag        self.key = get_random_bytes(16)        self.cipher = AES.new(self.key, AES.MODE_ECB)    def encrypt1(self, data):        \"\"\"å…ˆå¼‚æˆ–flagï¼Œå†åŠ å¯†\"\"\"        data = xor(data, self.flag)        pdata = pad(data, AES.block_size)        return self.cipher.encrypt(pdata).hex().encode()    def encrypt2(self, data):        \"\"\"æ‹¼æ¥flagï¼Œå°†æ¯ä¸ªå—çš„åŠ å¯†ç»“æœå¼‚æˆ–å¾—åˆ°æœ€ç»ˆç»“æœ\"\"\"        data = data + self.flag        pdata = pad(data, AES.block_size)        c = self.cipher.encrypt(pdata)        C = [c[i : i + 16] for i in range(0, len(c), 16)]        for i in range(1, len(C)):            C[0] = xor(C[0], C[i])        return C[0].hex().encode()def challenge(client: socket.socket):    cipher = myAES()    client.sendall(b\"Here is an AES system, try hack it !\\n\")    client.sendall(b\"\\t1. Encrypt 1  \\n\")    client.sendall(b\"\\t2. Encrypt 2  \\n\")    while 1:        try:            client.sendall(b\"your choice &gt; \")            try:                cho = int(client.recv(1024).decode().strip())            except ValueError:                client.sendall(b\"Invalid choice!\\n\")                continue        except:            break        if cho == 1:            client.sendall(b\"Input your data(hex): \")            try:                data = bytes.fromhex(client.recv(1024).strip().decode())                if len(data) == 0:                    client.sendall(b\"No input!\\n\")                    continue                client.sendall(b\"Encrypted data(hex): \" + cipher.encrypt1(data) + b\"\\n\")            except Exception as e:                print(e)                client.sendall(b\"Invalid data!\\n\")        elif cho == 2:            client.sendall(b\"Input your data(hex): \")            try:                data = bytes.fromhex(client.recv(1024).strip().decode())                if len(data) == 0:                    client.sendall(b\"No input!\\n\")                    continue                client.sendall(b\"Encrypted data(hex): \" + cipher.encrypt2(data) + b\"\\n\")            except Exception as e:                print(e)                client.sendall(b\"Invalid data!\\n\")                continue        else:            client.sendall(b\"Invalid choice!\\n\")            continuedef main():    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    server.bind((\"0.0.0.0\", 2025))    server.listen(2)    server.settimeout(5)    try:        while True:            try:                client, addr = server.accept()                client_thread = threading.Thread(target=challenge, args=(client,))                client_thread.start()            except socket.timeout:                pass    except KeyboardInterrupt:        server.close()if __name__ == \"__main__\":    flag = os.getenv(\"GZCTF_FLAG\")    flag = flag.lstrip(\"WHUCTF{\").rstrip(\"}\")    charset = ascii_lowercase + \"_\"    assert len(flag) % 16 == 3    assert all(c in charset for c in flag)    flag = flag.encode()    main()\nå¯è§å°±æ˜¯é€‰æ‹©ä¸€ç§åŠ å¯†æ–¹å¼ï¼Œå†è¾“å…¥dataæ•°æ®ï¼Œè¿›è¡ŒåŠ å¯†ï¼Œæ³¨æ„è¿™é‡Œçš„å¼‚æˆ–æ–¹æ³•\nå¯¹äºç¬¬ä¸€ç§åŠ å¯†æ–¹å¼ï¼Œè¾“å…¥å…¨0çš„dataå—ï¼Œé‚£ä¹ˆå®é™…ä¸Šå°±æ˜¯å¯¹flagè¿›è¡Œäº†ä¸€æ¬¡åŠ å¯†ï¼Œä¸å¦¨è®¾flagæ˜¯ä¸¤ä¸ªå—+3ä¸ªå­—ç¬¦ï¼Œé‚£ä¹ˆå®¹æ˜“æœ‰å¡«å……åå¾—åˆ°flag0 flag1 Pad(flag2)è¿™ä¸‰ä¸ªå—ï¼ŒåŠ å¯†åå¾—åˆ°encflag0 encflag1 encPad(flag2)ä¸‰ä¸ªå—ï¼Œæˆªå–å‰é¢ä¸¤ä¸ª\nå¯¹äºç¬¬äºŒç§åŠ å¯†æ–¹å¼æ˜¯å…ˆå°†flagæ‹¼æ¥åœ¨è¾“å…¥çš„dataåæ–¹ï¼Œå†16å­—èŠ‚åˆ†å—ï¼ŒåŠ å¯†ä¹‹åç”¨ä¸€ä¸ªCå­˜å‚¨å„ä¸ªå—å¼‚æˆ–çš„ç»“æœï¼Œå¦‚æœæˆ‘ä»¬è¾“å…¥äº†Pad(flag2)ï¼Œé‚£ä¹ˆPadä¹‹åä¼šå¾—åˆ° Pad(flag2) flag0 flag1 Pad(flag2) åŠ å¯†å¾—åˆ°encPad(flag2) encflag0 encflag1 encPad(flag2),å¼‚æˆ–çš„ç»“æœå°±ä¼šæ˜¯encflag0 XOR encflag1ï¼Œç„¶è€Œè¿™ä¸ªæˆ‘ä»¬æ˜¯çŸ¥é“çš„ï¼Œç”±ç¬¬ä¸€æ¬¡åŠ å¯†çš„ç»“æœï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬ç©·ä¸¾flag3æ‰€æœ‰çš„å¯èƒ½ï¼Œä¸€å…±ä¹Ÿå°±27^3ç§ï¼Œpadä¹‹åä¼ å…¥ï¼Œåªè¦è¾“å‡ºçš„å€¼ä¸ºencflag1 XOR encflag0 é‚£ä¹ˆæˆ‘ä»¬å°±æ„é€ å¯¹äº†\næ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬åº”ç”¨è¿™é‡Œçš„å¼‚æˆ–æ€§è´¨ï¼Œæ„é€ æ¯”flagé•¿1ä½çš„0ä¸²ï¼Œé‚£ä¹ˆflag0çš„ç¬¬ä¸€ä½ä¼šå¤åˆ¶åˆ°flag3çš„æœ«å°¾ï¼Œè¿™æ—¶å€™å¦‚æ³•ç‚®åˆ¶çˆ†ç ´ç°åœ¨çš„flag3å°±å¯ä»¥äº†ï¼Œèƒ½åœ¨27æ¬¡ä»¥å†…æå‡ºæ¥ï¼Œä»¥æ­¤å¾ªç¯å³å¯ï¼Œç¨å¾®æ³¨æ„ä¸‹å½“çˆ†ç ´ä½æ•°è¶…è¿‡16æ—¶å€™çš„å—æ„é€ \nè´´ä¸€ä¸‹å‡ºé¢˜äººkeatonå¸ˆå‚…çš„é¢˜è§£\ndef enc1(data: bytes) -&gt; bytes:    r.sendlineafter(b\"your choice &gt; \", b\"1\")    data = data.hex().encode()    r.sendlineafter(b\"Input your data(hex): \", data)    encdata = r.recvline_contains(b\"Encrypted data(hex): \").strip().split(b\": \")[1]    return bytes.fromhex(encdata.decode())def enc2(data: bytes) -&gt; bytes:    r.sendlineafter(b\"your choice &gt; \", b\"2\")    data = data.hex().encode()    r.sendlineafter(b\"Input your data(hex): \", data)    encdata = r.recvline_contains(b\"Encrypted data(hex): \").strip().split(b\": \")[1]    return bytes.fromhex(encdata.decode())def getTail():    \"\"\"å°¾éƒ¨æœ‰å‡ ä¸ªå­—èŠ‚æ•°æ®çš„å•å—\"\"\"    encflag = enc1(b\"\\x00\" * flag_len)    print(\"flagå¯†æ–‡ï¼š\", encflag.hex()) #flagå„ä¸ªå—åŠ å¯†åçš„ç»“æœ    encflag = [encflag[i : i + 16] for i in range(0, len(encflag), 16)] #å¯†æ–‡åˆ†å—    for i in product(charset[::-1], repeat=tail_len):        data = (\"\".join(i)).encode()        print(data) #ç©·ä¸¾æ‰€æœ‰å¯èƒ½çš„flagæœ«å°¾3ä½        pdata = pad(data, AES.block_size)        res = enc2(pdata)        if res == xor(*encflag[: len(encflag) - 1]):            print(\"å°¾éƒ¨ï¼š\", data)            return datadef recover():    \"\"\"é€å­—èŠ‚ç ´è§£\"\"\"    flag = getTail()    mask = enc2(b\"a\" * 32) #å¾—åˆ°encflag0 XOR encflag1 XOR encPad(flag2)    mask = xor(*[mask[i : i + 16] for i in range(0, len(mask), 16)])     for i in range(1, flag_len + 1 - tail_len):        c1 = enc1(b\"\\x00\" * (flag_len + i))        c1 = [c1[_ : _ + 16] for _ in range(0, len(c1), 16)]        for j in charset:            data = flag + j.encode()            print(data)            pdata = pad(data, AES.block_size)            res = enc2(pdata)            if xor(res, mask) == xor(*c1[(flag_len // 16) :]):                flag += j.encode()                print(flag[tail_len:] + flag[:tail_len])                break    flag = flag[tail_len:] + flag[:tail_len]    flag = \"WHUCTF{\" + flag.decode() + \"}\"    print(flag)if __name__ == \"__main__\":    tail_len = 3    flag_len = 35    recover()\n\nç¢ç¢å¿µç¬¬ä¸€æ¬¡æ­£å¼æ¥è§¦æ¯”èµ›ä¸­çš„å¯†ç é¢˜ï¼Œå’Œæ ¡å†…23 24çº§çš„å…¶ä»–å¸ˆå‚…æœ‰ç€ä¸å°çš„å·®è·ï¼Œä¹Ÿæ˜¯é€æ¸æ„è¯†åˆ°äº†å„ç±»æ¿å­ï¼Œæ€è·¯çš„é‡è¦æ€§ï¼Œå†™å¤ç›˜çš„åˆè¡·ä¹Ÿæ˜¯å¸Œæœ›ä»¥åæˆ–è®¸ç”¨å¾—åˆ°å…¶ä¸­çš„æ€è·¯&amp;è„šæœ¬ï¼Œä¸è¿‡pythonä»£ç èƒ½åŠ›ç¡®å®è¿˜å¾—å¥½å¥½ç»ƒä¹ å‘¢ï¼ŒåŠ æ²¹\n","categories":["WP"],"tags":["CTF","RSA","æ ¼å¯†ç ","å‰ªæ","AES"]},{"title":"XYCTF2025","url":"/2025/04/19/XYCTF2025/","content":"1.reedimport stringimport randomfrom secret import flagassert flag.startswith('XYCTF{') and flag.endswith('}')flag = flag.rstrip('}').lstrip('XYCTF{')table = string.ascii_letters + string.digitsassert all(i in table for i in flag)r = random.Random()class PRNG:    def __init__(self, seed):        self.a = 1145140        self.b = 19198100        random.seed(seed)    def next(self):        x = random.randint(self.a, self.b)        random.seed(x ** 2 + 1)        return x        def round(self, k):        for _ in range(k):            x = self.next()        return xdef encrypt(msg, a, b):    c = [(a * table.index(m) + b) % 19198111 for m in msg]    return cseed = int(input('give me seed: '))prng = PRNG(seed)a = prng.round(r.randrange(2**16))b = prng.round(r.randrange(2**16))enc = encrypt(flag, a, b)print(enc)\nè¾“ä¸€ä¸ªseedè¿›å»ï¼Œç„¶åå½±å“prngçš„çŠ¶æ€ï¼Œå†ç”Ÿæˆç³»æ•°a,b,ç”¨è¿™é‡Œçš„ci,péƒ½çŸ¥é“ï¼Œå®é™…ä¸Šæ²¡ä»€ä¹ˆå¿…è¦ç®¡prngçš„ç”Ÿæˆé€»è¾‘ï¼Œå¯çŸ¥miçš„å–å€¼åªæœ‰æ‰€æœ‰æ•°å­—å’Œå¤§å°å†™å­—æ¯ï¼Œä¹Ÿå°±æ˜¯62ä¸ªå–å€¼å¯èƒ½ï¼Œæˆ‘ä»¬æ‰¾ä¸¤ç»„ä¸ä¸€æ ·çš„ci,cjæœ‰\n\nc_i\\equiv am_i+b\\;mod\\;p\\\\\nc_j\\equiv am_j+b\\;modp\\\\\nåšå·®æœ‰(c_i-c_j)\\equiv a(m_i-m_j)\\;mod\\;pç©·ä¸¾æ‰€æœ‰å¯èƒ½çš„mi,mjçš„å–å€¼ï¼Œä¹Ÿå°±3600å¤šç§ï¼Œå¯ä»¥è§£å‡º\n\na\\equiv (c_i-c_j)(m_i-m_j)^{-1}\\;mod\\;p\\\\å†ä»£å…¥å¯å¾—\n\nb\\equiv c_i-m_i(c_i-c_j)(m_i-m_j)^{-1}\\;mod\\;p\\\\è¿™ä¸‹æˆ‘ä»¬å°±å¾—åˆ°äº†a,bå†å¯¹åé¢çš„æ‰€æœ‰å·²çŸ¥çš„cï¼Œå¯å¾—\n\nm_k\\equiv(c_k-b)a^{-1}\\;mod\\;p\\\\è§£å‡ºæ‰€æœ‰å¯èƒ½çš„m_kï¼Œçœ‹çœ‹æ˜¯ä¸æ˜¯åœ¨0~61å†…ï¼Œè„šæœ¬å¦‚ä¸‹\nimport stringtable = string.ascii_letters + string.digits  # 62 charactersmod = 19198111def extended_gcd(a, b):    if a == 0:        return (b, 0, 1)    else:        g, y, x = extended_gcd(b % a, a)        return (g, x - (b // a) * y, y)def modular_inverse(a, m):    g, x, y = extended_gcd(a, m)    if g != 1:        return None  # No inverse    else:        return x % menc = [4468502, 4468502, 15719774, 272087, 4468502, 15719774, 16429260, 8482421, 7144448, 12678836, 8928412, 15537278, 11786854, 8482421, 8036430, 11340863, 8482421, 7590439, 7590439, 11786854, 8928412, 16875251, 8036430, 981573, 12678836, 3840015, 11786854, 15091287, 7590439, 4468502, 15273783, 4468502, 15273783, 11523359, 4468502, 718078]c0 = enc[0]c2 = enc[2]solutions = []for m0 in range(len(table)):    for m2 in range(len(table)):        if m0 == m2:            continue        delta_m = m2 - m0        delta_c = (c2 - c0) % mod        inv_dm = modular_inverse(delta_m, mod)        if inv_dm is None:            continue        a = (delta_c * inv_dm) % mod        inv_a = modular_inverse(a, mod)        if inv_a is None:            continue        b = (c0 - a * m0) % mod        valid = True        plain = []        for c in enc:            m = ((c - b) * inv_a) % mod            if m &lt; 0 or m &gt;= len(table):                valid = False                break            plain.append(table[m])        if valid:            solutions.append((a, b, ''.join(plain)))if solutions:    print(\"Possible solutions:\")    for a, b, plain in solutions:        print(f\"a = {a}, b = {b}\")        print(f\"Flag: XYCTF{{{plain}}}\\n\")else:    print(\"No valid solutions found.\")#Possible solutions:#a = 3750424, b = 16875251#Flag: XYCTF{114514fixedpointissodangerous1919810}\nä¸è¿‡è¿™è²Œä¼¼æ˜¯å‡ºé¢˜äººçš„éé¢„æœŸè§£ï¼Œç­‰æœ‰å¸ˆå‚…åˆ†äº«äº†å…³äºPRNGä¸åŠ¨ç‚¹çš„è§£æ³•çš„è¯å†è¡¥å……å§\n2.Complex-signinfrom Crypto.Util.number import *from Crypto.Cipher import ChaCha20import hashlibfrom secret import flag# å¤æ•°class Complex:    def __init__(self, re, im):        self.re = re        self.im = im    def __mul__(self, c):        re_ = self.re * c.re - self.im * c.im        im_ = self.re * c.im + self.im * c.re        return Complex(re_, im_)    def __eq__(self, c):        return self.re == c.re and self.im == c.im    def __rshift__(self, m):        return Complex(self.re &gt;&gt; m, self.im &gt;&gt; m)    def __lshift__(self, m):        return Complex(self.re &lt;&lt; m, self.im &lt;&lt; m)    def __str__(self):        if self.im == 0:            return str(self.re)        elif self.re == 0:            if abs(self.im) == 1:                return f\"{'-' if self.im &lt; 0 else ''}i\"            else:                return f\"{self.im}i\"        else:            return f\"{self.re} {'+' if self.im &gt; 0 else '-'} {abs(self.im)}i\"    def tolist(self):        return [self.re, self.im]# å¿«é€Ÿå¹‚def complex_pow(c, exp, n):    result = Complex(1, 0)    while exp &gt; 0:        if exp &amp; 1:            result = result * c            result.re = result.re % n            result.im = result.im % n        c = c * c        c.re = c.re % n        c.im = c.im % n        exp &gt;&gt;= 1    return resultbits = 128p = getPrime(1024)q = getPrime(1024)n = p * qm = Complex(getRandomRange(1, n), getRandomRange(1, n))e = 3c = complex_pow(m, e, n)print(f\"n = {n}\")print(f\"mh = {(m &gt;&gt; bits &lt;&lt; bits).tolist()}\")print(f\"C = {c.tolist()}\")print(f\"enc = {ChaCha20.new(key=hashlib.sha256(str(m.re + m.im).encode()).digest(), nonce=b'Pr3d1ctmyxjj').encrypt(flag)}\")'''n = 24240993137357567658677097076762157882987659874601064738608971893024559525024581362454897599976003248892339463673241756118600994494150721789525924054960470762499808771760690211841936903839232109208099640507210141111314563007924046946402216384360405445595854947145800754365717704762310092558089455516189533635318084532202438477871458797287721022389909953190113597425964395222426700352859740293834121123138183367554858896124509695602915312917886769066254219381427385100688110915129283949340133524365403188753735534290512113201932620106585043122707355381551006014647469884010069878477179147719913280272028376706421104753mh = [3960604425233637243960750976884707892473356737965752732899783806146911898367312949419828751012380013933993271701949681295313483782313836179989146607655230162315784541236731368582965456428944524621026385297377746108440938677401125816586119588080150103855075450874206012903009942468340296995700270449643148025957527925452034647677446705198250167222150181312718642480834399766134519333316989347221448685711220842032010517045985044813674426104295710015607450682205211098779229647334749706043180512861889295899050427257721209370423421046811102682648967375219936664246584194224745761842962418864084904820764122207293014016, 15053801146135239412812153100772352976861411085516247673065559201085791622602365389885455357620354025972053252939439247746724492130435830816513505615952791448705492885525709421224584364037704802923497222819113629874137050874966691886390837364018702981146413066712287361010611405028353728676772998972695270707666289161746024725705731676511793934556785324668045957177856807914741189938780850108643929261692799397326838812262009873072175627051209104209229233754715491428364039564130435227582042666464866336424773552304555244949976525797616679252470574006820212465924134763386213550360175810288209936288398862565142167552]C = [5300743174999795329371527870190100703154639960450575575101738225528814331152637733729613419201898994386548816504858409726318742419169717222702404409496156167283354163362729304279553214510160589336672463972767842604886866159600567533436626931810981418193227593758688610512556391129176234307448758534506432755113432411099690991453452199653214054901093242337700880661006486138424743085527911347931571730473582051987520447237586885119205422668971876488684708196255266536680083835972668749902212285032756286424244284136941767752754078598830317271949981378674176685159516777247305970365843616105513456452993199192823148760, 21112179095014976702043514329117175747825140730885731533311755299178008997398851800028751416090265195760178867626233456642594578588007570838933135396672730765007160135908314028300141127837769297682479678972455077606519053977383739500664851033908924293990399261838079993207621314584108891814038236135637105408310569002463379136544773406496600396931819980400197333039720344346032547489037834427091233045574086625061748398991041014394602237400713218611015436866842699640680804906008370869021545517947588322083793581852529192500912579560094015867120212711242523672548392160514345774299568940390940653232489808850407256752]enc = b'\\x9c\\xc4n\\x8dF\\xd9\\x9e\\xf4\\x05\\x82!\\xde\\xfe\\x012$\\xd0\\x8c\\xaf\\xfb\\rEb(\\x04)\\xa1\\xa6\\xbaI2J\\xd2\\xb2\\x898\\x11\\xe6x\\xa9\\x19\\x00pn\\xf6rs- \\xd2\\xd1\\xbe\\xc7\\xf51.\\xd4\\xd2 \\xe7\\xc6\\xca\\xe5\\x19\\xbe''''\nåŸºäºäºŒå…ƒå¤æ•°çš„RSAè¿ç®—ï¼Œé¢˜ç›®ç»™å‡ºäº†må®ã€è™šéƒ¨çš„é«˜ä½ï¼ŒåŒæ—¶eçš„æ•°å€¼ä¸º3ï¼Œå¯ä»¥è€ƒè™‘è®¾ä½ä½ï¼Œå±•å¼€æˆå¤šé¡¹å¼ï¼Œå»æ‰“äºŒå…ƒcoppersmithï¼Œæ¨å¯¼å¦‚ä¸‹\n\nRe_{m}=mh[0]+x\\;;Im_m=mh[1]+y\\\\\nåˆC\\equiv(mh[0]+x+(mh[1]+y)i)^3\\;mod\\;n\\\\\næ•´ç†å¾—åˆ°\\\\\nRe_C\\equiv (mh[0]+x)^3-3(mh[0]+x)(mh[1]+y)^2\\;mod\\;n\\\\\nIm_C\\equiv-(mh[1]+y)^3+3(mh[0]+x)^2(mh[1]+y)\\;mod\\;n\\\\åªæœ‰x,yæœªçŸ¥ï¼Œè¿™é‡Œç»™ä¸€ä¸ªäºŒå…ƒcopperçš„è„šæœ¬ï¼Œæ„Ÿè°¢(defund/coppersmith: Coppersmithâ€™s method for multivariate polynomials (github.com))å’Œä½¿ç”¨è½®å­çš„exp\n#sageimport itertoolsdef small_roots(f, bounds, m=1, d=None):\tif not d:\t\td = f.degree()\tif isinstance(f, Polynomial):\t\tx, = polygens(f.base_ring(), f.variable_name(), 1)\t\tf = f(x)\tR = f.base_ring()\tN = R.cardinality()\t\tf /= f.coefficients().pop(0)\tf = f.change_ring(ZZ)\tG = Sequence([], f.parent())\tfor i in range(m+1):\t\tbase = N^(m-i) * f^i\t\tfor shifts in itertools.product(range(d), repeat=f.nvariables()):\t\t\tg = base * prod(map(power, f.variables(), shifts))\t\t\tG.append(g)\tB, monomials = G.coefficient_matrix()\tmonomials = vector(monomials)\tfactors = [monomial(*bounds) for monomial in monomials]\tfor i, factor in enumerate(factors):\t\tB.rescale_col(i, factor)\tB = B.dense_matrix().LLL()\tB = B.change_ring(QQ)\tfor i, factor in enumerate(factors):\t\tB.rescale_col(i, 1/factor)\tH = Sequence([], f.parent().change_ring(QQ))\tfor h in filter(None, B*monomials):\t\tH.append(h)\t\tI = H.ideal()\t\tif I.dimension() == -1:\t\t\tH.pop()\t\telif I.dimension() == 0:\t\t\troots = []\t\t\tfor root in I.variety(ring=ZZ):\t\t\t\troot = tuple(R(root[var]) for var in f.variables())\t\t\t\troots.append(root)\t\t\treturn roots\treturn []\nexp\nfrom sage.all import *import itertools# from coppersmith import small_rootsfrom Crypto.Cipher import ChaCha20from hashlib import sha256def small_roots(f, bounds, m=1, d=None):    if not d:        d = f.degree()    R = f.base_ring()    N = R.cardinality() #å–å¾—æ¨¡æ•°    f /= f.coefficients().pop(0) #æœ€é«˜æ¬¡é¡¹ç³»æ•°åŒ–ä¸º0ï¼Œcoefficientsæ˜¯å¤šé¡¹å¼çš„é™æ¬¡å¹‚æ’åˆ—ç³»æ•°    f = f.change_ring(ZZ)    G = Sequence([], f.parent())    for i in range(m + 1):        base = N ** (m - i) * f ** i #æ”¶é›†åŸºå¤šé¡¹å¼        for shifts in itertools.product(range(d), repeat=f.nvariables()):            g = base * prod(map(power, f.variables(), shifts))            G.append(g)    # print(G)    B, monomials = G.coefficient_matrix()    monomials = vector(monomials)    factors = [monomial(*bounds) for monomial in monomials]    for i, factor in enumerate(factors):        B.rescale_col(i, factor)    B = B.dense_matrix().LLL()    B = B.change_ring(QQ)    for i, factor in enumerate(factors):        B.rescale_col(i, 1 / factor)    H = Sequence([], f.parent().change_ring(QQ))    for h in filter(None, B * monomials):        H.append(h)        I = H.ideal()        if I.dimension() == -1:            H.pop()        elif I.dimension() == 0:            roots = []            for root in I.variety(ring=ZZ):                root = tuple(R(root[var]) for var in f.variables())                roots.append(root)            return roots    return []n = 24240993137357567658677097076762157882987659874601064738608971893024559525024581362454897599976003248892339463673241756118600994494150721789525924054960470762499808771760690211841936903839232109208099640507210141111314563007924046946402216384360405445595854947145800754365717704762310092558089455516189533635318084532202438477871458797287721022389909953190113597425964395222426700352859740293834121123138183367554858896124509695602915312917886769066254219381427385100688110915129283949340133524365403188753735534290512113201932620106585043122707355381551006014647469884010069878477179147719913280272028376706421104753mh = [3960604425233637243960750976884707892473356737965752732899783806146911898367312949419828751012380013933993271701949681295313483782313836179989146607655230162315784541236731368582965456428944524621026385297377746108440938677401125816586119588080150103855075450874206012903009942468340296995700270449643148025957527925452034647677446705198250167222150181312718642480834399766134519333316989347221448685711220842032010517045985044813674426104295710015607450682205211098779229647334749706043180512861889295899050427257721209370423421046811102682648967375219936664246584194224745761842962418864084904820764122207293014016, 15053801146135239412812153100772352976861411085516247673065559201085791622602365389885455357620354025972053252939439247746724492130435830816513505615952791448705492885525709421224584364037704802923497222819113629874137050874966691886390837364018702981146413066712287361010611405028353728676772998972695270707666289161746024725705731676511793934556785324668045957177856807914741189938780850108643929261692799397326838812262009873072175627051209104209229233754715491428364039564130435227582042666464866336424773552304555244949976525797616679252470574006820212465924134763386213550360175810288209936288398862565142167552]C = [5300743174999795329371527870190100703154639960450575575101738225528814331152637733729613419201898994386548816504858409726318742419169717222702404409496156167283354163362729304279553214510160589336672463972767842604886866159600567533436626931810981418193227593758688610512556391129176234307448758534506432755113432411099690991453452199653214054901093242337700880661006486138424743085527911347931571730473582051987520447237586885119205422668971876488684708196255266536680083835972668749902212285032756286424244284136941767752754078598830317271949981378674176685159516777247305970365843616105513456452993199192823148760, 21112179095014976702043514329117175747825140730885731533311755299178008997398851800028751416090265195760178867626233456642594578588007570838933135396672730765007160135908314028300141127837769297682479678972455077606519053977383739500664851033908924293990399261838079993207621314584108891814038236135637105408310569002463379136544773406496600396931819980400197333039720344346032547489037834427091233045574086625061748398991041014394602237400713218611015436866842699640680804906008370869021545517947588322083793581852529192500912579560094015867120212711242523672548392160514345774299568940390940653232489808850407256752]R = PolynomialRing(Zmod(n), names=('x', 'y'))x, y = R.gens()f = (mh[0] + x)**3 - 3 * (mh[0] + x) * ((mh[1] + y)**2) - C[0]g = (mh[1] + y)**3 - 3 * (mh[0] + x)**2 * (mh[1] + y) + C[1]roots = small_roots(f, bounds=(2**129,2**129))enc = b'\\x9c\\xc4n\\x8dF\\xd9\\x9e\\xf4\\x05\\x82!\\xde\\xfe\\x012$\\xd0\\x8c\\xaf\\xfb\\rEb(\\x04)\\xa1\\xa6\\xbaI2J\\xd2\\xb2\\x898\\x11\\xe6x\\xa9\\x19\\x00pn\\xf6rs- \\xd2\\xd1\\xbe\\xc7\\xf51.\\xd4\\xd2 \\xe7\\xc6\\xca\\xe5\\x19\\xbe'sum = mh[0]+mh[1]+roots[0][0]+roots[0][1]key = sha256(str(sum).encode()).digest()cipher = ChaCha20.new(key=key, nonce=b'Pr3d1ctmyxjj')flag = cipher.decrypt(enc)print(\"Recovered flag:\", flag.decode(errors='ignore'))  #XYCTF{Welcome_to_XYCTF_Now_let_us_together_play_Crypto_challenge}\n3.divisioné¢˜ç›®ç»™äº†å®¹å™¨çš„server\n#server.py# -*- encoding: utf-8 -*-'''@File    :   server.py@Time    :   2025/03/20 12:25:03@Author  :   LamentXU '''import random print('----Welcome to my division calc----')print('''menu:      [1]  Division calc      [2]  Get flag''')while True:    choose = input(': &gt;&gt;&gt; ')    if choose == '1':        try:            denominator = int(input('input the denominator: &gt;&gt;&gt; '))        except:            print('INPUT NUMBERS')            continue        nominator = random.getrandbits(32)        if denominator == '0':            print('NO YOU DONT')            continue        else:            print(f'{nominator}//{denominator} = {nominator//denominator}')    elif choose == '2':        try:            ans = input('input the answer: &gt;&gt;&gt; ')            rand1 = random.getrandbits(11000)            rand2 = random.getrandbits(10000)            correct_ans = rand1 // rand2            if correct_ans == int(ans):                print('WOW')                with open('flag', 'r') as f:                    print(f'Here is your flag: {f.read()}')            else:                print(f'NOPE, the correct answer is {correct_ans}')        except:            print('INPUT NUMBERS')    else:        print('Invalid choice')\nè€ƒç‚¹ä¸»è¦æ˜¯pythonçš„PRFrandom å…¶ä¸­ä½¿ç”¨çš„æ˜¯MT19937ç®—æ³•ï¼Œåœ¨è¾“å‡ºæ¯”ç‰¹è¶…è¿‡624*32ä½æ—¶å°±èƒ½è¢«é¢„æµ‹ï¼Œå‚è€ƒblogs([CTF/randcrack]pythonéšæœºæ•°é¢„æµ‹æ¨¡å—åˆ†æåŠæ”¹è¿›æ–¹æ¡ˆ_random.getrandbits(32)-CSDNåšå®¢)\nåšå®¢å¸ˆå‚…ç»™äº†ä¸ªå¾ˆå¥½ç”¨çš„è½®å­ï¼Œæ€è·¯ä¹Ÿå¾ˆæ¸…æ¥šï¼Œé€‰æ‹©1ï¼Œè¾“å…¥1ï¼Œå°±èƒ½è·å¾—è¿™æ¬¡ç”Ÿæˆçš„éšæœºæ•°ï¼Œé‚£ä¹ˆè¾“624æ¬¡ï¼Œå†é€‰æ‹©2ï¼Œè¾“å…¥é¢„æµ‹çš„å€¼å°±Okäº†ï¼Œç›´æ¥ä¸Šexp\nimport socketimport reimport timeimport random from randcrack import RandCrack #ä¸‹è½½randcrackåº“åå¯¼å…¥ç±»# é…ç½®æœåŠ¡å™¨åœ°å€å’Œç«¯å£host = 'gz.imxbt.cn'  # æ›¿æ¢æˆç›®æ ‡æœåŠ¡å™¨çš„ IP åœ°å€port = 20522         # æ›¿æ¢æˆç›®æ ‡æœåŠ¡å™¨çš„ç«¯å£å·rc = RandCrack()res = ''def exploit(host, port):    # Connect to the target    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host, port))            for i in range (625):        s.send(b'1\\n')        time.sleep(0.05)        s.send(b'1\\n')        time.sleep(0.05)        response = s.recv(40000).decode('utf-8')    print(response)    numbers = re.findall(r'(\\d{2,})', response)    # ä½¿ç”¨åˆ—è¡¨æ¨å¯¼å¼ä¿æŒé¡ºåºå¹¶å»é‡    filtered_numbers = []    seen = set()    for num in numbers:        if num != '1' and num not in seen:            filtered_numbers.append(num)            seen.add(num)    print(len(filtered_numbers))    print(filtered_numbers)    for nums in filtered_numbers:        rc.submit(int(nums))#æ¯æ¬¡å¾ªç¯æäº¤ä¸€ä¸ª32ä½randomç”Ÿæˆçš„éšæœºæ•°    s.send(b'2\\n')    time.sleep(0.5)    d=rc.predict_getrandbits(32)    a=rc.predict_getrandbits(11000)    b=rc.predict_getrandbits(10000)    c=a//b    print(c)    s.send(f\"{c}\\n\".encode())    time.sleep(0.5)      response = s.recv(2048).decode('utf-8')    print(f\"{response}\")   if __name__ == \"__main__\":    exploit(host, port)# flag{I_do_not_want_any_CTFER_get_0_solve_in_Crypto_bad_bad_adwa}\n4.choiceè¿™é“ä¹Ÿæ˜¯è€ƒå¯Ÿçš„MT19937çš„å†…å®¹ï¼Œé¢˜å¹²\nfrom Crypto.Util.number import bytes_to_longfrom random import Randomfrom secret import flagassert flag.startswith(b'XYCTF{') and flag.endswith(b'}')flag = flag[6:-1]msg = bytes_to_long(flag)rand = Random()test = bytes([i for i in range(255, -1, -1)]) #256ä¸ªå­—ç¬¦ asciiprint(test)open('output.py', 'w').write(f'enc = {msg ^ rand.getrandbits(msg.bit_length())}\\nr = {[rand.choice(test) for _ in range(2496)]}')    # å…ˆgetrandbitsçš„ç”¨äº†ä¸€æ¬¡# å†å­˜åœ¨choice test å³é€‰æ‹©çš„éƒ¨åˆ†\nä¸è¿‡è¿™é‡Œæ˜¯ç”Ÿæˆäº†2496ä¸ª8bitçš„æ•°å­—ï¼Œå¯çŸ¥24968 = 624 32 bitæ•°æ˜¯å¤Ÿç”¨çš„ï¼Œæ²¿ç”¨ä¸Šé¢åšå®¢å¸ˆå‚…çš„è½®å­ï¼Œå°±å¯ä»¥ç ´è§£ä¼ªéšæœºç”Ÿæˆå™¨ï¼Œä½†æ˜¯è¿™é‡Œflagçš„é•¿åº¦æœªçŸ¥ï¼Œçˆ†ç ´å°±è¡Œäº†ï¼Œexpå¦‚ä¸‹\nfrom pyrandcracker import RandCrackerfrom Crypto.Util.number import *rc = RandCracker(detail = True)r = [224, 55, 218, 253, 150, 84, 208, 134, 18, 177, 244, 54, 122, 193, 249, 5, 121, 80, 230, 21, 236, 33, 226, 3, 120, 141, 212, 33, 69, 195, 78, 112, 0, 62, 64, 197, 10, 224, 64, 191, 17, 112, 196, 143, 209, 92, 10, 198, 174, 181, 96, 118, 175, 145, 111, 41, 113, 206, 137, 37, 56, 227, 252, 84, 18, 145, 81, 124, 202, 14, 255, 144, 200, 13, 230, 218, 208, 210, 222, 101, 211, 114, 222, 12, 190, 226, 62, 118, 87, 152, 118, 245, 196, 4, 92, 251, 238, 142, 114, 13, 113, 247, 171, 8, 138, 20, 169, 192, 221, 223, 60, 56, 188, 70, 184, 202, 195, 246, 71, 235, 152, 255, 73, 128, 140, 159, 119, 79, 1, 223, 239, 242, 60, 228, 205, 90, 210, 5, 165, 35, 176, 75, 21, 182, 220, 212, 240, 212, 77, 124, 52, 140, 85, 200, 207, 31, 177, 82, 76, 152, 128, 124, 205, 216, 252, 34, 27, 198, 186, 61, 161, 192, 158, 226, 40, 127, 69, 162, 24, 46, 208, 183, 99, 165, 1, 221, 184, 40, 147, 136, 236, 245, 228, 197, 86, 15, 201, 95, 115, 18, 131, 79, 86, 12, 122, 63, 200, 192, 244, 205, 229, 36, 86, 217, 249, 170, 5, 134, 99, 33, 214, 10, 120, 105, 233, 115, 230, 114, 105, 84, 39, 167, 18, 10, 77, 236, 104, 225, 196, 181, 105, 180, 159, 24, 4, 147, 131, 143, 64, 201, 212, 175, 203, 200, 19, 99, 24, 112, 180, 75, 222, 204, 204, 13, 210, 165, 135, 175, 132, 205, 247, 28, 178, 76, 240, 196, 240, 121, 132, 21, 8, 45, 203, 143, 206, 6, 11, 51, 47, 87, 88, 35, 63, 168, 251, 11, 254, 11, 46, 72, 210, 230, 184, 114, 88, 194, 99, 229, 144, 1, 226, 44, 133, 10, 42, 234, 112, 100, 248, 247, 66, 221, 72, 229, 236, 4, 65, 203, 65, 61, 23, 181, 190, 87, 1, 76, 113, 48, 178, 42, 175, 49, 78, 159, 104, 229, 213, 223, 13, 249, 216, 60, 144, 203, 156, 23, 129, 148, 87, 37, 79, 227, 141, 202, 210, 245, 236, 121, 129, 78, 7, 121, 42, 82, 184, 222, 96, 100, 189, 62, 102, 176, 198, 1, 153, 242, 23, 191, 197, 176, 115, 206, 122, 50, 104, 70, 170, 29, 52, 189, 157, 99, 82, 187, 201, 78, 25, 75, 126, 118, 160, 250, 53, 112, 143, 161, 251, 221, 44, 255, 232, 115, 182, 77, 31, 217, 228, 97, 112, 236, 21, 160, 127, 9, 220, 22, 97, 159, 239, 25, 140, 206, 210, 148, 105, 184, 41, 56, 92, 141, 3, 200, 165, 14, 161, 219, 177, 40, 189, 75, 48, 146, 130, 151, 100, 144, 239, 22, 19, 246, 166, 231, 228, 68, 254, 16, 99, 95, 32, 177, 216, 170, 125, 211, 100, 142, 251, 16, 64, 83, 161, 184, 242, 248, 239, 141, 171, 135, 48, 20, 34, 250, 13, 70, 236, 172, 22, 241, 171, 25, 18, 204, 36, 248, 253, 203, 138, 10, 130, 249, 15, 157, 244, 154, 41, 4, 231, 64, 20, 212, 126, 160, 48, 154, 171, 250, 199, 113, 32, 186, 126, 217, 3, 236, 115, 37, 174, 75, 222, 125, 55, 86, 65, 96, 56, 254, 226, 213, 244, 36, 199, 164, 160, 126, 191, 29, 50, 135, 234, 165, 122, 132, 68, 133, 129, 0, 220, 72, 87, 172, 93, 15, 131, 37, 119, 240, 43, 239, 105, 45, 244, 6, 34, 111, 151, 144, 54, 46, 159, 6, 5, 160, 32, 4, 180, 246, 39, 220, 85, 209, 145, 41, 88, 137, 110, 101, 113, 115, 204, 11, 53, 152, 177, 240, 193, 220, 136, 84, 221, 12, 43, 74, 122, 251, 236, 53, 175, 36, 46, 246, 181, 137, 246, 53, 189, 171, 240, 104, 8, 126, 56, 122, 245, 155, 130, 31, 16, 20, 212, 147, 33, 165, 82, 117, 244, 167, 235, 115, 244, 94, 173, 195, 34, 36, 33, 218, 39, 13, 90, 196, 172, 207, 105, 73, 255, 187, 221, 162, 242, 186, 122, 140, 241, 120, 98, 44, 81, 172, 201, 150, 238, 111, 147, 24, 214, 192, 125, 102, 157, 53, 219, 172, 123, 218, 222, 71, 138, 117, 188, 32, 104, 10, 188, 118, 58, 254, 36, 104, 212, 76, 209, 15, 6, 33, 149, 15, 225, 76, 8, 157, 48, 70, 127, 19, 126, 77, 216, 133, 132, 30, 33, 113, 117, 134, 238, 57, 20, 121, 26, 184, 229, 202, 90, 28, 42, 230, 42, 159, 19, 191, 162, 205, 241, 67, 177, 216, 191, 164, 146, 90, 228, 232, 149, 163, 135, 130, 193, 196, 178, 215, 216, 155, 238, 20, 36, 196, 153, 207, 177, 149, 40, 172, 139, 12, 134, 142, 154, 225, 179, 95, 248, 190, 8, 154, 246, 229, 102, 121, 197, 116, 135, 163, 128, 109, 112, 114, 143, 164, 134, 233, 45, 244, 22, 141, 211, 214, 122, 14, 93, 49, 251, 85, 95, 95, 191, 210, 245, 181, 142, 125, 110, 33, 195, 150, 197, 173, 86, 50, 127, 187, 129, 67, 119, 58, 134, 119, 36, 151, 136, 122, 157, 22, 171, 195, 48, 178, 232, 228, 177, 6, 124, 50, 163, 161, 32, 49, 197, 157, 188, 86, 208, 226, 208, 63, 173, 21, 192, 148, 194, 208, 251, 95, 117, 34, 116, 217, 130, 150, 97, 206, 101, 201, 88, 137, 163, 90, 104, 129, 4, 191, 99, 50, 115, 8, 145, 116, 250, 180, 193, 229, 128, 92, 55, 26, 6, 154, 68, 0, 66, 77, 126, 192, 170, 218, 252, 127, 192, 29, 107, 152, 231, 190, 202, 130, 116, 229, 193, 63, 13, 48, 220, 238, 126, 74, 232, 19, 242, 71, 159, 9, 196, 187, 111, 243, 81, 244, 193, 95, 166, 85, 22, 240, 32, 1, 114, 11, 64, 114, 149, 217, 207, 194, 1, 33, 245, 14, 101, 119, 32, 233, 214, 139, 71, 103, 125, 54, 17, 86, 140, 132, 221, 45, 227, 136, 203, 156, 223, 73, 43, 82, 190, 119, 22, 14, 115, 0, 192, 105, 147, 210, 146, 47, 89, 210, 18, 225, 126, 210, 240, 55, 219, 247, 106, 190, 50, 35, 13, 255, 236, 253, 82, 244, 117, 139, 1, 72, 182, 19, 170, 173, 59, 175, 10, 95, 66, 253, 178, 139, 45, 5, 24, 59, 9, 222, 58, 46, 79, 48, 39, 175, 196, 249, 249, 70, 126, 118, 69, 165, 155, 119, 67, 221, 20, 133, 16, 99, 41, 132, 11, 12, 35, 70, 87, 43, 197, 103, 33, 201, 3, 195, 142, 128, 135, 121, 26, 185, 2, 73, 235, 70, 219, 49, 227, 133, 241, 34, 6, 9, 109, 66, 50, 177, 114, 119, 101, 91, 144, 41, 246, 40, 81, 113, 203, 226, 87, 8, 0, 73, 212, 5, 95, 112, 230, 4, 28, 206, 93, 252, 30, 195, 197, 226, 165, 120, 3, 124, 169, 66, 227, 113, 55, 101, 135, 141, 71, 84, 202, 19, 145, 25, 92, 50, 80, 53, 63, 85, 184, 196, 93, 254, 47, 252, 182, 150, 115, 20, 181, 178, 87, 162, 50, 190, 228, 125, 240, 134, 10, 142, 173, 206, 250, 49, 186, 201, 118, 146, 246, 244, 199, 9, 55, 253, 123, 103, 200, 206, 79, 168, 216, 99, 192, 191, 236, 214, 248, 111, 115, 74, 155, 165, 150, 40, 86, 224, 240, 133, 69, 34, 52, 13, 63, 61, 116, 182, 144, 177, 101, 164, 77, 217, 65, 218, 150, 142, 249, 165, 160, 220, 120, 25, 36, 157, 134, 223, 11, 46, 121, 75, 182, 126, 104, 91, 204, 45, 49, 175, 10, 48, 83, 150, 96, 244, 10, 149, 76, 124, 189, 149, 200, 252, 175, 124, 146, 126, 230, 70, 194, 243, 63, 204, 224, 115, 140, 115, 110, 86, 22, 193, 5, 11, 18, 177, 159, 94, 160, 38, 188, 139, 89, 1, 200, 163, 138, 8, 140, 169, 54, 29, 225, 22, 5, 99, 144, 247, 239, 106, 77, 29, 141, 206, 89, 236, 4, 32, 104, 115, 206, 204, 15, 100, 66, 199, 15, 89, 24, 246, 99, 224, 207, 7, 205, 142, 203, 28, 87, 16, 110, 93, 72, 73, 206, 48, 59, 170, 152, 224, 2, 74, 9, 125, 140, 82, 206, 159, 0, 117, 237, 252, 47, 200, 75, 133, 68, 239, 109, 169, 25, 168, 202, 240, 5, 67, 125, 173, 233, 6, 148, 38, 182, 13, 141, 149, 39, 119, 189, 122, 49, 173, 153, 78, 103, 211, 65, 224, 52, 10, 35, 233, 88, 66, 43, 120, 255, 71, 169, 215, 250, 218, 205, 163, 164, 226, 46, 178, 25, 88, 59, 98, 199, 167, 134, 244, 167, 210, 20, 246, 159, 163, 252, 114, 5, 168, 52, 47, 177, 159, 255, 236, 166, 49, 36, 61, 10, 130, 135, 220, 101, 202, 69, 150, 100, 217, 98, 203, 217, 166, 33, 169, 203, 230, 194, 224, 15, 249, 205, 52, 41, 124, 191, 223, 148, 251, 147, 133, 85, 149, 214, 198, 5, 134, 91, 201, 191, 204, 152, 240, 37, 34, 236, 211, 182, 142, 207, 1, 188, 67, 87, 222, 220, 7, 78, 49, 129, 236, 98, 120, 217, 204, 77, 106, 89, 250, 182, 15, 18, 27, 143, 13, 27, 61, 223, 213, 196, 190, 24, 35, 104, 100, 220, 60, 194, 174, 169, 20, 167, 75, 162, 26, 253, 213, 59, 219, 187, 253, 160, 249, 61, 122, 113, 223, 55, 57, 198, 53, 138, 94, 154, 18, 132, 233, 183, 71, 7, 22, 50, 196, 181, 202, 103, 86, 31, 119, 83, 130, 165, 242, 170, 31, 35, 175, 117, 95, 89, 247, 221, 186, 47, 236, 241, 77, 194, 111, 148, 45, 101, 88, 41, 0, 33, 139, 15, 127, 156, 72, 234, 217, 170, 218, 216, 31, 4, 73, 150, 78, 49, 178, 13, 178, 46, 102, 93, 184, 110, 205, 132, 190, 43, 87, 194, 35, 188, 166, 9, 97, 184, 202, 113, 45, 150, 62, 106, 108, 19, 162, 85, 212, 188, 131, 38, 67, 23, 136, 208, 87, 63, 69, 6, 209, 242, 45, 13, 228, 14, 233, 8, 71, 43, 51, 89, 46, 195, 101, 132, 254, 154, 183, 220, 115, 221, 255, 174, 150, 65, 141, 176, 57, 144, 16, 115, 252, 144, 139, 52, 205, 224, 75, 190, 192, 2, 231, 30, 238, 149, 22, 200, 137, 244, 239, 185, 212, 145, 230, 200, 8, 249, 109, 26, 226, 195, 133, 140, 103, 50, 230, 180, 47, 196, 226, 105, 13, 239, 135, 20, 214, 152, 211, 208, 81, 213, 48, 187, 232, 77, 139, 16, 79, 204, 216, 56, 41, 41, 58, 192, 245, 1, 104, 85, 42, 107, 94, 142, 12, 247, 90, 254, 116, 72, 193, 219, 54, 247, 5, 28, 60, 140, 10, 185, 86, 148, 101, 198, 96, 181, 245, 61, 25, 186, 29, 57, 176, 188, 9, 239, 93, 198, 110, 248, 23, 87, 193, 161, 107, 40, 38, 186, 205, 148, 197, 127, 144, 69, 19, 47, 132, 82, 23, 170, 83, 224, 235, 49, 190, 44, 145, 65, 66, 141, 78, 1, 254, 24, 157, 7, 23, 227, 28, 81, 176, 22, 92, 139, 188, 48, 183, 229, 139, 205, 174, 131, 189, 241, 21, 146, 204, 58, 249, 167, 217, 174, 43, 41, 56, 181, 212, 42, 188, 6, 117, 93, 178, 160, 129, 15, 76, 150, 207, 245, 227, 247, 130, 171, 114, 204, 101, 176, 55, 43, 138, 149, 90, 124, 45, 96, 181, 221, 16, 121, 210, 51, 210, 164, 68, 64, 154, 167, 91, 69, 35, 153, 212, 10, 125, 235, 203, 166, 145, 9, 174, 86, 65, 70, 112, 194, 140, 92, 170, 49, 191, 157, 218, 199, 152, 151, 247, 208, 182, 209, 34, 245, 5, 173, 105, 175, 159, 71, 251, 198, 246, 214, 99, 58, 70, 154, 52, 39, 88, 149, 179, 202, 86, 240, 108, 200, 83, 250, 62, 213, 113, 138, 73, 106, 141, 192, 204, 90, 251, 208, 28, 124, 30, 134, 119, 144, 68, 23, 204, 181, 186, 76, 156, 71, 8, 104, 186, 87, 221, 134, 122, 72, 244, 203, 121, 181, 65, 90, 185, 131, 230, 133, 54, 158, 186, 168, 201, 178, 155, 172, 164, 22, 130, 111, 90, 209, 2, 167, 23, 176, 63, 139, 89, 63, 15, 238, 110, 204, 85, 36, 127, 68, 240, 177, 31, 2, 81, 147, 205, 192, 214, 173, 103, 130, 10, 100, 232, 125, 216, 163, 209, 171, 168, 243, 145, 6, 170, 41, 142, 250, 145, 57, 139, 224, 221, 189, 48, 141, 232, 146, 92, 216, 154, 126, 223, 8, 90, 82, 138, 221, 240, 223, 87, 209, 165, 17, 52, 154, 91, 12, 121, 212, 238, 46, 215, 217, 147, 136, 139, 251, 91, 39, 188, 244, 251, 52, 110, 22, 126, 200, 231, 153, 103, 203, 120, 219, 118, 172, 53, 141, 203, 75, 163, 150, 194, 27, 208, 9, 186, 6, 85, 46, 243, 135, 66, 40, 79, 206, 250, 20, 85, 123, 35, 164, 44, 85, 104, 66, 51, 177, 125, 189, 165, 226, 13, 75, 78, 225, 252, 226, 138, 81, 171, 172, 175, 122, 145, 68, 254, 37, 153, 39, 113, 237, 232, 220, 80, 193, 181, 21, 197, 186, 56, 202, 239, 213, 135, 41, 6, 85, 54, 135, 214, 95, 102, 23, 192, 153, 235, 110, 26, 14, 84, 220, 142, 236, 192, 8, 117, 205, 249, 92, 148, 149, 77, 235, 205, 232, 21, 48, 14, 84, 187, 124, 218, 166, 155, 183, 62, 10, 123, 53, 63, 79, 101, 193, 3, 61, 29, 39, 99, 22, 197, 75, 10, 165, 44, 215, 210, 181, 74, 235, 200, 247, 158, 187, 200, 102, 22, 150, 73, 42, 131, 28, 17, 180, 133, 205, 23, 228, 226, 219, 175, 207, 81, 53, 141, 114, 140, 59, 218, 169, 7, 219, 139, 75, 210, 97, 236, 157, 21, 109, 195, 128, 54, 5, 55, 217, 127, 49, 62, 59, 101, 95, 86, 255, 22, 186, 94, 151, 114, 93, 19, 198, 159, 174, 142, 132, 195, 157, 206, 161, 107, 255, 106, 196, 250, 191, 86, 221, 196, 36, 29, 37, 50, 224, 42, 20, 89, 212, 252, 191, 157, 237, 10, 157, 80, 42, 234, 180, 1, 183, 186, 239, 129, 14, 125, 114, 66, 203, 120, 114, 37, 214, 37, 73, 153, 182, 165, 87, 177, 75, 220, 210, 105, 154, 149, 114, 13, 202, 128, 55, 128, 96, 158, 150, 57, 86, 106, 127, 160, 57, 80, 255, 107, 241, 95, 121, 14, 110, 160, 119, 211, 150, 156, 185, 158, 221, 110, 76, 255, 119, 15, 245, 1, 238, 139, 100, 250, 220, 147, 193, 51, 144, 123, 139, 13, 26, 158, 95, 148, 251, 82, 227, 119, 92, 132, 219, 248, 239, 217, 101, 88, 121, 10, 148, 203, 156, 156]enc = 5042764371819053176884777909105310461303359296255297for i in r:    rc.submit(255-i,8)rc.check(offset = True)# çˆ†ç ´é•¿åº¦ä¸ºiå³å¯for i in range(150,200):    rc.offset_bits(-i)    data = rc.rnd.getrandbits(i)    print(long_to_bytes(data^enc))#ç¨å¾®è¦è·‘ä¸€ä¼š#b'___0h_51mple_r@nd0m___'\n5.*å¤å¤å¤å¤æ•°class ComComplex:    def __init__(self, value=[0,0,0,0]):        self.value = value    def __str__(self):        s = str(self.value[0])        for k,i in enumerate(self.value[1:]):            if i &gt;= 0:                s += '+'            s += str(i) +'ijk'[k]        return s    def __add__(self,x):        return ComComplex([i+j for i,j in zip(self.value,x.value)])    def __mul__(self,x):        a = self.value[0]*x.value[0]-self.value[1]*x.value[1]-self.value[2]*x.value[2]-self.value[3]*x.value[3]        b = self.value[0]*x.value[1]+self.value[1]*x.value[0]+self.value[2]*x.value[3]-self.value[3]*x.value[2]        c = self.value[0]*x.value[2]-self.value[1]*x.value[3]+self.value[2]*x.value[0]+self.value[3]*x.value[1]        d = self.value[0]*x.value[3]+self.value[1]*x.value[2]-self.value[2]*x.value[1]+self.value[3]*x.value[0]        return ComComplex([a,b,c,d])    def __mod__(self,x):        return ComComplex([i % x for i in self.value])    def __pow__(self, x, n=None):        tmp = ComComplex(self.value)        a = ComComplex([1,0,0,0])        while x:            if x &amp; 1:                a *= tmp            tmp *= tmp            if n:                a %= n                tmp %= n            x &gt;&gt;= 1        return afrom Crypto.Util.number import *from secret import flag, hintp = getPrime(256)q = getPrime(256)r = getPrime(256)n = p * q * rP = getPrime(512)assert len(hint) == 20hints = ComComplex([bytes_to_long(hint[i:i+5]) for i in range(0,20,5)])keys = ComComplex([0, p, q, r])print('hint =',hints)print('gift =',hints*keys%P)print('P =',P)e = 65547m = ComComplex([bytes_to_long(flag[i:i+len(flag)//4+1]) for i in range(0,len(flag),len(flag)//4+1)])c = pow(m, e, n)print('n =', n)print('c =', c)'''hint = 375413371936+452903063925i+418564633198j+452841062207kgift = 8123312244520119413231609191866976836916616973013918670932199631084038015924368317077919454611785179950870055560079987034735836668109705445946887481003729+20508867471664499348708768798854433383217801696267611753941328714877299161068885700412171i+22802458968832151777449744120185122420871929971817937643641589637402679927558503881707868j+40224499597522456323122179021760594618350780974297095023316834212332206526399536884102863kP = 8123312244520119413231609191866976836916616973013918670932199631182724263362174895104545305364960781233690810077210539091362134310623408173268475389315109n = 408713495380933615345467409596399184629824932933932227692519320046890365817329617301604051766392980053993030281090124694858194866782889226223493799859404283664530068697313752856923001112586828837146686963124061670340088332769524367c = 212391106108596254648968182832931369624606731443797421732310126161911908195602305474921714075911012622738456373731638115041135121458776339519085497285769160263024788009541257401354037620169924991531279387552806754098200127027800103+24398526281840329222660628769015610312084745844610670698920371305353888694519135578269023873988641161449924124665731242993290561874625654977013162008430854786349580090169988458393820787665342793716311005178101342140536536153873825i+45426319565874516841189981758358042952736832934179778483602503215353130229731883231784466068253520728052302138781204883495827539943655851877172681021818282251414044916889460602783324944030929987991059211909160860125047647337380125j+96704582331728201332157222706704482771142627223521415975953255983058954606417974983056516338287792260492498273014507582247155218239742778886055575426154960475637748339582574453542182586573424942835640846567809581805953259331957385k'''\né¦–å…ˆï¼Œå®šä¹‰äº†ä¸€ä¸ªå››å…ƒæ•°çš„è¿ç®—ï¼Œé¦–å…ˆè¿™é‡Œçš„p,q,réƒ½æ˜¯å¯ä»¥æ±‚çš„ï¼Œè§£çº¿æ€§æ–¹ç¨‹å’Œå››å…ƒæ•°æ±‚æ¨¡é€†éƒ½æ˜¯å¯è¡Œçš„æ–¹æ³•ï¼Œ\n\nq^{-1}=\\frac{q^*}{|q|^2},å…¶ä¸­q^*æ˜¯qçš„å…±è½­å››å…ƒæ•°(è™šä½å–åå³å¯)\\\\\npart1 æ±‚pqr\nF=GF(P)hint = [F(x) for x in [375413371936, 452903063925, 418564633198, 452841062207]]H = matrix(F,[    [hint[0],-hint[1],-hint[2],-hint[3]],    [hint[1],hint[0],-hint[3],hint[2]],    [hint[2],hint[3],hint[0],-hint[1]],    [hint[3],-hint[2],hint[1],hint[0]]])g = vector(GF(P),[gift[0],gift[1],gift[2],gift[3]])v = H.solve_right(g)p=int(v[1])q=int(v[2])r=int(v[3])#è§£æ–¹ç¨‹\n\n\n\npart2 åˆ†æRSA\n\nè¿™é‡Œe=65547=9*7283 ä¸”ç®—ä¸€ä¸‹å°±èƒ½å‘ç°e phiä¸äº’ç´ ï¼Œ,ç„¶åè¿™é‡Œæ¨¡æŒ‡ä¸äº’ç´ çš„åŸç†è¿˜æ²¡æœ‰æå¤ªæ˜ç™½ï¼Œå…ˆè´´ä¸€ä¸‹expï¼Œæ™šä¸€äº›å†è¡¥å……ä¸€ä¸‹\nclass ComComplex:    def __init__(self, value=[0,0,0,0]):        self.value = value    def __str__(self):        s = str(self.value[0])        for k,i in enumerate(self.value[1:]):            if i &gt;= 0:                s += '+'            s += str(i) +'ijk'[k]        return s    def __add__(self,x):        return ComComplex([i+j for i,j in zip(self.value,x.value)])    def __mul__(self,x):        a = self.value[0]*x.value[0]-self.value[1]*x.value[1]-self.value[2]*x.value[2]-self.value[3]*x.value[3]        b = self.value[0]*x.value[1]+self.value[1]*x.value[0]+self.value[2]*x.value[3]-self.value[3]*x.value[2]        c = self.value[0]*x.value[2]-self.value[1]*x.value[3]+self.value[2]*x.value[0]+self.value[3]*x.value[1]        d = self.value[0]*x.value[3]+self.value[1]*x.value[2]-self.value[2]*x.value[1]+self.value[3]*x.value[0]        return ComComplex([a,b,c,d])    def __mod__(self,x):        return ComComplex([i % x for i in self.value])    def __pow__(self, x, n=None):        tmp = ComComplex(self.value)        a = ComComplex([1,0,0,0])        while x:            if x &amp; 1:                a *= tmp            tmp *= tmp            if n:                a %= n                tmp %= n            x &gt;&gt;= 1        return a    def inv(self, mod):        inv_len = inverse(sum(i**2 for i in self.value), mod)        return ComComplex([self.value[0] * inv_len % mod, -self.value[1] * inv_len % mod, -self.value[2] * inv_len % mod, -self.value[3] * inv_len % mod])# è®¡ç®—æ¨¡é€†å…ƒfrom Crypto.Util.number import *from sage.all import *hint = [375413371936,452903063925,418564633198,452841062207]gift = [8123312244520119413231609191866976836916616973013918670932199631084038015924368317077919454611785179950870055560079987034735836668109705445946887481003729,20508867471664499348708768798854433383217801696267611753941328714877299161068885700412171,22802458968832151777449744120185122420871929971817937643641589637402679927558503881707868,40224499597522456323122179021760594618350780974297095023316834212332206526399536884102863]P = 8123312244520119413231609191866976836916616973013918670932199631182724263362174895104545305364960781233690810077210539091362134310623408173268475389315109n = 408713495380933615345467409596399184629824932933932227692519320046890365817329617301604051766392980053993030281090124694858194866782889226223493799859404283664530068697313752856923001112586828837146686963124061670340088332769524367c = [212391106108596254648968182832931369624606731443797421732310126161911908195602305474921714075911012622738456373731638115041135121458776339519085497285769160263024788009541257401354037620169924991531279387552806754098200127027800103,24398526281840329222660628769015610312084745844610670698920371305353888694519135578269023873988641161449924124665731242993290561874625654977013162008430854786349580090169988458393820787665342793716311005178101342140536536153873825,45426319565874516841189981758358042952736832934179778483602503215353130229731883231784466068253520728052302138781204883495827539943655851877172681021818282251414044916889460602783324944030929987991059211909160860125047647337380125,96704582331728201332157222706704482771142627223521415975953255983058954606417974983056516338287792260492498273014507582247155218239742778886055575426154960475637748339582574453542182586573424942835640846567809581805953259331957385]e=65547# 65547 = 7283*9c = ComComplex([c[0],c[1],c[2],c[3]])F=GF(P)hint = [F(x) for x in [375413371936, 452903063925, 418564633198, 452841062207]]H = matrix(F,[    [hint[0],-hint[1],-hint[2],-hint[3]],    [hint[1],hint[0],-hint[3],hint[2]],    [hint[2],hint[3],hint[0],-hint[1]],    [hint[3],-hint[2],hint[1],hint[0]]])g = vector(GF(P),[gift[0],gift[1],gift[2],gift[3]])v = H.solve_right(g)p=int(v[1])q=int(v[2])r=int(v[3])phi =q*(q-1)*(q**2-1)# print(GCD(e,(p-1)*(q-1)*(r-1)))# print(GCD(e,p-1))print(GCD(e,q-1)) # å»è®¡ç®—qçš„æ¬§æ‹‰å‡½æ•°ï¼Ÿprint(gcd(e,phi))d=inverse(e,phi//3)m = pow(c,d,q)# å®é™…ä¸Šè¿˜æ˜¯åœ¨è¿™ä¸ªå››å…ƒæ•°ä¸‹è®¡ç®—å¾—åˆ°çš„ç»“æœprint(m)# print(GCD(e,r-1))for i in m.value:    print(long_to_bytes(int(i)).decode(),end='')# flag{Quaternion_15_ComComComComplexXXX!!!?}\n","categories":["å¤ç°"],"tags":["CTF","RSA","MT19937"]}]