[{"title":"TGCTF2025","url":"/2025/04/22/TGCTF2025/","content":"EZRSAfrom secrets import flag, get_random_emojiiiiiifrom Crypto.Util.number import *def genarate_emojiiiiii_prime(nbits, base=0):    while True:        p = getPrime(base // 32 * 32) if base &gt;= 3 else 0        for i in range(nbits // 8 // 4 - base // 32):            p = (p &lt;&lt; 32) + get_random_emojiiiiii() # 猜一猜        if isPrime(p):            return pm = bytes_to_long(flag.encode()+ \"\".join([long_to_bytes(get_random_emojiiiiii()).decode() for _ in range(5)]).encode())p = genarate_emojiiiiii_prime(512, 224)q = genarate_emojiiiiii_prime(512)n = p * qe = \"💯\"c = pow(m, bytes_to_long(e.encode()), n)print(\"p0 =\", long_to_bytes(p % 2 ** 256).decode())print(\"n =\", n)print(\"c =\", c)# p0 = 😘😾😂😋😶😾😳😷# n = 156583691355552921614631145152732482393176197132995684056861057354110068341462353935267384379058316405283253737394317838367413343764593681931500132616527754658531492837010737718142600521325345568856010357221012237243808583944390972551218281979735678709596942275013178851539514928075449007568871314257800372579# c = 47047259652272336203165844654641527951135794808396961300275905227499051240355966018762052339199047708940870407974724853429554168419302817757183570945811400049095628907115694231183403596602759249583523605700220530849961163557032168735648835975899744556626132330921576826526953069435718888223260480397802737401\n从\np = genarate_emojiiiiii_prime(512, 224)q = genarate_emojiiiiii_prime(512)\n切入，结合这个函数，不难分析出，q就是18个emoji块，而p的第288位都是emoji块（共8个），而p已知低256位，并且观察生成p的emoji块的组成，十位数表示都是40369911??所以说只用爆破第八个emoji的最后2位，即可得到p的低288位，然后对高位再打一组copper，此时是可以解的，解出来，这里copper的思路是，当x确定，在$GF(n)$我们可以用多项式\n\np=f(x)=x*2^{288}+(a+i)*2^{256}+pp\\equiv0\\\\来约束x,从而copper出可能的值，再用整除性验证即可，脚本如下\nfrom Crypto.Util.number import *from tqdm import tqdmp0 = \"😘😾😂😋😶😾😳😷\"n = 156583691355552921614631145152732482393176197132995684056861057354110068341462353935267384379058316405283253737394317838367413343764593681931500132616527754658531492837010737718142600521325345568856010357221012237243808583944390972551218281979735678709596942275013178851539514928075449007568871314257800372579c = 47047259652272336203165844654641527951135794808396961300275905227499051240355966018762052339199047708940870407974724853429554168419302817757183570945811400049095628907115694231183403596602759249583523605700220530849961163557032168735648835975899744556626132330921576826526953069435718888223260480397802737401e = \"💯\"ee = bytes_to_long(e.encode())a=4036991100pp = bytes_to_long(p0.encode())for i in tqdm(range(100)):    PR.&lt;x&gt; = PolynomialRing(Zmod(n))    f = x * 2^288 + pp + (a+i) * 2^256    f = f.monic()    roots = f.small_roots(X=2^224, beta=0.4, eplison=0.04)    if roots:        x = roots[0]        p_may = int(x * 2^288 + pp + (a+i) * 2^256)        if n%p_may == 0:            print(\"p_may = \", p_may)            print(\"q_may = \", n // p_may)            break# p_may =  12424840247075830662687097292458444573014198016321428995092662043898159667123240573630892907827505266982898641483333170032514244713840745287869771915696311# q_may =  12602471198163266643743702664647336358595911975665358584258749238146841559843060594842063473155049870396568542257767865369797827796765830093256146584311989# 用时0.2s\n解出p,q之后就是e,phi不互素的RSA了,感谢不知道战队的师傅提供的一种简洁的写法TGCTF25 不知道 WP | 不知道のblog (idontknowctf.xyz)\nphi = (p-1)*(q-1)# GCD = gcd(ee, phi)  15d = inverse(ee//15, phi)c = pow(c, d, n)R.&lt;y&gt;=Zmod(p)[]f=y^15-cf=f.monic()m1=f.roots()R.&lt;z&gt;=Zmod(q)[]f=z^15-cf=f.monic()m2=f.roots()for i in m1:    for j in m2:        m=crt([int(i[0]),int(j[0])],[int(p),int(q)])        # print(long_to_bytes(int(m)))        if b'TGCTF' in long_to_bytes(int(m)):            print(long_to_bytes(int(m)).decode())# TGCTF{🙇🏮🤟_🫡🫡🫡_🚩🚩🚩}😃😖😘😨😢\nLLLCGfrom hashlib import sha256from Crypto.Util.number import getPrime, inverse, bytes_to_long, isPrimefrom random import randintimport socketserverfrom secret import flag, dsa_p, dsa_qclass TripleLCG:    def __init__(self, seed1, seed2, seed3, a, b, c, d, n):        self.state = [seed1, seed2, seed3]        self.a = a        self.b = b        self.c = c        self.d = d        self.n = n    def next(self):        new = (self.a * self.state[-3] + self.b * self.state[-2] + self.c * self.state[-1] + self.d) % self.n        self.state.append(new)        return newclass DSA:    def __init__(self):        # while True:            # self.q = getPrime(160)            # t = 2 * getPrime(1024 - 160) * self.q            # if isPrime(t + 1):            #    self.p = t + 1            #    break        self.p = dsa_p        self.q = dsa_q        self.g = pow(2, (self.p - 1) // self.q, self.p)        self.x = randint(1, self.q - 1)        self.y = pow(self.g, self.x, self.p)    def sign(self, msg, k):        h = bytes_to_long(sha256(msg).digest())        r = pow(self.g, k, self.p) % self.q        s = (inverse(k, self.q) * (h + self.x * r)) % self.q        return (r, s)    def verify(self, msg, r, s):        if not (0 &lt; r &lt; self.q and 0 &lt; s &lt; self.q):            return False        h = bytes_to_long(sha256(msg).digest())        w = inverse(s, self.q)        u1 = (h * w) % self.q        u2 = (r * w) % self.q        v = ((pow(self.g, u1, self.p) * pow(self.y, u2, self.p)) % self.p) % self.q        return v == rclass Task(socketserver.BaseRequestHandler):    def _recvall(self):        BUFF_SIZE = 2048        data = b''        while True:            part = self.request.recv(BUFF_SIZE)            data += part            if len(part) &lt; BUFF_SIZE:                break        return data.strip()    def send(self, msg, newline=True):        if newline:            msg += b'\\n'        self.request.sendall(msg)    def recv(self, prompt=b'[-] '):        self.send(prompt, newline=False)        return self._recvall()    def handle(self):        n = getPrime(128)        a, b, c, d = [randint(1, n - 1) for _ in range(4)]        seed1, seed2, seed3 = [randint(1, n - 1) for _ in range(3)]        lcg = TripleLCG(seed1, seed2, seed3, a, b, c, d, n)        dsa = DSA()        self.send(b\"Welcome to TGCTF Challenge!\\n\")        self.send(f\"p = {dsa.p}, q = {dsa.q}, g = {dsa.g}, y = {dsa.y}\".encode())        small_primes = [59093, 65371, 37337, 43759, 52859, 39541, 60457, 61469, 43711]        used_messages = set()        for o_v in range(3):            self.send(b\"Select challenge parts: 1, 2, 3\\n\")            parts = self.recv().decode().split()            if '1' in parts:                self.send(b\"Part 1\\n\")                for i in range(12):                    self.send(f\"Message {i + 1}: \".encode())                    msg = self.recv()                    used_messages.add(msg)                    k = lcg.next()                    r, s = dsa.sign(msg, k)                    self.send(f\"r = {r}, ks = {[k % p for p in small_primes]}\\n\".encode())            if '2' in parts:                self.send(b\"Part 2\\n\")                for _ in range(307):                    k = lcg.next()                for i in range(10):                    self.send(f\"Message {i + 1}: \".encode())                    msg = self.recv()                    k = lcg.next() % dsa.q                    r, s = dsa.sign(msg, k)                    self.send(f\"Signature: r = {r}, s = {s}\\n\".encode())                    used_messages.add(msg)            if '3' in parts:                self.send(b\"Part 3\\n\")                self.send(b\"Forged message: \")                final_msg = self.recv()                self.send(b\"Forged r: \")                r = int(self.recv())                self.send(b\"Forged s: \")                s = int(self.recv())                if final_msg in used_messages:                    self.send(b\"Message already signed!\\n\")                elif dsa.verify(final_msg, r, s):                    self.send(f\"Good! Your flag: {flag}\\n\".encode())                else:                    self.send(b\"Invalid signature.\\n\")###Welcome to TGCTF Challenge!p = 184352699172192576270535944394450689601424152593934253476634864667530549943623545663040121406222033469867822007490624607150449533351028007649079671823930639894259153639431593427418637301705583834256344087212849054820629604266938603002612952530534395948672534275310804229044744624757608906107492972246321630467, q = 1427475768627039429244287846531087092897981204933, g = 179483243075904419855912998377411172058265425529332248345132802466991524049692135618377118498301129461020930474539980424661227889497234584809425572665861532126589551010542468047939006056449514768312598585142121764108071687257917794156000007175743318015987068492602701013540262918705248846831651675444456948643, y = 65387748521549843710283006626280200692251144711420678211108890034468688391999964987744284367851744917929187743649125947284992180212308979307495115040557673902928236192043216997090684739998860758466653879269647032285760519012600075468974154258734633743042931772136088467213651982608545621578498333319665003265Select challenge parts: 1, 2, 3###\n数字签名问题，题干给出了一个三重LCG计算类，计算公式是\n\ns_{i+3}\\equiv as_{i}+bs_{i+1}+cs_{i+2}+d\\;mod\\;n\\\\\ns_1=seed_1\\;s_2=seed_2\\;s_2=seed_2\\\\\n我们先看part1，我们每输入一个，都会生成一个,并且用进行签名，然后再输出\n\n\n[k_i\\;mod\\;p_j,....](0","categories":["复现"],"tags":["CTF","RSA","LCG","DSA"]},{"title":"RSA--e与phi不互素","url":"/2025/04/28/RSA-e%E4%B8%8Ephi%E4%B8%8D%E4%BA%92%E7%B4%A0/","content":"前言我们知道，在RSA系统中，解密依赖于欧拉定理\n\na^{\\phi(p)}\\equiv1\\;mod\\;p\\;,\\;(a,p)=1\\\\以及同余等式\n\ned\\equiv1\\;mod\\;\\phi(n)\\\\,那么在已知\n\nc\\equiv\\;m^{e}\\;mod\\;n下，容易得到\n\nc^{d}\\equiv\\;(m^{e})^{d}\\;mod\\;n\\\\\ned=1+k\\phi(n)\\\\\nc^{d}\\equiv\\;m*m^{k\\phi(n)}\\;\\equiv\\;m*1\\;mod\\;n\\\\但是当不互素的情况下，私钥就无法正常计算，在此之下想要顺利求解明文,衍生了一系列问题，本文基于笔者日常中遇到的相关题型，给出对应的处理方法\n从简单情况出发我们不妨令\n\ngcd(e,\\phi)=t\\\\\nte^{'}=e\\\\那么考虑转化为公钥指数为的RSA，有\n\ne^{'}d^{'}\\equiv1mod\\phi(n)\\\\\nc\\equiv\\;m^{e}\\equiv\\;m^{te^{'}}\\;mod\\;n\\\\\nc^{d^{'}}\\equiv\\;m^{te^{'}d^{'}}\\;\\equiv\\;m^{t}\\;mod\\;n\\\\显然此时我们能够计算\n\nc^{d^{'}}\\;mod\\;n\\\\如果不是很大（个位数），当的时候，我们直接能得到\n\nc^{d^{'}}\\;mod\\;n=m^{t}\\\\，直接开次方就能得到\n如果不那么大的话，我们姑且还能尝试爆破\n\nc^{d^{'}}=kn+m^{t}\\\\，但是如果数据不支持，大到爆破不了，我们就得进一步观察已有数据中的代数结构了\n如果同时与，互质（CRT加速RSA问题）这里也就是在RSA中使用CRT算法加速运算的例子，我们都来讲讲如何操作\n\n为什么要用CRT？\n\n在RSA的计算中，我们有\n\ned\\equiv1\\;mod\\;\\phi(n)\\\\\nc\\equiv\\;m^d\\;modn\\\\，我们知道，往往非常大，那么计算上面两个式子就非常的消耗时间，而且也需要,我们注意到也是两个大质数，很有可能与即   ;   即也互素，那么我能就能把问题转化到模 下来讨论，下面是推导过程\n\n由c\\equiv\\;m^{e}\\;mod\\;n\\\\\nc\\equiv\\;m^p\\;mod\\;p\\\\\nc\\equiv\\;m^q\\;mod\\;q\\\\这是由于也就是模的传递性，那么我们转过来计算在模下的私钥，即\n\nedp\\equiv1\\;mod\\;\\phi(p)\\\\\ned_q\\equiv1\\;mod\\;\\phi(q)\\\\那么在解密的时候就有\n\nc^{d_p}\\equiv\\;m^{ed_p}\\equiv\\;m^{1+k\\phi(p)}\\;\\equiv\\;m\\;mod\\;p\\\\\nc^{d_q}\\equiv\\;m^{ed_q}\\equiv\\;m^{1+k\\phi(q)}\\;\\equiv\\;m\\;mod\\;q\\\\\n记c^{d_p}\\equiv\\;m\\;mod\\;p\\;\\;=m_1\\;\\;c^{d_q}\\equiv\\;m\\;mod\\;q\\;\\;=m_2\\\\这里是因为可能比要大，所以我们无法直接解出来，然后我们根据中国剩余定理可以构造出一个对的解，如下\n由第二个同余式不妨设\n\nm=m_2+hq\\;\\\\我们进而只需要解出来,把这个式子带入另一个同余式\n\nm_2+hq\\equiv\\;m_1mod\\;p\\\\\nhq\\equiv(m_1-m_2)\\;mod\\;p\\\\我们只需计算\n\nI_q\\equiv\\;q^{-1}\\;mod\\;p\\\\那么有\n\nh\\equiv\\;I_q(m_1-m_2)\\;mod\\;p\\\\得到之后回代即可成功求出\n可见这里我们的计算都是在模的式子中进行的，乘法运算的次数少了不少，实现了加速\n说回正题，从上面不难看出，我们自始至终都没有尝试计算，成功回避了这个问题\n来个例子—黑盾杯 2020-Factor\nn = 3454083680130687060405946528826790951695785465926614724373e = 3c = 1347530713288996422676156069761604101177635382955634367208gcd(m, n) = 1\n这里n不是很大，简单分解后能得到三个素因子，我们记为pqr，如下\np=11761833764528579549q=17100682436035561357r=17172929050033177661print(n-p*q*r) # 0print(gcd(e,phi)) # 3print(gcd(e,p-1)) # 1print(gcd(e,q-1)) # 3print(gcd(e,r-1)) # 1print(gcd(e,(p-1)*(r-1))) # 1\n简单检查了关系，如上，这题方法很多，在上面的解法下即利用来使用CRT求解，代码如下\n#sagedp=inverse(e,p-1)dr=inverse(e,r-1)m1=pow(c,dp,p)m2=pow(c,dr,r)Ir=pow(r,-1,p)h=pow(Ir*(m1-m2),1,p)m=m2+h*rprint(long_to_bytes(m))# CMISCCTF{3_RSA}\n这里也能转化到在模下尝试求解，但是那对明文的大小有一定要求，我们还是使用通法，这里只要能找到两个满足要求的因子就行，但是这不是什么时候都能生效，请看下题\n强网杯2022—[ASR]\nfrom Crypto.Util.number import getPrimefrom secret import falgpad = lambda s:s + bytes([(len(s)-1)%16+1]*((len(s)-1)%16+1))n = getPrime(128)**2 * getPrime(128)**2 * getPrime(128)**2 * getPrime(128)**2e = 3flag = pad(flag)print(flag)assert(len(flag) &gt;= 48)m = int.from_bytes(flag,'big')c = pow(m,e,n)print(f'n = {n}')print(f'e = {e}')print(f'c = {c}')n = 8250871280281573979365095715711359115372504458973444367083195431861307534563246537364248104106494598081988216584432003199198805753721448450911308558041115465900179230798939615583517756265557814710419157462721793864532239042758808298575522666358352726060578194045804198551989679722201244547561044646931280001e = 3c = 945272793717722090962030960824180726576357481511799904903841312265308706852971155205003971821843069272938250385935597609059700446530436381124650731751982419593070224310399320617914955227288662661442416421725698368791013785074809691867988444306279231013360024747585261790352627234450209996422862329513284149\n注意到这里特别对m进行了填充，就是保证m比n的因子大，无法转化为在小因子的域下求解，看看下面这段失败的exp\nfrom Crypto.Util.number import *e = 3n = 8250871280281573979365095715711359115372504458973444367083195431861307534563246537364248104106494598081988216584432003199198805753721448450911308558041115465900179230798939615583517756265557814710419157462721793864532239042758808298575522666358352726060578194045804198551989679722201244547561044646931280001c = 945272793717722090962030960824180726576357481511799904903841312265308706852971155205003971821843069272938250385935597609059700446530436381124650731751982419593070224310399320617914955227288662661442416421725698368791013785074809691867988444306279231013360024747585261790352627234450209996422862329513284149p = 225933944608558304529179430753170813347q = 260594583349478633632570848336184053653r = 218566259296037866647273372633238739089t = 223213222467584072959434495118689164399print(gcd(e,p-1)) # 3print(gcd(e,q-1)) # 1print(gcd(e,r-1)) # 3print(gcd(e,t-1)) # 1dt=inverse(e,t-1)dq=inverse(e,q-1)m1=pow(c,dt,t)m2=pow(c,dq,q)Iq=pow(q,-1,t)h=pow(Iq*(m1-m2),1,t)m=m2+h*qprint(long_to_bytes(m))\n这里的确找到了满足的两个因子，但是我们注意到，若又,所以我们在上述代码中解出来的满足，也就是说，如果的时候，这个方法就暂时失效了，这是在多因子RSA下特别的问题，注意到我们还有两个因子没有使用，为了也能使用上它们，我们给出更加一般的方法\n有限域开根想想我们的核心目标是什么？—求解 那么我们为什么要找到这个的?重新捋一遍过程，我们就发现，是为了去计算来求解满足的,换言之，我们还是在求模不同素因子下的,我们不妨想一下，真的重要吗？,我们看这个方程\n\nm^e-c\\equiv0\\;mod\\;a_i\\\\这不就是在下的方程吗？这里还非常小，完全可以在这个有限域下来开根求解所有符合题意的的取值集合，显然可能有多解，但是我们可以依次枚举中的值，由上述分析，若，那么否则也有\n那么我们枚举这四个集合，一定能找到满足我们需要的\n\n\\begin{cases}m_1=m\\;mod\\;a_1\\\\m_2=m\\;mod\\;a_2\\\\m_3=m\\;mod\\;a_3\\\\m_4=m\\;mod\\;a_4\\\\\\end{cases}这就是中国剩余定理了，我们直接打CRT就能解出来m，而且我们用到了所有的因子，几乎可以保证这里是唯一的，如果不是唯一的，我们确定一下中的，转化到模下就行，下面是修改后的exp\n# sagefrom Crypto.Util.number import *from itertools import product# Given parameterse = 3n = 8250871280281573979365095715711359115372504458973444367083195431861307534563246537364248104106494598081988216584432003199198805753721448450911308558041115465900179230798939615583517756265557814710419157462721793864532239042758808298575522666358352726060578194045804198551989679722201244547561044646931280001c = 945272793717722090962030960824180726576357481511799904903841312265308706852971155205003971821843069272938250385935597609059700446530436381124650731751982419593070224310399320617914955227288662661442416421725698368791013785074809691867988444306279231013360024747585261790352627234450209996422862329513284149# Prime factorsp = 225933944608558304529179430753170813347q = 260594583349478633632570848336184053653r = 218566259296037866647273372633238739089t = 223213222467584072959434495118689164399# Create polynomial rings and find roots in each fieldR.&lt;x&gt; = Zmod(p)[]f = x^e - cres_p = f.monic().roots()R.&lt;x&gt; = Zmod(q)[]f = x^e - cres_q = f.monic().roots()R.&lt;x&gt; = Zmod(r)[]f = x^e - cres_r = f.monic().roots()R.&lt;x&gt; = Zmod(t)[]f = x^e - cres_t = f.monic().roots()# Iterate through all possible combinations of rootsfor (m_p, _) in res_p:    for (m_q, _) in res_q:        for (m_r, _) in res_r:            for (m_t, _) in res_t:                # Combine using CRT in stages                # First combine p and q                m_pq = crt(int(m_p), int(m_q), p, q)                # Then combine r and t                m_rt = crt(int(m_r), int(m_t), r, t)                # Finally combine the two results                m = crt(m_pq, m_rt, p*q, r*t)                                mes = long_to_bytes(m)                print(mes)        # b'flag{Fear_can_hold_you_prisoner_Hope_can_set_you_free}\\x06\\x06\\x06\\x06\\x06\\x06'\n","categories":["Crypto"],"tags":["RSA","Crypto"]},{"title":"UCSCCTF2025","url":"/2025/04/20/UCSCCTF2025/","content":"\n1.XR4import base64import randomfrom secret import flagimport numpy as npdef init_sbox(key):    s_box = list(range(256))    j = 0    for i in range(256):        j = (j + s_box[i] + ord(key[i % len(key)])) % 256        s_box[i], s_box[j] = s_box[j], s_box[i]    return s_boxdef decrypt(cipher, box):    res = []    i = j = 0    cipher_bytes = base64.b64decode(cipher)    for s in cipher_bytes:        i = (i + 1) % 256        j = (j + box[i]) % 256        box[i], box[j] = box[j], box[i]        t = (box[i] + box[j]) % 256        k = box[t]        res.append(chr(s ^ k))    return (''.join(res))def random_num(seed_num):    random.seed(seed_num)    for i in range(36):        print(chr(int(str(random.random()*10000)[0:2]) ^ (data[i])))if __name__ == '__main__':    ciphertext = \"MjM184anvdA=\"    key = \"XR4\"    box = init_sbox(key)    a=decrypt(ciphertext, box)    random_num(int(a))# transposed_matrix=(data.reshape(6*6))^T# transposed_matrix=[[  1 111  38 110  95  44]#  [ 11  45  58  39  84   1]#  [116  19 113  60  91 118]#  [ 33  98  38  57  10  29]#  [ 68  52 119  56  43 125]#  [ 32  32   7  26  41  41]]\n类似RC4的流密码，解密思路是用密钥XR4解密密文MjM184anvdA=还原出随机数种子，用来重置随机数生成器，再恢复矩阵，最后生成随机数流逐位异或就能得到答案，exp\nimport base64import randomimport numpy as np# RC4初始化函数def init_sbox(key):    s_box = list(range(256))    j = 0    for i in range(256):        j = (j + s_box[i] + ord(key[i % len(key)])) % 256        s_box[i], s_box[j] = s_box[j], s_box[i]    return s_box# RC4解密函数def decrypt(cipher, box):    res = []    i = j = 0    cipher_bytes = base64.b64decode(cipher)    for s in cipher_bytes:        i = (i + 1) % 256        j = (j + box[i]) % 256        box[i], box[j] = box[j], box[i]        t = (box[i] + box[j]) % 256        k = box[t]        res.append(s ^ k)    return bytes(res)if __name__ == '__main__':    # 已知参数    ciphertext = \"MjM184anvdA=\"    key = \"XR4\"    transposed_matrix = np.array([        [1, 111, 38, 110, 95, 44],        [11, 45, 58, 39, 84, 1],        [116, 19, 113, 60, 91, 118],        [33, 98, 38, 57, 10, 29],        [68, 52, 119, 56, 43, 125],        [32, 32, 7, 26, 41, 41]    ])    # Step 1: 解密RC4获取种子    box = init_sbox(key)    seed_bytes = decrypt(ciphertext, box.copy())    seed = int(seed_bytes.decode())    print(f\"[+] 解密种子值: {seed}\") # 78910112    # Step 2: 恢复原始矩阵    original_matrix = transposed_matrix.T.reshape(-1)  # 转置恢复原始顺序        # Step 3: 生成随机数序列    random.seed(seed)    flag_chars = []    for num in original_matrix:        rand_val = int(str(random.random() * 10000)[:2])  # 生成前两位数字        flag_char = chr(rand_val ^ num)        flag_chars.append(flag_char)    # Step 4: 组合flag    flag = ''.join(flag_chars)    print(f\"\\n[+] 解密结果: {flag}\") # c570ee41-8b09-11ef-ac4a-a4b1c1c5a2d2\nflag{c570ee41-8b09-11ef-ac4a-a4b1c1c5a2d2}\n2.essentialfrom Crypto.Util.number import *import sympyfrom flag import flaga=getPrime(512)p=sympy.nextprime(13*a)q=sympy.prevprime(25*a)number2=p*qdef crypto01(number1, number2, number3):    number4 = 1    while number2 &gt; 0:        if number2 % 2:             number4 = (number4 * number1) % number3        number1 = number1 ** 2 % number3        number2 //= 2    return number4# n1^n2 mod n3def crypto02(number1, number2):    number3 = number1    number4 = number2    giao = 1    giaogiao = 0    while number4 &gt; 0:        number7 = number3 // number4        giao, giaogiao = giaogiao, giao - giaogiao*number7        number3, number4 = number4, number3 - number4*number7    while giao&lt;0:        giao = giao + number2    return giao#pow(n1,-1,n2)def crypto03(number1, number2, number3):    number4 = crypto01(number3, number1, number2)    return number4# n3^n1 mod n2def crypto05(number1,number2):    return pow(number1,0xe18e,number2)# n1^e mod n2number2 = 20163906788220322201451577848491140709934459544530540491496316478863216041602438391240885798072944983762763612154204258364582429930908603435291338810293235475910630277814171079127000082991765275778402968190793371421104016122994314171387648385459262396767639666659583363742368765758097301899441819527512879933947number1 = 6035830951309638186877554194461701691293718312181839424149825035972373443231514869488117139554688905904333169357086297500189578624512573983935412622898726797379658795547168254487169419193859102095920229216279737921183786260128443133977458414094572688077140538467216150378641116223616640713960883880973572260683number3 = int.from_bytes(flag[0:19].encode(\"utf-8\"), \"big\")number4 = int.from_bytes(flag[19:39].encode(\"utf-8\"), \"big\")print(crypto03(number1, number2, number3))print(crypto05(number4,number2))#6624758244437183700228793390575387439910775985543869953485120951825790403986028668723069396276896827302706342862776605008038149721097476152863529945095435498809442643082504012461883786296234960634593997098236558840899107452647003306820097771301898479134315680273315445282673421302058215601162967617943836306076  p1#204384474875628990804496315735508023717499220909413449050868658084284187670628949761107184746708810539920536825856744947995442111688188562682921193868294477052992835394998910706435735040133361347697720913541458302074252626700854595868437809272878960638744881154520946183933043843588964174947340240510756356766  p2\n套层皮的RSA，crypto01计算的是\n\nn_1^{n_2}\\;mod\\;n_3\\\\ crypto02计算的是\n\nn_1^{-1}\\;mod\\;n_2\\\\ crypto03计算的是\n\nn_3^{n_1}\\;mod\\;n_2\\\\ crypto05计算的是\n\nn_1^e\\;mod\\;n_2\\\\这里给出了\n\nn_1=pq,注意到a就512位，且考虑到质数分步在500多位下都很密集，p应该很接近13a，q很接近25a，那么就可以对n1除去13*25再开根，得到一个a的初步估计，再尝试搜索出p,q的值，脚本如下\ndef find_a(n):    a_approx = gmpy2.isqrt(n // 325)    for delta in range(-1000, 1000):  # 搜索偏移范围        a_candidate = int(a_approx) + delta        p = sympy.nextprime(13 * a_candidate)        q = sympy.prevprime(25 * a_candidate)        if p * q == n:            return a_candidate, p, q    return Nonea, p, q = find_a(n)print(f\"[+] Found a: {a}\")print(f\"p = {p}\\nq = {q}\")```[+] Found a: 7876724580534791771835430594434627088013471560469412207736963203935537053220379418645369259714178145931522503674390087394035229717461111762112820042426110p = 102397419546952293033860597727650152144175130286102358700580521651161981691864932442389800376284315897109792547767071136122457986326994452907466660551539601q = 196918114513369794295885764860865677200336789011735305193424080098388426330509485466134231492854453648288062591859752184850880742936527794052820501060652747```\n有了p,q之后就是很基础的RSA解明文了，注意到e与phi不互素，但是gcd很小，先试着用e//2算，实在不行再尝试有限域开根，所幸这里直接就算出来了,exp\np = 102397419546952293033860597727650152144175130286102358700580521651161981691864932442389800376284315897109792547767071136122457986326994452907466660551539601q = 196918114513369794295885764860865677200336789011735305193424080098388426330509485466134231492854453648288062591859752184850880742936527794052820501060652747number2 = 20163906788220322201451577848491140709934459544530540491496316478863216041602438391240885798072944983762763612154204258364582429930908603435291338810293235475910630277814171079127000082991765275778402968190793371421104016122994314171387648385459262396767639666659583363742368765758097301899441819527512879933947number1 = 6035830951309638186877554194461701691293718312181839424149825035972373443231514869488117139554688905904333169357086297500189578624512573983935412622898726797379658795547168254487169419193859102095920229216279737921183786260128443133977458414094572688077140538467216150378641116223616640713960883880973572260683c1 = 6624758244437183700228793390575387439910775985543869953485120951825790403986028668723069396276896827302706342862776605008038149721097476152863529945095435498809442643082504012461883786296234960634593997098236558840899107452647003306820097771301898479134315680273315445282673421302058215601162967617943836306076c2 = 204384474875628990804496315735508023717499220909413449050868658084284187670628949761107184746708810539920536825856744947995442111688188562682921193868294477052992835394998910706435735040133361347697720913541458302074252626700854595868437809272878960638744881154520946183933043843588964174947340240510756356766e=0xe18ephi = (p-1)*(q-1)print(GCD(number1,phi))d1 = inverse(number1,phi)m1 = pow(c1,d1,number2)d2 = inverse(e//2,phi)M2 = pow(c2,d2,number2)m2 = int(gmpy2.iroot(M2,2)[0])print(long_to_bytes(m1)+long_to_bytes(m2))#b'flag{75811c6d95770d56092817b75f15df05}'\nflag{75811c6d95770d56092817b75f15df05}\n3.EZ-calculatefrom Crypto.Util.number import *from random import randintfrom hashlib import md5flag1 = b'xxx'flag2 = b'xxx'Flags = 'flag{' + md5(flag1+flag2).hexdigest()[::-1] + '}'def backpack_encrypt_flag(flag_bytes, M, group_len):    bits = []    for byte in flag_bytes:        bits.extend([int(b) for b in format(byte, \"08b\")])    while len(bits) % group_len != 0:        bits.append(0)    S_list = []    for i in range(0, len(bits), group_len):        group = bits[i:i + group_len]        S = sum(bit * m for bit, m in zip(group, M))        S_list.append(S)    return S_listdef backpack(flag_bytes):    R = [10]    while len(R) &lt; 8:        next_val = randint(2 * R[-1], 3 * R[-1])        R.append(next_val)    B = randint(2 * R[-1] + 1, 3 * R[-1])    A = getPrime(100)    M = [A * ri % B for ri in R]    S_list = backpack_encrypt_flag(flag_bytes, M, len(M))    return R, A, B, M, S_listp = getPrime(512)q = getPrime(512)n = p*qe = 0x10000m = bytes_to_long(flag1)k = randint(1, 999)problem1 = (pow(p,e,n)-pow(q,e,n)) % nproblem2 = pow(p-q,e,n)*pow(e,k,n)c = pow(m,e,n)R, A, B, M, S_list = backpack(flag2)with open(r\"C:\\Users\\Rebirth\\Desktop\\data.txt\", \"w\") as f:    f.write(f\"problem1 = {problem1}\\n\")    f.write(f\"problem2 = {problem2}\\n\")    f.write(f\"n = {n}\\n\")    f.write(f\"c = {c}\\n\")    f.write(\"-------------------------\\n\")    f.write(f\"R = {R}\\n\")    f.write(f\"A = {A}\\n\")    f.write(f\"B = {B}\\n\")    f.write(f\"M = {M}\\n\")    f.write(f\"S_list = {S_list}\\n\")    f.write(\"-------------------------\\n\")    f.write(f\"What you need to submit is Flags!\\n\")\n\npart1\nRSA,题目给出的是\n\np_1=(p^e-q^e)\\;mod\\;n\\\\\np_2=(p-q)^e\\;mod\\;n\\;\\;*\\;\\;e^k\\;mod\\;n\\\\\n\n  这里我们的思路是枚举k的取值，计算出pow(e,k,n)之后用p2来除它，得到P，那么由二项式定理\n\n  \\frac{p_2}{e^kmodn}=P\\;=(p-q)^e\\;mod\\;n=p^e+q^emod\\;n\\\\  上下相加，容易得到\n\n  p_1+P=2p^emod\\;n\\\\\n  p=gcd(p_1+P,n)\\\\  同样的方法我们也能枚举出q，再用位数和正负号作为制约就能爆破出p,q的值，脚本如下\n  problem1 = 24819077530766367166035941051823834496451802693325219476153953490742162231345380863781267094224914358021972805811737102184859249919313532073566493054398702269142565372985584818560322911207851760003915310535736092154713396343146403645986926080307669092998175883480679019195392639696872929250699367519967334248problem2 = 20047847761237831029338089120460407946040166929398007572321747488189673799484690384806832406317298893135216999267808940360773991216254295946086409441877930687132524014042802810607804699235064733393301861594858928571425025486900981252230771735969897010173299098677357738890813870488373321839371734457780977243838253195895485537023584305192701526016n = 86262122894918669428795269753754618836562727502569381672630582848166228286806362453183099819771689423205156909662196526762880078792845161061353312693752568577607175166060900619163231849790003982326663277243409696279313372337685740601191870965951317590823292785776887874472943335746122798330609540525922467021c = 74962027356320017542746842438347279031419999636985213695851878703229715143667648659071242394028952959096683055640906478244974899784491598741415530787571499313545501736858104610426804890565497123850685161829628373760791083545457573498600656412030353579510452843445377415943924958414311373173951242344875240776e=65536for i in range(1,1000):    k = pow(e,i,n)    Pr2 = problem2//k    # print(isinstance(Pr2,int))    sum = problem1+Pr2    sub = Pr2 - problem1    if sub&gt;0 :        q = GCD(sub,n)        print(q)# 爆破p q#p = 9586253455468582613875015189854230646329578628731744411408644831684238720919107792959420247980417763684885397749546095133107188260274536708721056484419031#q = 8998523072192453101232205847855618180700579235012899613083663121402246420191771909612939404791268078655630846054784775118256720627970477420936836352759291\n  然后这里e是65536，不和phi互素，gcd是4，就考虑有限域开根然后用crt算可能的解了，脚本如下\n  from Crypto.Util.number import *from math import gcdfrom sage.all import *# 给定参数p = 9586253455468582613875015189854230646329578628731744411408644831684238720919107792959420247980417763684885397749546095133107188260274536708721056484419031q = 8998523072192453101232205847855618180700579235012899613083663121402246420191771909612939404791268078655630846054784775118256720627970477420936836352759291n = p * qe = 65536c = 74962027356320017542746842438347279031419999636985213695851878703229715143667648659071242394028952959096683055640906478244974899784491598741415530787571499313545501736858104610426804890565497123850685161829628373760791083545457573498600656412030353579510452843445377415943924958414311373173951242344875240776possible_m = []def decrypt_rsa_with_coprime_e(p, q, e, c):    # 计算模p和模q的c值    c_p = c % p    c_q = c % q    # 处理模p下的解    s_p = (p - 1) // 2  # 因为p-1的2的指数为1    d_p = pow(e, -1, s_p)    m_p = pow(c_p, d_p, p)    solutions_p = [m_p, (-m_p) % p]    # 处理模q下的解    s_q = (q - 1) // 2  # q-1的2的指数为1    d_q = pow(e, -1, s_q)    m_q = pow(c_q, d_q, q)    solutions_q = [m_q, (-m_q) % q]    # 使用CRT组合所有可能的解    from itertools import product    possible_m = []    for mp, mq in product(solutions_p, solutions_q):        m = CRT([mp, mq], [p, q])        possible_m.append(m)    return possible_m    # 执行解密possible_m = decrypt_rsa_with_coprime_e(p, q, e, c)for m in possible_m:    print(long_to_bytes(m))# b'CRYPTO_ALGORIT'\n  不过跑出来b’CRYPTO_ALGORIT’就是第一个，有可能开根也能做呢\n\npart2\n背包加密，不过该给的都给了，按照加密过程反过来写很快就能搞出来\nfrom Crypto.Util.number import long_to_bytesimport math# 已知参数R = [10, 29, 83, 227, 506, 1372, 3042, 6163]A = 1253412688290469788410859162653B = 16036M = [10294, 12213, 10071, 4359, 1310, 4376, 7622, 14783]S_list = [13523, 32682, 38977, 44663, 43353, 31372, 17899, 17899, 44663, 16589, 40304, 25521, 31372]def backpack_decrypt(S_list, A, B, M):    # 1. 验证A与B互质    assert math.gcd(A, B) == 1, \"A and B must be coprime\"        # 2. 计算A的模逆元    inv_A = pow(A, -1, B)        # 3. 恢复超递增序列R    R_recovered = [(m * inv_A) % B for m in M]    print(\"恢复的R:\", R_recovered)  # 应等于原始R        # 4. 解密每个S值    bits = []    for S in S_list:        # 将S转换为超递增背包问题        S_prime = (S * inv_A) % B                # 贪心算法解背包        group = []        remaining = S_prime        for r in reversed(R_recovered):            if remaining &gt;= r:                group.append(1)                remaining -= r            else:                group.append(0)        bits.extend(group[::-1])  # 反转后加入        # 5. 转换二进制为字节    bytes_data = b''    for i in range(0, len(bits), 8):        byte_bits = bits[i:i+8]        if len(byte_bits) &lt; 8:            byte_bits += [0]*(8 - len(byte_bits))        byte = int(''.join(map(str, byte_bits)), 2)        bytes_data += bytes([byte])        # 6. 去除填充的零    return bytes_data.rstrip(b'\\x00')# 执行解密flag2 = backpack_decrypt(S_list, A, B, M)print(\"解密结果:\", flag2.decode())# HMS_WELL_DONE\n最后对两个flag拼接之后取md5，flag{64f67374264b7621650b1de4dbc5f924}\n\n\n4.merge_ECC#t.sageimport randomfrom sympy import nextprimedef part1():    p = random_prime(2^512, 2^513)    a = random.randint(0, p-1)    b = random.randint(0, p-1)    while (4 * a**3 + 27 * b**2) % p == 0:        a = random.randint(0, p-1)        b = random.randint(0, p-1)    E = EllipticCurve(GF(p), [a, b])#构造一个模p环下的关于a,b的椭圆曲线    P=E.random_point()#曲线上的随机一个点    n = [random.randint(1, 2**20) for _ in range(3)] #随机的一个点    assert part1=''.join([hex(i)[2:] for i in n])    cipher = [n[i] * P for i in range(3)]    print(f\"N = {p}\")    print(f\"a = {a}, b = {b}\")    print(f\"P = {P}\")    for i in range(3):        print(f\"cipher{i} = {cipher[i]}\")# CRTdef part2():    p =  839252355769732556552066312852886325703283133710701931092148932185749211043    a =  166868889451291853349533652847942310373752202024350091562181659031084638450    b =  168504858955716283284333002385667234985259576554000582655928538041193311381    P = E.random_point()    Q = key*P    print(\"p = \",p)    print(\"a = \",a)    print(\"b = \",b)    print(\"P = \",P)    print(\"Q = \",Q)    assert part2=keypart1()print(\"-------------------------------------------\")part2()assert flag=\"flag{\"+str(part1)+\"-\"+str(part2)+\"}\"\n考察的是有关ECC的两种特殊攻击方法\n\npart1\n攻击的思路是Pohlig-Hellman攻击，要求是曲线的阶有小因数，这里E.order计算出来是512位，丢yafu分解之后发现有7个因子，其中5个比较小，且全部乘起来之后是比要大的，因此我们就可以取小的5个因子来进行攻击，脚本如下\nfrom sage.all import *from Crypto.Util.number import *n = 8186762541745429544201163537921168767557829030115874801599552603320381728161178278432652391299286759969365150578265902315058515370390070500719061057476940print(n.bit_length())# 2*2*5*11*499*683*124696170958113532210068667*875618937758378886905025632349007870524674918888468835522805095350653442872611049093102429356717528012933133846029979343# 椭圆曲线参数p = 8186762541745429544201163537921168767557829030115874801599552603320381728161132002130533050721684554609459754424458805702284922582219134865036743485620797a = 1495420997701481377470828570661032998514190598989197201754979317255564287604311958150666812378959018880028977121896929545639701195491870774156958755735447b = 5991466901412408757938889677965118882508317970919705053385317474407117921506012065861844241307270755999163280442524251782766457119443496954015171881396147E = EllipticCurve(GF(p), [a, b])# 生成元和密文点P = E(    6053058761132539206566092359337778642106843252217768817197593657660613775577674830119685211727923302909194735842939382758409841779476679807381619373546323,    7059796954840479182074296506322819844555365317950589431690683736872390418673951275875742138479119268529134101923865062199776716582160225918885119415223226)cipher0 = E(    4408587937721811766304285221308758024881057826193901720202053016482471785595442728924925855745045433966244594468163087104593409425316538804577603801023861,    5036207336371623412617556622231677184152618465739959524167001889273208946091746905245078901669335908442289383798546066844566618503786766455892065155724816)cipher1 = E(    2656427748146837510897512086140712942840881743356863380855689945832188909581954790770797146584513962618190767634822273749569907212145053676352384889228875,    4010263650619965046904980178893999473955022015118149348183137418914551275841596653682626506158128955577872592363930977349664669161585732323838763793957500)cipher2 = E(    1836350123050832793309451054411760401335561429787905037706697802971381859410503854213212757333551949694177845513529651742217132039482986693213175074097638,    1647556471109115097539227566131273446643532340029032358996281388864842086424490493200350147689138143951529796293632149050896423880108194903604646084656434)# 已知阶的分解（排除最后两个大因子）primes = [4, 5, 11, 499, 683]  # 2^2, 5, 11, 499, 683def pohlig_hellman(P, Q, primes):    dlogs = []    for fac in primes:        t = P.order() // fac        PP = t * P        QQ = t * Q        dlog = PP.discrete_log(QQ)  # 自动选择最佳算法        dlogs.append(dlog)        print(f\"Factor: {fac}, Discrete Log: {dlog}\")    return crt(dlogs, primes)# 计算三个离散对数print(\"计算n0:\")n0 = pohlig_hellman(P, cipher0, primes)print(\"\\n计算n1:\")n1 = pohlig_hellman(P, cipher1, primes)print(\"\\n计算n2:\")n2 = pohlig_hellman(P, cipher2, primes)# 验证结果assert cipher0 == n0 * Passert cipher1 == n1 * Passert cipher2 == n2 * P# 拼接结果part1 = hex(n0)[2:] + hex(n1)[2:] + hex(n2)[2:]print(\"\\n解密结果:\", part1)# f61bd9f152e65ac\n\npart2\nsmart攻击，这里曲线计算出来阶和模数相同，脚本如下\nfrom sage.all import *from Crypto.Util.number import *from gmpy2 import *p =  839252355769732556552066312852886325703283133710701931092148932185749211043a =  166868889451291853349533652847942310373752202024350091562181659031084638450b =  168504858955716283284333002385667234985259576554000582655928538041193311381E = EllipticCurve(GF(p), [a, b])r = E.order()# 839252355769732556552066312852886325703283133710701931092148932185749211043print(r)P =  E(547842233959736088159936218561804098153493246314301816190854370687622130932 , 259351987899983557442340376413545600148150183183773375317113786808135411950 )Q =  E(52509027983019069214323702207915994504051708473855890224511139305828303028 , 520507172059483331872189759719244369795616990414416040196069632909579234481 )def SmartAttack(P,Q,p):    E = P.curve()    Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ])    P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True)    for P_Qp in P_Qps:        if GF(p)(P_Qp.xy()[1]) == P.xy()[1]:            break    Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True)    for Q_Qp in Q_Qps:        if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]:            break    p_times_P = p*P_Qp    p_times_Q = p*Q_Qp    x_P,y_P = p_times_P.xy()    x_Q,y_Q = p_times_Q.xy()    phi_P = -(x_P/y_P)    phi_Q = -(x_Q/y_Q)    k = phi_Q/phi_P    return ZZ(k)r = SmartAttack(P, Q, p)print(r)# 7895892011\nflag{f61bd9f152e65ac-7895892011}\n\n\n\n\n*5.logos2023赣政杯原题，这里是别的师傅写的博客2023赣政杯 —- Crypto_赣政杯2023-CSDN博客\n还在被sagemath各种环境问题折磨，就暂时不细写了\n","categories":["WP"],"tags":["CTF","Crypto","ECC","DLP"]},{"title":"WHUCTF2025","url":"/2025/04/14/WHUCTF2025/","content":"WHUCTF2025复盘\n\nLSFR_Signin\n\n原题代码如下\nfrom Crypto.Util.number import *flag = b\"whuctf{}\"flag = list(bin(bytes_to_long(flag))[2:])assert(len(flag) == 255)for i in range(len(flag)):    flag[i] = int(flag[i])for i in range(2025):    flag.append(flag[i] ^ flag[i+20] ^ flag[i+25] ^ flag[i+250] ^ flag[-1])    print(flag[-1], end=\"\")\n已知flag为255位，对于线性寄存器，根据i i+20 i+25 i+250 以及最后一位就能解出下一位，于是我们从第256位开始往后，有\n\nflag_i = flag_{i+20} xor flag_{i+25}xorflag_{i+250}xorflag_{i+254}xorflag_{i+256}i取0到254，而我们已知255~2280位，取255~510位来解密就可以，脚本如下\nfrom Crypto.Util.number import long_to_bytes# 初始化长度为255的全0数组s = [0] * 255# 给定的01串bit_string = \"110000011011110000010101100011111101011011111111111111101011000111001010111000101111101100011011000110011000100010011111110111010110000111111111111101111011011101000000010011110010111000110100110011101110101010110001110100111001100011100001001000000011010011001101001000000000110110100101000110000011011100011100001000010001110000111110000110010001110001101011101110100011010000101101000000000001101111111001010100011110110001101010010100011010011010010110010110100011001100010010010110110010010001111010111100011101100001111111110101011010011111110101000110010000101011011101000000111000001011010010001010101101111111001100010001001011100100111000010100011001001111011110111111101100111001011100001110110110100010011010011111110010111001101000011000011111001101100111001111000010011110011111001010001111110001010100100011001000100011001010010111010000011101011001111111010010010101001010011010000010000100001010111000000000010011011110110001101010010101001010100100010110001001000101000001011111010110101110111100101001100101011000010000101010001010111010111010010110001111010000001101101100101111001010010010011010101110001101001111011010001000010111010011010001011011011000111101010001101110000100100011010011111110110000001101100010011000110100010101010010101100101011001001100010100111011101111100010111100010001101100101100111110101001111101000010110110011000111100110101001111001100110111100111111000101101101000011110011001101100111100111001001001001100101111101110111011111110110101000001100010110101101100100001110100110101100101011010101101101100011011000001111001010001110000110001001011001001110111110000001000011000011000101010101010010010100010011011000011100111011101111110100101111111001011010110010010011101011001011110001101110110110111110100000100001111100101000001101010000011001001100100010101111010100000010110010010111000000010010101001011001011001111001000100010100101000011110110101001011111011111001010111101111000001101101100101111010101100110000111011101100100000011001110011000110110100101010100\"# 将01串添加到数组后面for i in range(len(bit_string)):    s.append(int(bit_string[i]))# 从i=254开始向前计算for i in range(254, -1, -1):    s[i] = s[i+20] ^ s[i+25] ^ s[i+250] ^ s[i+254] ^ s[i+255]# 截取前255位并转换为字符串result_bits = ''.join(str(bit) for bit in s[:255])# 转换为长整型然后转为字节result_long = int(result_bits, 2)result_bytes = long_to_bytes(result_long)print(result_bytes)#whuctf{quit3_ea5y_Sign1n_R1ght?}\n\nRSAASR\n\n题干：\nfrom Crypto.Util.number import getPrime, isPrime, bytes_to_long, long_to_bytesdef generate(bit):    while True:        p = getPrime(bit)        q = rev(p)        if isPrime(q):            break    return p, qrev = lambda x: int(bin(x)[:1:-1], 2)  # 二进制反转整数flag = b\"??????\"p, q = generate(512)n = p * qe = 65537c = pow(bytes_to_long(flag), e, n)print(f\"n={n}\")print(f\"e={e}\")print(f\"c={c}\")\np和q二进制颠倒，采用爆破的思路，同时估计p q的范围，并且每次取p q的低k位（k为已经爆破出来的位）相乘，对结果取低k位，如果和n的低k位相同就继续，不同就剪去，代码如下，板子参照博客：Crypto趣题-剪枝 | 糖醋小鸡块的blog (tangcuxiaojikuai.xyz)\nfrom Crypto.Util.number import *import syssys.setrecursionlimit(1500)n=89260288112458610375700543707493254232809306221431627423709616690294586688526862549905410606087786699242563057156677052913617284849136716660502920085006747882186134482309361626185003661858419446057779826705477210404882478906671799290032009310469036065257789664458482249297907582602310789531951177426393110643e=65537c=34953739673730018843655174314108340461262205663805875643136393046216892771730195951086950749299233260612871271352091804579992550715616098448464010205976283620661044089962336249776561849400241337436006809354102892524119722533361144592982143227173415365371111087024439252557012289555411199194971295453523635612def find(ph,qh):    l = len(ph)    pl = qh[::-1]    ql = ph[::-1]    p_max = ph + (512-2*l)*'1' + pl    q_max = qh + (512-2*l)*'1' + ql    p_min = ph + (512-2*l)*'0' + pl    q_min = qh + (512-2*l)*'0' + ql    if(int(p_max,2) * int(q_max,2) &lt; n):        return    if(int(p_min,2) * int(q_min,2) &gt; n):        return    if(int(pl,2) * int(ql,2)  %  (2**(l-1)) != n % (2**(l-1))):        return        if(l == 256):        pp0 = int(p_max,2)        if(n % pp0 == 0):            pf = pp0            qf = n//pp0            phi = (pf - 1)*(qf - 1)            d = inverse(e,phi)            m1 = pow(c,d,n)            print(long_to_bytes(m1))            exit()    else:        find(ph+'1',qh+'1')        find(ph+'1',qh+'0')        find(ph+'0',qh+'1')        find(ph+'0',qh+'0')find('1','1')# WHUCTF{cryptography_and_reverse}\n\n*ez_lattice\n\n格密码相关，题干\nfrom Crypto.Util.number import *flag = b\"whuctf{}\"blen = 512l = len(flag) // 4 #未知n = 2X = []a = [bytes_to_long(flag[i * l: i * l + l]) for i in range(2)] #切成两部分b = 0p = getPrime(blen)for i in range(2):    X.append(getRandomNBitInteger(blen))    b = (a[i] * X[i]) % p       assert b.bit_length() &lt; 110print(\"p =\", p)print(\"X =\", X) # p = 12478746590758967738992827236548867094406642228843048782158822830242432957850861746109083849369751421558416546441433265483311369062332823391326650330844473# X = [4370703796271085517745653374714633557060694569231794372714420305839580193452505356598920188429238758568075323630107438853033389535935767953293146851021439, 5636765597544539887670148818611437395262628189014720546978418282055551396918915796702935478309173130501906553399905160951176701403838275497327658585404887]n = 2X = []a = [bytes_to_long(flag[i * l: i * l + l]) for i in range(2, 4)]print(a)p = getPrime(blen)for i in range(n):    X.append(getRandomNBitInteger(blen))    b = (a[i] * X[i]) % p    assert b.bit_length() &lt;= 55s = getRandomNBitInteger(55)P = p - sprint(\"P =\", P)print(\"X =\", X)# P = 8064317391291915578249751043887298750752952396481901402238164933671762816998644264248732894561122039999833298392825353792148892469165631966482732750535761# X = [6042201174605160506707043360458329015685676206288676104013330039569480295420873678739841513174948925787517746114885517054730046775608073287427260847787072, 6232867934334525782602291010514616748943593081406115516232887372014738839717093295759414233886061184914495957664550361507367497641317336980894814940037711]\n简单分析可知分为两个部分，前半段是\n\nb = kp+a_iX_i本质是两个方程，这里有两种方法可以解决，都写一下\n\n1.根据两个方程造3*3的格子\n将上式展开，有\n\n\\begin{aligned}\nb &= kp + a_1 X_1 \\\\\nb &= kp + a_2 X_2\n\\end{aligned}观察式子，不难得到矩阵运算式\n\n(a_1,a_2,k)\\begin{pmatrix}\n1&0&X_1\\\\\n0&1&X_2\\\\\n0&0&p\n\\end{pmatrix}=(a_1,a_2,2b)接下来运用Hermite\n上界为 ,大概是170位，右边的目标向量长度取决于a1,a2,b但肯定不会超过上界，我们可以先解一下看看\n\n\nX1 = X[0]X2 = X[1]# 构造 3×3 格基L = Matrix(ZZ, [    [1, 0, X1],    [0, 1, X2],    [0, 0, p]])a1 = L.LLL()[0][0]a2 = L.LLL()[0][1]a1 = abs(a1)a2 = abs(a2)print(long_to_bytes(a1))print(long_to_bytes(a2))#b'whuctf{'#b'Lattice'\n\n一个思路更简单的思路，感谢(zijeff (github.com))\n\nL0 = Matrix(ZZ,[    [1,X[0]],    [0,p]])M0 = L0.LLL()[0]  v0 = L0.solve_left(M0) for i in range(1,10000):    a0 = abs(v0[0]) * i    m0 = long_to_bytes(int(a0))    tag = True    for m in m0:        if not chr(m) in string.printable:            tag = false            break    if tag:        print(long_to_bytes(int(a0)))\n\n*pollard&amp;williams\n\nfrom Crypto.Util.number import *import osflag = b'whuctf{}'blen = 256def rsa(p, q, message):    n = p * q    e = 65537    pad_length = n.bit_length() // 8 - len(message) - 2 #块长为 n的长度除8（字节数） 减去mes长度再减2    message += os.urandom(pad_length) #生成pad_length个随机字节    m = bytes_to_long(message)    return n, pow(m, e, n)def part1(message1, message2):    while True:        p1 = getPrime(blen)        p2 = (p1 - 1) // 2 #相当于p1右移一位，且放掉最低位        if isPrime(p2):            break    q1 = getPrime(blen)    q2 = getPrime(blen)    return rsa(p1, q1, message1), rsa(p2, q2, message2)def part2(message1, message2):    while True:        p1 = getPrime(blen)        p2 = (p1 + 1) // 2 #没有明显关系        if isPrime(p2):            break    q1 = getPrime(blen)    q2 = getPrime(blen)    return rsa(p1, q1, message1), rsa(p2, q2, message2)assert len(flag) == 44l = len(flag) // 4m1, m2, m3, m4 = [flag[i * l: i * l + l] for i in range(4)]# 切成四段c1, c2 = part1(m1, m2)c3, c4 = part2(m3, m4)print(f'{c1 = }')print(f'{c2 = }')print(f'{c3 = }')print(f'{c4 = }')# c1 = (6053032598894343876848386724367478876865502990878797490385487692233771017587839889683279773931697102081210221515871925626229356354906807395177342943323369, 4066195854081844630643812355140109730178549671457699640787009592379117222130777528564788537029636082768525403919530491221982157867347461546035515101540809)# c2 = (3881600892538209342174115382004433032693183438455968854185245139152150453077746028435728337685187304179257593974737056409431270271087770400534952463611803, 3170419555737452151768856928448822332346045957475336562622244748908867061340721719260259808765271614258250388620180512676045609008728482012225062330421389)# c3 = (12299016617136978588548772285625358530978334196485520160172325214608426825374255755330322407319092229940503630270734074076341447314630647646764214262929507, 318163940794629731124968470499655451861010987042419720693423620230895540439020747998494269609254222775880714679954773027280497632868550785421041286883861)# c4 = (4549315768074822845197072475333248869579555413221208949230121240611191001190288208256119819724334902434536556333152862828649067092565476816480268615884657, 1882968780168858989700488482275734089425710600149658668167954773629584030303631176914870357507995175067079535271674721507969999430710585448040194277936142)\n基于pollard p-1和willams p+1两个大数分解算法\n\n1\n可知 由欧拉定理不难得到\n\n2^{2n_2} = 2^{p_1-1} \\equiv 1 \\;(modp_1)\\\\\np_1\\;|\\;2^{2n_2}-1\\\\\np_1 = gcd(n_1,2^{2n_2-1})直接算就行，代码如下\np1 = gmpy2.gcd(gmpy2.powmod(3, 2 * n2, n1) - 1, n1)p2 = (p1 - 1) // 2q1 = n1 // p1q2 = n2 // p2\n\n2\n证明比较繁琐，先给出结论\n对于如下Lucas序列\n\nV_0 = 2\\\\\nV_1 = A\\\\\nV_n = AV_{n-1}-V_{n-2}\\\\令,若  有 \n\np\\;| gcd(V_m-2,n) \\;\\; p|n\\;\\;其中p-(\\frac D p )|m\\;\\;(\\frac D p )为勒让德符号\n\n思路就是，枚举A，1到15往往就够了，找到一个D不是p的二次剩余，也就是有\n这里我们容易发现,那么2n2就是我们代入的m，接下来用我们枚举的A,找到的m来迭代运算lucas序列，求出来之后做两次gcd即可，最终\n\np_1 = gcd(gcd(V_{2n_2}\\;-\\;2,n_1)\\;,\\;n_1)脚本在这里\ndef lucas_v(a,n):    v0 = 2    v1 = a    R = ZZ     M = matrix(R,[[a,-1],[1,0]])     v = M**(n-1) * vector(R,[v1,v0])    return v[0]for a in range(2,10):    p3 = ZZ(gcd(lucas_v(a,2 * n4) - 2, n3))    if 1&lt; p3 &lt; n3:        breakp4 = (p3+1) // 2q3 = n3 // p3q4 = n4 // p4     \n\n*seista’s revenge\n\nfrom Crypto.Util.Padding import padfrom Crypto.Util.number import *from Crypto.Cipher import AESfrom hashlib import *flag = b\"whuctf{}\"blen = 512p = getPrime(blen)s = getRandomNBitInteger(100)P = p + st = 2X = []a = [getPrime(160) for _ in range(t)]for i in range(t):    X.append(inverse(a[i], p))key = sha256(str(a[0]*a[1]).encode()).digest()[:16]iv = b\"0\" * 16AES = AES.new(key, AES.MODE_CBC, iv)print(\"X =\", X)print(\"P =\", P)print(\"ct =\", AES.encrypt(pad(flag, AES.block_size)))# X = [1266403423628708294851978766647131186574350037928491893316575383770634141679199238688724846443316942748685589080912612989737322832820423142859211423222170, 10633805933378187507165706136587361125130747673943368523389315948924728188453225153073019422908293191827053741582511390426559341625596650317484672418362991]# P = 12727949469666331910572325155797935927989546075198211256583307434798528241134917675474139742863165705376701853130873014549089300596914514323642506815012401# ct = b'\\xe9\\x87\\x942\\xbc\\x94`t\\x85^r\\xb8\\xd2\\x00\\xfb\\xb0Ni\\x08\\xcf\\x07\\xf1\\xae\\x95U{\\xf1\\xd4\\xda}@H'# Lattice\nez_lattice的part2稍微改了一下上来的，求a0,a1就可以了\n这里有\n\na_iX_i \\equiv 1\\;\\;mod p\\\\其实不论b怎么样，我们都是用类似的方法求解\nfrom Crypto.Util.number import *import gmpy2from sage.all import *import libnumimport stringfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadfrom hashlib import sha256X = [1266403423628708294851978766647131186574350037928491893316575383770634141679199238688724846443316942748685589080912612989737322832820423142859211423222170, 10633805933378187507165706136587361125130747673943368523389315948924728188453225153073019422908293191827053741582511390426559341625596650317484672418362991]P = 12727949469666331910572325155797935927989546075198211256583307434798528241134917675474139742863165705376701853130873014549089300596914514323642506815012401ct = b'\\xe9\\x87\\x942\\xbc\\x94`t\\x85^r\\xb8\\xd2\\x00\\xfb\\xb0Ni\\x08\\xcf\\x07\\xf1\\xae\\x95U{\\xf1\\xd4\\xda}@H'# 这里s只有100位，可以估计二者是几乎相等的L0 = Matrix(ZZ,[    [1,X[0]],    [0,P]])M0 = L0.LLL()W0 = M0[0]v0 = L0.solve_left(W0) L1 = Matrix(ZZ,[    [1,X[1]],    [0,P]])M1 = L1.LLL()W1 = M1[0]v1 = L1.solve_left(W1)for i in range(1,10000):    a = abs(v0[0] * v1[0]) * i    key = sha256(str(a).encode()).digest()[:16]    iv = b\"0\" * 16    AES_cipher = AES.new(key, AES.MODE_CBC, iv)    decrypted_data = unpad(AES_cipher.decrypt(ct), AES.block_size)    m0 = decrypted_data.decode()    tag = True    for m in m0:        if not m in string.printable:            tag = false            break    if tag:        print(m0)        # whuctf{You_w1ll_never_kn0w_1t!}\n\nonlyAES\n\n交互题，代码如下\nimport osimport socketimport threadingfrom Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad, unpadfrom string import ascii_lowercaseglobal flagdef xor(a, b):    if len(a) &lt; len(b):        a, b = b, a    c = []    for i in range(len(a)):        c.append(a[i] ^ b[i % len(b)])    return bytes(c)class myAES:    def __init__(self):        self.flag = flag        self.key = get_random_bytes(16)        self.cipher = AES.new(self.key, AES.MODE_ECB)    def encrypt1(self, data):        \"\"\"先异或flag，再加密\"\"\"        data = xor(data, self.flag)        pdata = pad(data, AES.block_size)        return self.cipher.encrypt(pdata).hex().encode()    def encrypt2(self, data):        \"\"\"拼接flag，将每个块的加密结果异或得到最终结果\"\"\"        data = data + self.flag        pdata = pad(data, AES.block_size)        c = self.cipher.encrypt(pdata)        C = [c[i : i + 16] for i in range(0, len(c), 16)]        for i in range(1, len(C)):            C[0] = xor(C[0], C[i])        return C[0].hex().encode()def challenge(client: socket.socket):    cipher = myAES()    client.sendall(b\"Here is an AES system, try hack it !\\n\")    client.sendall(b\"\\t1. Encrypt 1  \\n\")    client.sendall(b\"\\t2. Encrypt 2  \\n\")    while 1:        try:            client.sendall(b\"your choice &gt; \")            try:                cho = int(client.recv(1024).decode().strip())            except ValueError:                client.sendall(b\"Invalid choice!\\n\")                continue        except:            break        if cho == 1:            client.sendall(b\"Input your data(hex): \")            try:                data = bytes.fromhex(client.recv(1024).strip().decode())                if len(data) == 0:                    client.sendall(b\"No input!\\n\")                    continue                client.sendall(b\"Encrypted data(hex): \" + cipher.encrypt1(data) + b\"\\n\")            except Exception as e:                print(e)                client.sendall(b\"Invalid data!\\n\")        elif cho == 2:            client.sendall(b\"Input your data(hex): \")            try:                data = bytes.fromhex(client.recv(1024).strip().decode())                if len(data) == 0:                    client.sendall(b\"No input!\\n\")                    continue                client.sendall(b\"Encrypted data(hex): \" + cipher.encrypt2(data) + b\"\\n\")            except Exception as e:                print(e)                client.sendall(b\"Invalid data!\\n\")                continue        else:            client.sendall(b\"Invalid choice!\\n\")            continuedef main():    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    server.bind((\"0.0.0.0\", 2025))    server.listen(2)    server.settimeout(5)    try:        while True:            try:                client, addr = server.accept()                client_thread = threading.Thread(target=challenge, args=(client,))                client_thread.start()            except socket.timeout:                pass    except KeyboardInterrupt:        server.close()if __name__ == \"__main__\":    flag = os.getenv(\"GZCTF_FLAG\")    flag = flag.lstrip(\"WHUCTF{\").rstrip(\"}\")    charset = ascii_lowercase + \"_\"    assert len(flag) % 16 == 3    assert all(c in charset for c in flag)    flag = flag.encode()    main()\n可见就是选择一种加密方式，再输入data数据，进行加密，注意这里的异或方法\n对于第一种加密方式，输入全0的data块，那么实际上就是对flag进行了一次加密，不妨设flag是两个块+3个字符，那么容易有填充后得到flag0 flag1 Pad(flag2)这三个块，加密后得到encflag0 encflag1 encPad(flag2)三个块，截取前面两个\n对于第二种加密方式是先将flag拼接在输入的data后方，再16字节分块，加密之后用一个C存储各个块异或的结果，如果我们输入了Pad(flag2)，那么Pad之后会得到 Pad(flag2) flag0 flag1 Pad(flag2) 加密得到encPad(flag2) encflag0 encflag1 encPad(flag2),异或的结果就会是encflag0 XOR encflag1，然而这个我们是知道的，由第一次加密的结果，也就是说，我们穷举flag3所有的可能，一共也就27^3种，pad之后传入，只要输出的值为encflag1 XOR encflag0 那么我们就构造对了\n接下来，我们应用这里的异或性质，构造比flag长1位的0串，那么flag0的第一位会复制到flag3的末尾，这时候如法炮制爆破现在的flag3就可以了，能在27次以内搞出来，以此循环即可，稍微注意下当爆破位数超过16时候的块构造\n贴一下出题人keaton师傅的题解\ndef enc1(data: bytes) -&gt; bytes:    r.sendlineafter(b\"your choice &gt; \", b\"1\")    data = data.hex().encode()    r.sendlineafter(b\"Input your data(hex): \", data)    encdata = r.recvline_contains(b\"Encrypted data(hex): \").strip().split(b\": \")[1]    return bytes.fromhex(encdata.decode())def enc2(data: bytes) -&gt; bytes:    r.sendlineafter(b\"your choice &gt; \", b\"2\")    data = data.hex().encode()    r.sendlineafter(b\"Input your data(hex): \", data)    encdata = r.recvline_contains(b\"Encrypted data(hex): \").strip().split(b\": \")[1]    return bytes.fromhex(encdata.decode())def getTail():    \"\"\"尾部有几个字节数据的单块\"\"\"    encflag = enc1(b\"\\x00\" * flag_len)    print(\"flag密文：\", encflag.hex()) #flag各个块加密后的结果    encflag = [encflag[i : i + 16] for i in range(0, len(encflag), 16)] #密文分块    for i in product(charset[::-1], repeat=tail_len):        data = (\"\".join(i)).encode()        print(data) #穷举所有可能的flag末尾3位        pdata = pad(data, AES.block_size)        res = enc2(pdata)        if res == xor(*encflag[: len(encflag) - 1]):            print(\"尾部：\", data)            return datadef recover():    \"\"\"逐字节破解\"\"\"    flag = getTail()    mask = enc2(b\"a\" * 32) #得到encflag0 XOR encflag1 XOR encPad(flag2)    mask = xor(*[mask[i : i + 16] for i in range(0, len(mask), 16)])     for i in range(1, flag_len + 1 - tail_len):        c1 = enc1(b\"\\x00\" * (flag_len + i))        c1 = [c1[_ : _ + 16] for _ in range(0, len(c1), 16)]        for j in charset:            data = flag + j.encode()            print(data)            pdata = pad(data, AES.block_size)            res = enc2(pdata)            if xor(res, mask) == xor(*c1[(flag_len // 16) :]):                flag += j.encode()                print(flag[tail_len:] + flag[:tail_len])                break    flag = flag[tail_len:] + flag[:tail_len]    flag = \"WHUCTF{\" + flag.decode() + \"}\"    print(flag)if __name__ == \"__main__\":    tail_len = 3    flag_len = 35    recover()\n\n碎碎念第一次正式接触比赛中的密码题，和校内23 24级的其他师傅有着不小的差距，也是逐渐意识到了各类板子，思路的重要性，写复盘的初衷也是希望以后或许用得到其中的思路&amp;脚本，不过python代码能力确实还得好好练习呢，加油\n","categories":["WP"],"tags":["CTF","RSA","格密码","剪枝","AES"]},{"title":"XYCTF2025","url":"/2025/04/19/XYCTF2025/","content":"1.reedimport stringimport randomfrom secret import flagassert flag.startswith('XYCTF{') and flag.endswith('}')flag = flag.rstrip('}').lstrip('XYCTF{')table = string.ascii_letters + string.digitsassert all(i in table for i in flag)r = random.Random()class PRNG:    def __init__(self, seed):        self.a = 1145140        self.b = 19198100        random.seed(seed)    def next(self):        x = random.randint(self.a, self.b)        random.seed(x ** 2 + 1)        return x        def round(self, k):        for _ in range(k):            x = self.next()        return xdef encrypt(msg, a, b):    c = [(a * table.index(m) + b) % 19198111 for m in msg]    return cseed = int(input('give me seed: '))prng = PRNG(seed)a = prng.round(r.randrange(2**16))b = prng.round(r.randrange(2**16))enc = encrypt(flag, a, b)print(enc)\n输一个seed进去，然后影响prng的状态，再生成系数a,b,用这里的ci,p都知道，实际上没什么必要管prng的生成逻辑，可知mi的取值只有所有数字和大小写字母，也就是62个取值可能，我们找两组不一样的ci,cj有\n\nc_i\\equiv am_i+b\\;mod\\;p\\\\\nc_j\\equiv am_j+b\\;modp\\\\\n做差有(c_i-c_j)\\equiv a(m_i-m_j)\\;mod\\;p穷举所有可能的mi,mj的取值，也就3600多种，可以解出\n\na\\equiv (c_i-c_j)(m_i-m_j)^{-1}\\;mod\\;p\\\\再代入可得\n\nb\\equiv c_i-m_i(c_i-c_j)(m_i-m_j)^{-1}\\;mod\\;p\\\\这下我们就得到了a,b再对后面的所有已知的c，可得\n\nm_k\\equiv(c_k-b)a^{-1}\\;mod\\;p\\\\解出所有可能的m_k，看看是不是在0~61内，脚本如下\nimport stringtable = string.ascii_letters + string.digits  # 62 charactersmod = 19198111def extended_gcd(a, b):    if a == 0:        return (b, 0, 1)    else:        g, y, x = extended_gcd(b % a, a)        return (g, x - (b // a) * y, y)def modular_inverse(a, m):    g, x, y = extended_gcd(a, m)    if g != 1:        return None  # No inverse    else:        return x % menc = [4468502, 4468502, 15719774, 272087, 4468502, 15719774, 16429260, 8482421, 7144448, 12678836, 8928412, 15537278, 11786854, 8482421, 8036430, 11340863, 8482421, 7590439, 7590439, 11786854, 8928412, 16875251, 8036430, 981573, 12678836, 3840015, 11786854, 15091287, 7590439, 4468502, 15273783, 4468502, 15273783, 11523359, 4468502, 718078]c0 = enc[0]c2 = enc[2]solutions = []for m0 in range(len(table)):    for m2 in range(len(table)):        if m0 == m2:            continue        delta_m = m2 - m0        delta_c = (c2 - c0) % mod        inv_dm = modular_inverse(delta_m, mod)        if inv_dm is None:            continue        a = (delta_c * inv_dm) % mod        inv_a = modular_inverse(a, mod)        if inv_a is None:            continue        b = (c0 - a * m0) % mod        valid = True        plain = []        for c in enc:            m = ((c - b) * inv_a) % mod            if m &lt; 0 or m &gt;= len(table):                valid = False                break            plain.append(table[m])        if valid:            solutions.append((a, b, ''.join(plain)))if solutions:    print(\"Possible solutions:\")    for a, b, plain in solutions:        print(f\"a = {a}, b = {b}\")        print(f\"Flag: XYCTF{{{plain}}}\\n\")else:    print(\"No valid solutions found.\")#Possible solutions:#a = 3750424, b = 16875251#Flag: XYCTF{114514fixedpointissodangerous1919810}\n不过这貌似是出题人的非预期解，等有师傅分享了关于PRNG不动点的解法的话再补充吧\n2.Complex-signinfrom Crypto.Util.number import *from Crypto.Cipher import ChaCha20import hashlibfrom secret import flag# 复数class Complex:    def __init__(self, re, im):        self.re = re        self.im = im    def __mul__(self, c):        re_ = self.re * c.re - self.im * c.im        im_ = self.re * c.im + self.im * c.re        return Complex(re_, im_)    def __eq__(self, c):        return self.re == c.re and self.im == c.im    def __rshift__(self, m):        return Complex(self.re &gt;&gt; m, self.im &gt;&gt; m)    def __lshift__(self, m):        return Complex(self.re &lt;&lt; m, self.im &lt;&lt; m)    def __str__(self):        if self.im == 0:            return str(self.re)        elif self.re == 0:            if abs(self.im) == 1:                return f\"{'-' if self.im &lt; 0 else ''}i\"            else:                return f\"{self.im}i\"        else:            return f\"{self.re} {'+' if self.im &gt; 0 else '-'} {abs(self.im)}i\"    def tolist(self):        return [self.re, self.im]# 快速幂def complex_pow(c, exp, n):    result = Complex(1, 0)    while exp &gt; 0:        if exp &amp; 1:            result = result * c            result.re = result.re % n            result.im = result.im % n        c = c * c        c.re = c.re % n        c.im = c.im % n        exp &gt;&gt;= 1    return resultbits = 128p = getPrime(1024)q = getPrime(1024)n = p * qm = Complex(getRandomRange(1, n), getRandomRange(1, n))e = 3c = complex_pow(m, e, n)print(f\"n = {n}\")print(f\"mh = {(m &gt;&gt; bits &lt;&lt; bits).tolist()}\")print(f\"C = {c.tolist()}\")print(f\"enc = {ChaCha20.new(key=hashlib.sha256(str(m.re + m.im).encode()).digest(), nonce=b'Pr3d1ctmyxjj').encrypt(flag)}\")'''n = 24240993137357567658677097076762157882987659874601064738608971893024559525024581362454897599976003248892339463673241756118600994494150721789525924054960470762499808771760690211841936903839232109208099640507210141111314563007924046946402216384360405445595854947145800754365717704762310092558089455516189533635318084532202438477871458797287721022389909953190113597425964395222426700352859740293834121123138183367554858896124509695602915312917886769066254219381427385100688110915129283949340133524365403188753735534290512113201932620106585043122707355381551006014647469884010069878477179147719913280272028376706421104753mh = [3960604425233637243960750976884707892473356737965752732899783806146911898367312949419828751012380013933993271701949681295313483782313836179989146607655230162315784541236731368582965456428944524621026385297377746108440938677401125816586119588080150103855075450874206012903009942468340296995700270449643148025957527925452034647677446705198250167222150181312718642480834399766134519333316989347221448685711220842032010517045985044813674426104295710015607450682205211098779229647334749706043180512861889295899050427257721209370423421046811102682648967375219936664246584194224745761842962418864084904820764122207293014016, 15053801146135239412812153100772352976861411085516247673065559201085791622602365389885455357620354025972053252939439247746724492130435830816513505615952791448705492885525709421224584364037704802923497222819113629874137050874966691886390837364018702981146413066712287361010611405028353728676772998972695270707666289161746024725705731676511793934556785324668045957177856807914741189938780850108643929261692799397326838812262009873072175627051209104209229233754715491428364039564130435227582042666464866336424773552304555244949976525797616679252470574006820212465924134763386213550360175810288209936288398862565142167552]C = [5300743174999795329371527870190100703154639960450575575101738225528814331152637733729613419201898994386548816504858409726318742419169717222702404409496156167283354163362729304279553214510160589336672463972767842604886866159600567533436626931810981418193227593758688610512556391129176234307448758534506432755113432411099690991453452199653214054901093242337700880661006486138424743085527911347931571730473582051987520447237586885119205422668971876488684708196255266536680083835972668749902212285032756286424244284136941767752754078598830317271949981378674176685159516777247305970365843616105513456452993199192823148760, 21112179095014976702043514329117175747825140730885731533311755299178008997398851800028751416090265195760178867626233456642594578588007570838933135396672730765007160135908314028300141127837769297682479678972455077606519053977383739500664851033908924293990399261838079993207621314584108891814038236135637105408310569002463379136544773406496600396931819980400197333039720344346032547489037834427091233045574086625061748398991041014394602237400713218611015436866842699640680804906008370869021545517947588322083793581852529192500912579560094015867120212711242523672548392160514345774299568940390940653232489808850407256752]enc = b'\\x9c\\xc4n\\x8dF\\xd9\\x9e\\xf4\\x05\\x82!\\xde\\xfe\\x012$\\xd0\\x8c\\xaf\\xfb\\rEb(\\x04)\\xa1\\xa6\\xbaI2J\\xd2\\xb2\\x898\\x11\\xe6x\\xa9\\x19\\x00pn\\xf6rs- \\xd2\\xd1\\xbe\\xc7\\xf51.\\xd4\\xd2 \\xe7\\xc6\\xca\\xe5\\x19\\xbe''''\n基于二元复数的RSA运算，题目给出了m实、虚部的高位，同时e的数值为3，可以考虑设低位，展开成多项式，去打二元coppersmith，推导如下\n\nRe_{m}=mh[0]+x\\;;Im_m=mh[1]+y\\\\\n又C\\equiv(mh[0]+x+(mh[1]+y)i)^3\\;mod\\;n\\\\\n整理得到\\\\\nRe_C\\equiv (mh[0]+x)^3-3(mh[0]+x)(mh[1]+y)^2\\;mod\\;n\\\\\nIm_C\\equiv-(mh[1]+y)^3+3(mh[0]+x)^2(mh[1]+y)\\;mod\\;n\\\\只有x,y未知，这里给一个二元copper的脚本，感谢(defund/coppersmith: Coppersmith’s method for multivariate polynomials (github.com))和使用轮子的exp\n#sageimport itertoolsdef small_roots(f, bounds, m=1, d=None):\tif not d:\t\td = f.degree()\tif isinstance(f, Polynomial):\t\tx, = polygens(f.base_ring(), f.variable_name(), 1)\t\tf = f(x)\tR = f.base_ring()\tN = R.cardinality()\t\tf /= f.coefficients().pop(0)\tf = f.change_ring(ZZ)\tG = Sequence([], f.parent())\tfor i in range(m+1):\t\tbase = N^(m-i) * f^i\t\tfor shifts in itertools.product(range(d), repeat=f.nvariables()):\t\t\tg = base * prod(map(power, f.variables(), shifts))\t\t\tG.append(g)\tB, monomials = G.coefficient_matrix()\tmonomials = vector(monomials)\tfactors = [monomial(*bounds) for monomial in monomials]\tfor i, factor in enumerate(factors):\t\tB.rescale_col(i, factor)\tB = B.dense_matrix().LLL()\tB = B.change_ring(QQ)\tfor i, factor in enumerate(factors):\t\tB.rescale_col(i, 1/factor)\tH = Sequence([], f.parent().change_ring(QQ))\tfor h in filter(None, B*monomials):\t\tH.append(h)\t\tI = H.ideal()\t\tif I.dimension() == -1:\t\t\tH.pop()\t\telif I.dimension() == 0:\t\t\troots = []\t\t\tfor root in I.variety(ring=ZZ):\t\t\t\troot = tuple(R(root[var]) for var in f.variables())\t\t\t\troots.append(root)\t\t\treturn roots\treturn []\nexp\nfrom sage.all import *import itertools# from coppersmith import small_rootsfrom Crypto.Cipher import ChaCha20from hashlib import sha256def small_roots(f, bounds, m=1, d=None):    if not d:        d = f.degree()    R = f.base_ring()    N = R.cardinality() #取得模数    f /= f.coefficients().pop(0) #最高次项系数化为0，coefficients是多项式的降次幂排列系数    f = f.change_ring(ZZ)    G = Sequence([], f.parent())    for i in range(m + 1):        base = N ** (m - i) * f ** i #收集基多项式        for shifts in itertools.product(range(d), repeat=f.nvariables()):            g = base * prod(map(power, f.variables(), shifts))            G.append(g)    # print(G)    B, monomials = G.coefficient_matrix()    monomials = vector(monomials)    factors = [monomial(*bounds) for monomial in monomials]    for i, factor in enumerate(factors):        B.rescale_col(i, factor)    B = B.dense_matrix().LLL()    B = B.change_ring(QQ)    for i, factor in enumerate(factors):        B.rescale_col(i, 1 / factor)    H = Sequence([], f.parent().change_ring(QQ))    for h in filter(None, B * monomials):        H.append(h)        I = H.ideal()        if I.dimension() == -1:            H.pop()        elif I.dimension() == 0:            roots = []            for root in I.variety(ring=ZZ):                root = tuple(R(root[var]) for var in f.variables())                roots.append(root)            return roots    return []n = 24240993137357567658677097076762157882987659874601064738608971893024559525024581362454897599976003248892339463673241756118600994494150721789525924054960470762499808771760690211841936903839232109208099640507210141111314563007924046946402216384360405445595854947145800754365717704762310092558089455516189533635318084532202438477871458797287721022389909953190113597425964395222426700352859740293834121123138183367554858896124509695602915312917886769066254219381427385100688110915129283949340133524365403188753735534290512113201932620106585043122707355381551006014647469884010069878477179147719913280272028376706421104753mh = [3960604425233637243960750976884707892473356737965752732899783806146911898367312949419828751012380013933993271701949681295313483782313836179989146607655230162315784541236731368582965456428944524621026385297377746108440938677401125816586119588080150103855075450874206012903009942468340296995700270449643148025957527925452034647677446705198250167222150181312718642480834399766134519333316989347221448685711220842032010517045985044813674426104295710015607450682205211098779229647334749706043180512861889295899050427257721209370423421046811102682648967375219936664246584194224745761842962418864084904820764122207293014016, 15053801146135239412812153100772352976861411085516247673065559201085791622602365389885455357620354025972053252939439247746724492130435830816513505615952791448705492885525709421224584364037704802923497222819113629874137050874966691886390837364018702981146413066712287361010611405028353728676772998972695270707666289161746024725705731676511793934556785324668045957177856807914741189938780850108643929261692799397326838812262009873072175627051209104209229233754715491428364039564130435227582042666464866336424773552304555244949976525797616679252470574006820212465924134763386213550360175810288209936288398862565142167552]C = [5300743174999795329371527870190100703154639960450575575101738225528814331152637733729613419201898994386548816504858409726318742419169717222702404409496156167283354163362729304279553214510160589336672463972767842604886866159600567533436626931810981418193227593758688610512556391129176234307448758534506432755113432411099690991453452199653214054901093242337700880661006486138424743085527911347931571730473582051987520447237586885119205422668971876488684708196255266536680083835972668749902212285032756286424244284136941767752754078598830317271949981378674176685159516777247305970365843616105513456452993199192823148760, 21112179095014976702043514329117175747825140730885731533311755299178008997398851800028751416090265195760178867626233456642594578588007570838933135396672730765007160135908314028300141127837769297682479678972455077606519053977383739500664851033908924293990399261838079993207621314584108891814038236135637105408310569002463379136544773406496600396931819980400197333039720344346032547489037834427091233045574086625061748398991041014394602237400713218611015436866842699640680804906008370869021545517947588322083793581852529192500912579560094015867120212711242523672548392160514345774299568940390940653232489808850407256752]R = PolynomialRing(Zmod(n), names=('x', 'y'))x, y = R.gens()f = (mh[0] + x)**3 - 3 * (mh[0] + x) * ((mh[1] + y)**2) - C[0]g = (mh[1] + y)**3 - 3 * (mh[0] + x)**2 * (mh[1] + y) + C[1]roots = small_roots(f, bounds=(2**129,2**129))enc = b'\\x9c\\xc4n\\x8dF\\xd9\\x9e\\xf4\\x05\\x82!\\xde\\xfe\\x012$\\xd0\\x8c\\xaf\\xfb\\rEb(\\x04)\\xa1\\xa6\\xbaI2J\\xd2\\xb2\\x898\\x11\\xe6x\\xa9\\x19\\x00pn\\xf6rs- \\xd2\\xd1\\xbe\\xc7\\xf51.\\xd4\\xd2 \\xe7\\xc6\\xca\\xe5\\x19\\xbe'sum = mh[0]+mh[1]+roots[0][0]+roots[0][1]key = sha256(str(sum).encode()).digest()cipher = ChaCha20.new(key=key, nonce=b'Pr3d1ctmyxjj')flag = cipher.decrypt(enc)print(\"Recovered flag:\", flag.decode(errors='ignore'))  #XYCTF{Welcome_to_XYCTF_Now_let_us_together_play_Crypto_challenge}\n3.division题目给了容器的server\n#server.py# -*- encoding: utf-8 -*-'''@File    :   server.py@Time    :   2025/03/20 12:25:03@Author  :   LamentXU '''import random print('----Welcome to my division calc----')print('''menu:      [1]  Division calc      [2]  Get flag''')while True:    choose = input(': &gt;&gt;&gt; ')    if choose == '1':        try:            denominator = int(input('input the denominator: &gt;&gt;&gt; '))        except:            print('INPUT NUMBERS')            continue        nominator = random.getrandbits(32)        if denominator == '0':            print('NO YOU DONT')            continue        else:            print(f'{nominator}//{denominator} = {nominator//denominator}')    elif choose == '2':        try:            ans = input('input the answer: &gt;&gt;&gt; ')            rand1 = random.getrandbits(11000)            rand2 = random.getrandbits(10000)            correct_ans = rand1 // rand2            if correct_ans == int(ans):                print('WOW')                with open('flag', 'r') as f:                    print(f'Here is your flag: {f.read()}')            else:                print(f'NOPE, the correct answer is {correct_ans}')        except:            print('INPUT NUMBERS')    else:        print('Invalid choice')\n考点主要是python的PRFrandom 其中使用的是MT19937算法，在输出比特超过624*32位时就能被预测，参考blogs([CTF/randcrack]python随机数预测模块分析及改进方案_random.getrandbits(32)-CSDN博客)\n博客师傅给了个很好用的轮子，思路也很清楚，选择1，输入1，就能获得这次生成的随机数，那么输624次，再选择2，输入预测的值就Ok了，直接上exp\nimport socketimport reimport timeimport random from randcrack import RandCrack #下载randcrack库后导入类# 配置服务器地址和端口host = 'gz.imxbt.cn'  # 替换成目标服务器的 IP 地址port = 20522         # 替换成目标服务器的端口号rc = RandCrack()res = ''def exploit(host, port):    # Connect to the target    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host, port))            for i in range (625):        s.send(b'1\\n')        time.sleep(0.05)        s.send(b'1\\n')        time.sleep(0.05)        response = s.recv(40000).decode('utf-8')    print(response)    numbers = re.findall(r'(\\d{2,})', response)    # 使用列表推导式保持顺序并去重    filtered_numbers = []    seen = set()    for num in numbers:        if num != '1' and num not in seen:            filtered_numbers.append(num)            seen.add(num)    print(len(filtered_numbers))    print(filtered_numbers)    for nums in filtered_numbers:        rc.submit(int(nums))#每次循环提交一个32位random生成的随机数    s.send(b'2\\n')    time.sleep(0.5)    d=rc.predict_getrandbits(32)    a=rc.predict_getrandbits(11000)    b=rc.predict_getrandbits(10000)    c=a//b    print(c)    s.send(f\"{c}\\n\".encode())    time.sleep(0.5)      response = s.recv(2048).decode('utf-8')    print(f\"{response}\")   if __name__ == \"__main__\":    exploit(host, port)# flag{I_do_not_want_any_CTFER_get_0_solve_in_Crypto_bad_bad_adwa}\n4.choice这道也是考察的MT19937的内容，题干\nfrom Crypto.Util.number import bytes_to_longfrom random import Randomfrom secret import flagassert flag.startswith(b'XYCTF{') and flag.endswith(b'}')flag = flag[6:-1]msg = bytes_to_long(flag)rand = Random()test = bytes([i for i in range(255, -1, -1)]) #256个字符 asciiprint(test)open('output.py', 'w').write(f'enc = {msg ^ rand.getrandbits(msg.bit_length())}\\nr = {[rand.choice(test) for _ in range(2496)]}')    # 先getrandbits的用了一次# 再存在choice test 即选择的部分\n不过这里是生成了2496个8bit的数字，可知24968 = 624 32 bit数是够用的，沿用上面博客师傅的轮子，就可以破解伪随机生成器，但是这里flag的长度未知，爆破就行了，exp如下\nfrom pyrandcracker import RandCrackerfrom Crypto.Util.number import *rc = RandCracker(detail = True)r = [224, 55, 218, 253, 150, 84, 208, 134, 18, 177, 244, 54, 122, 193, 249, 5, 121, 80, 230, 21, 236, 33, 226, 3, 120, 141, 212, 33, 69, 195, 78, 112, 0, 62, 64, 197, 10, 224, 64, 191, 17, 112, 196, 143, 209, 92, 10, 198, 174, 181, 96, 118, 175, 145, 111, 41, 113, 206, 137, 37, 56, 227, 252, 84, 18, 145, 81, 124, 202, 14, 255, 144, 200, 13, 230, 218, 208, 210, 222, 101, 211, 114, 222, 12, 190, 226, 62, 118, 87, 152, 118, 245, 196, 4, 92, 251, 238, 142, 114, 13, 113, 247, 171, 8, 138, 20, 169, 192, 221, 223, 60, 56, 188, 70, 184, 202, 195, 246, 71, 235, 152, 255, 73, 128, 140, 159, 119, 79, 1, 223, 239, 242, 60, 228, 205, 90, 210, 5, 165, 35, 176, 75, 21, 182, 220, 212, 240, 212, 77, 124, 52, 140, 85, 200, 207, 31, 177, 82, 76, 152, 128, 124, 205, 216, 252, 34, 27, 198, 186, 61, 161, 192, 158, 226, 40, 127, 69, 162, 24, 46, 208, 183, 99, 165, 1, 221, 184, 40, 147, 136, 236, 245, 228, 197, 86, 15, 201, 95, 115, 18, 131, 79, 86, 12, 122, 63, 200, 192, 244, 205, 229, 36, 86, 217, 249, 170, 5, 134, 99, 33, 214, 10, 120, 105, 233, 115, 230, 114, 105, 84, 39, 167, 18, 10, 77, 236, 104, 225, 196, 181, 105, 180, 159, 24, 4, 147, 131, 143, 64, 201, 212, 175, 203, 200, 19, 99, 24, 112, 180, 75, 222, 204, 204, 13, 210, 165, 135, 175, 132, 205, 247, 28, 178, 76, 240, 196, 240, 121, 132, 21, 8, 45, 203, 143, 206, 6, 11, 51, 47, 87, 88, 35, 63, 168, 251, 11, 254, 11, 46, 72, 210, 230, 184, 114, 88, 194, 99, 229, 144, 1, 226, 44, 133, 10, 42, 234, 112, 100, 248, 247, 66, 221, 72, 229, 236, 4, 65, 203, 65, 61, 23, 181, 190, 87, 1, 76, 113, 48, 178, 42, 175, 49, 78, 159, 104, 229, 213, 223, 13, 249, 216, 60, 144, 203, 156, 23, 129, 148, 87, 37, 79, 227, 141, 202, 210, 245, 236, 121, 129, 78, 7, 121, 42, 82, 184, 222, 96, 100, 189, 62, 102, 176, 198, 1, 153, 242, 23, 191, 197, 176, 115, 206, 122, 50, 104, 70, 170, 29, 52, 189, 157, 99, 82, 187, 201, 78, 25, 75, 126, 118, 160, 250, 53, 112, 143, 161, 251, 221, 44, 255, 232, 115, 182, 77, 31, 217, 228, 97, 112, 236, 21, 160, 127, 9, 220, 22, 97, 159, 239, 25, 140, 206, 210, 148, 105, 184, 41, 56, 92, 141, 3, 200, 165, 14, 161, 219, 177, 40, 189, 75, 48, 146, 130, 151, 100, 144, 239, 22, 19, 246, 166, 231, 228, 68, 254, 16, 99, 95, 32, 177, 216, 170, 125, 211, 100, 142, 251, 16, 64, 83, 161, 184, 242, 248, 239, 141, 171, 135, 48, 20, 34, 250, 13, 70, 236, 172, 22, 241, 171, 25, 18, 204, 36, 248, 253, 203, 138, 10, 130, 249, 15, 157, 244, 154, 41, 4, 231, 64, 20, 212, 126, 160, 48, 154, 171, 250, 199, 113, 32, 186, 126, 217, 3, 236, 115, 37, 174, 75, 222, 125, 55, 86, 65, 96, 56, 254, 226, 213, 244, 36, 199, 164, 160, 126, 191, 29, 50, 135, 234, 165, 122, 132, 68, 133, 129, 0, 220, 72, 87, 172, 93, 15, 131, 37, 119, 240, 43, 239, 105, 45, 244, 6, 34, 111, 151, 144, 54, 46, 159, 6, 5, 160, 32, 4, 180, 246, 39, 220, 85, 209, 145, 41, 88, 137, 110, 101, 113, 115, 204, 11, 53, 152, 177, 240, 193, 220, 136, 84, 221, 12, 43, 74, 122, 251, 236, 53, 175, 36, 46, 246, 181, 137, 246, 53, 189, 171, 240, 104, 8, 126, 56, 122, 245, 155, 130, 31, 16, 20, 212, 147, 33, 165, 82, 117, 244, 167, 235, 115, 244, 94, 173, 195, 34, 36, 33, 218, 39, 13, 90, 196, 172, 207, 105, 73, 255, 187, 221, 162, 242, 186, 122, 140, 241, 120, 98, 44, 81, 172, 201, 150, 238, 111, 147, 24, 214, 192, 125, 102, 157, 53, 219, 172, 123, 218, 222, 71, 138, 117, 188, 32, 104, 10, 188, 118, 58, 254, 36, 104, 212, 76, 209, 15, 6, 33, 149, 15, 225, 76, 8, 157, 48, 70, 127, 19, 126, 77, 216, 133, 132, 30, 33, 113, 117, 134, 238, 57, 20, 121, 26, 184, 229, 202, 90, 28, 42, 230, 42, 159, 19, 191, 162, 205, 241, 67, 177, 216, 191, 164, 146, 90, 228, 232, 149, 163, 135, 130, 193, 196, 178, 215, 216, 155, 238, 20, 36, 196, 153, 207, 177, 149, 40, 172, 139, 12, 134, 142, 154, 225, 179, 95, 248, 190, 8, 154, 246, 229, 102, 121, 197, 116, 135, 163, 128, 109, 112, 114, 143, 164, 134, 233, 45, 244, 22, 141, 211, 214, 122, 14, 93, 49, 251, 85, 95, 95, 191, 210, 245, 181, 142, 125, 110, 33, 195, 150, 197, 173, 86, 50, 127, 187, 129, 67, 119, 58, 134, 119, 36, 151, 136, 122, 157, 22, 171, 195, 48, 178, 232, 228, 177, 6, 124, 50, 163, 161, 32, 49, 197, 157, 188, 86, 208, 226, 208, 63, 173, 21, 192, 148, 194, 208, 251, 95, 117, 34, 116, 217, 130, 150, 97, 206, 101, 201, 88, 137, 163, 90, 104, 129, 4, 191, 99, 50, 115, 8, 145, 116, 250, 180, 193, 229, 128, 92, 55, 26, 6, 154, 68, 0, 66, 77, 126, 192, 170, 218, 252, 127, 192, 29, 107, 152, 231, 190, 202, 130, 116, 229, 193, 63, 13, 48, 220, 238, 126, 74, 232, 19, 242, 71, 159, 9, 196, 187, 111, 243, 81, 244, 193, 95, 166, 85, 22, 240, 32, 1, 114, 11, 64, 114, 149, 217, 207, 194, 1, 33, 245, 14, 101, 119, 32, 233, 214, 139, 71, 103, 125, 54, 17, 86, 140, 132, 221, 45, 227, 136, 203, 156, 223, 73, 43, 82, 190, 119, 22, 14, 115, 0, 192, 105, 147, 210, 146, 47, 89, 210, 18, 225, 126, 210, 240, 55, 219, 247, 106, 190, 50, 35, 13, 255, 236, 253, 82, 244, 117, 139, 1, 72, 182, 19, 170, 173, 59, 175, 10, 95, 66, 253, 178, 139, 45, 5, 24, 59, 9, 222, 58, 46, 79, 48, 39, 175, 196, 249, 249, 70, 126, 118, 69, 165, 155, 119, 67, 221, 20, 133, 16, 99, 41, 132, 11, 12, 35, 70, 87, 43, 197, 103, 33, 201, 3, 195, 142, 128, 135, 121, 26, 185, 2, 73, 235, 70, 219, 49, 227, 133, 241, 34, 6, 9, 109, 66, 50, 177, 114, 119, 101, 91, 144, 41, 246, 40, 81, 113, 203, 226, 87, 8, 0, 73, 212, 5, 95, 112, 230, 4, 28, 206, 93, 252, 30, 195, 197, 226, 165, 120, 3, 124, 169, 66, 227, 113, 55, 101, 135, 141, 71, 84, 202, 19, 145, 25, 92, 50, 80, 53, 63, 85, 184, 196, 93, 254, 47, 252, 182, 150, 115, 20, 181, 178, 87, 162, 50, 190, 228, 125, 240, 134, 10, 142, 173, 206, 250, 49, 186, 201, 118, 146, 246, 244, 199, 9, 55, 253, 123, 103, 200, 206, 79, 168, 216, 99, 192, 191, 236, 214, 248, 111, 115, 74, 155, 165, 150, 40, 86, 224, 240, 133, 69, 34, 52, 13, 63, 61, 116, 182, 144, 177, 101, 164, 77, 217, 65, 218, 150, 142, 249, 165, 160, 220, 120, 25, 36, 157, 134, 223, 11, 46, 121, 75, 182, 126, 104, 91, 204, 45, 49, 175, 10, 48, 83, 150, 96, 244, 10, 149, 76, 124, 189, 149, 200, 252, 175, 124, 146, 126, 230, 70, 194, 243, 63, 204, 224, 115, 140, 115, 110, 86, 22, 193, 5, 11, 18, 177, 159, 94, 160, 38, 188, 139, 89, 1, 200, 163, 138, 8, 140, 169, 54, 29, 225, 22, 5, 99, 144, 247, 239, 106, 77, 29, 141, 206, 89, 236, 4, 32, 104, 115, 206, 204, 15, 100, 66, 199, 15, 89, 24, 246, 99, 224, 207, 7, 205, 142, 203, 28, 87, 16, 110, 93, 72, 73, 206, 48, 59, 170, 152, 224, 2, 74, 9, 125, 140, 82, 206, 159, 0, 117, 237, 252, 47, 200, 75, 133, 68, 239, 109, 169, 25, 168, 202, 240, 5, 67, 125, 173, 233, 6, 148, 38, 182, 13, 141, 149, 39, 119, 189, 122, 49, 173, 153, 78, 103, 211, 65, 224, 52, 10, 35, 233, 88, 66, 43, 120, 255, 71, 169, 215, 250, 218, 205, 163, 164, 226, 46, 178, 25, 88, 59, 98, 199, 167, 134, 244, 167, 210, 20, 246, 159, 163, 252, 114, 5, 168, 52, 47, 177, 159, 255, 236, 166, 49, 36, 61, 10, 130, 135, 220, 101, 202, 69, 150, 100, 217, 98, 203, 217, 166, 33, 169, 203, 230, 194, 224, 15, 249, 205, 52, 41, 124, 191, 223, 148, 251, 147, 133, 85, 149, 214, 198, 5, 134, 91, 201, 191, 204, 152, 240, 37, 34, 236, 211, 182, 142, 207, 1, 188, 67, 87, 222, 220, 7, 78, 49, 129, 236, 98, 120, 217, 204, 77, 106, 89, 250, 182, 15, 18, 27, 143, 13, 27, 61, 223, 213, 196, 190, 24, 35, 104, 100, 220, 60, 194, 174, 169, 20, 167, 75, 162, 26, 253, 213, 59, 219, 187, 253, 160, 249, 61, 122, 113, 223, 55, 57, 198, 53, 138, 94, 154, 18, 132, 233, 183, 71, 7, 22, 50, 196, 181, 202, 103, 86, 31, 119, 83, 130, 165, 242, 170, 31, 35, 175, 117, 95, 89, 247, 221, 186, 47, 236, 241, 77, 194, 111, 148, 45, 101, 88, 41, 0, 33, 139, 15, 127, 156, 72, 234, 217, 170, 218, 216, 31, 4, 73, 150, 78, 49, 178, 13, 178, 46, 102, 93, 184, 110, 205, 132, 190, 43, 87, 194, 35, 188, 166, 9, 97, 184, 202, 113, 45, 150, 62, 106, 108, 19, 162, 85, 212, 188, 131, 38, 67, 23, 136, 208, 87, 63, 69, 6, 209, 242, 45, 13, 228, 14, 233, 8, 71, 43, 51, 89, 46, 195, 101, 132, 254, 154, 183, 220, 115, 221, 255, 174, 150, 65, 141, 176, 57, 144, 16, 115, 252, 144, 139, 52, 205, 224, 75, 190, 192, 2, 231, 30, 238, 149, 22, 200, 137, 244, 239, 185, 212, 145, 230, 200, 8, 249, 109, 26, 226, 195, 133, 140, 103, 50, 230, 180, 47, 196, 226, 105, 13, 239, 135, 20, 214, 152, 211, 208, 81, 213, 48, 187, 232, 77, 139, 16, 79, 204, 216, 56, 41, 41, 58, 192, 245, 1, 104, 85, 42, 107, 94, 142, 12, 247, 90, 254, 116, 72, 193, 219, 54, 247, 5, 28, 60, 140, 10, 185, 86, 148, 101, 198, 96, 181, 245, 61, 25, 186, 29, 57, 176, 188, 9, 239, 93, 198, 110, 248, 23, 87, 193, 161, 107, 40, 38, 186, 205, 148, 197, 127, 144, 69, 19, 47, 132, 82, 23, 170, 83, 224, 235, 49, 190, 44, 145, 65, 66, 141, 78, 1, 254, 24, 157, 7, 23, 227, 28, 81, 176, 22, 92, 139, 188, 48, 183, 229, 139, 205, 174, 131, 189, 241, 21, 146, 204, 58, 249, 167, 217, 174, 43, 41, 56, 181, 212, 42, 188, 6, 117, 93, 178, 160, 129, 15, 76, 150, 207, 245, 227, 247, 130, 171, 114, 204, 101, 176, 55, 43, 138, 149, 90, 124, 45, 96, 181, 221, 16, 121, 210, 51, 210, 164, 68, 64, 154, 167, 91, 69, 35, 153, 212, 10, 125, 235, 203, 166, 145, 9, 174, 86, 65, 70, 112, 194, 140, 92, 170, 49, 191, 157, 218, 199, 152, 151, 247, 208, 182, 209, 34, 245, 5, 173, 105, 175, 159, 71, 251, 198, 246, 214, 99, 58, 70, 154, 52, 39, 88, 149, 179, 202, 86, 240, 108, 200, 83, 250, 62, 213, 113, 138, 73, 106, 141, 192, 204, 90, 251, 208, 28, 124, 30, 134, 119, 144, 68, 23, 204, 181, 186, 76, 156, 71, 8, 104, 186, 87, 221, 134, 122, 72, 244, 203, 121, 181, 65, 90, 185, 131, 230, 133, 54, 158, 186, 168, 201, 178, 155, 172, 164, 22, 130, 111, 90, 209, 2, 167, 23, 176, 63, 139, 89, 63, 15, 238, 110, 204, 85, 36, 127, 68, 240, 177, 31, 2, 81, 147, 205, 192, 214, 173, 103, 130, 10, 100, 232, 125, 216, 163, 209, 171, 168, 243, 145, 6, 170, 41, 142, 250, 145, 57, 139, 224, 221, 189, 48, 141, 232, 146, 92, 216, 154, 126, 223, 8, 90, 82, 138, 221, 240, 223, 87, 209, 165, 17, 52, 154, 91, 12, 121, 212, 238, 46, 215, 217, 147, 136, 139, 251, 91, 39, 188, 244, 251, 52, 110, 22, 126, 200, 231, 153, 103, 203, 120, 219, 118, 172, 53, 141, 203, 75, 163, 150, 194, 27, 208, 9, 186, 6, 85, 46, 243, 135, 66, 40, 79, 206, 250, 20, 85, 123, 35, 164, 44, 85, 104, 66, 51, 177, 125, 189, 165, 226, 13, 75, 78, 225, 252, 226, 138, 81, 171, 172, 175, 122, 145, 68, 254, 37, 153, 39, 113, 237, 232, 220, 80, 193, 181, 21, 197, 186, 56, 202, 239, 213, 135, 41, 6, 85, 54, 135, 214, 95, 102, 23, 192, 153, 235, 110, 26, 14, 84, 220, 142, 236, 192, 8, 117, 205, 249, 92, 148, 149, 77, 235, 205, 232, 21, 48, 14, 84, 187, 124, 218, 166, 155, 183, 62, 10, 123, 53, 63, 79, 101, 193, 3, 61, 29, 39, 99, 22, 197, 75, 10, 165, 44, 215, 210, 181, 74, 235, 200, 247, 158, 187, 200, 102, 22, 150, 73, 42, 131, 28, 17, 180, 133, 205, 23, 228, 226, 219, 175, 207, 81, 53, 141, 114, 140, 59, 218, 169, 7, 219, 139, 75, 210, 97, 236, 157, 21, 109, 195, 128, 54, 5, 55, 217, 127, 49, 62, 59, 101, 95, 86, 255, 22, 186, 94, 151, 114, 93, 19, 198, 159, 174, 142, 132, 195, 157, 206, 161, 107, 255, 106, 196, 250, 191, 86, 221, 196, 36, 29, 37, 50, 224, 42, 20, 89, 212, 252, 191, 157, 237, 10, 157, 80, 42, 234, 180, 1, 183, 186, 239, 129, 14, 125, 114, 66, 203, 120, 114, 37, 214, 37, 73, 153, 182, 165, 87, 177, 75, 220, 210, 105, 154, 149, 114, 13, 202, 128, 55, 128, 96, 158, 150, 57, 86, 106, 127, 160, 57, 80, 255, 107, 241, 95, 121, 14, 110, 160, 119, 211, 150, 156, 185, 158, 221, 110, 76, 255, 119, 15, 245, 1, 238, 139, 100, 250, 220, 147, 193, 51, 144, 123, 139, 13, 26, 158, 95, 148, 251, 82, 227, 119, 92, 132, 219, 248, 239, 217, 101, 88, 121, 10, 148, 203, 156, 156]enc = 5042764371819053176884777909105310461303359296255297for i in r:    rc.submit(255-i,8)rc.check(offset = True)# 爆破长度为i即可for i in range(150,200):    rc.offset_bits(-i)    data = rc.rnd.getrandbits(i)    print(long_to_bytes(data^enc))#稍微要跑一会#b'___0h_51mple_r@nd0m___'\n5.*复复复复数class ComComplex:    def __init__(self, value=[0,0,0,0]):        self.value = value    def __str__(self):        s = str(self.value[0])        for k,i in enumerate(self.value[1:]):            if i &gt;= 0:                s += '+'            s += str(i) +'ijk'[k]        return s    def __add__(self,x):        return ComComplex([i+j for i,j in zip(self.value,x.value)])    def __mul__(self,x):        a = self.value[0]*x.value[0]-self.value[1]*x.value[1]-self.value[2]*x.value[2]-self.value[3]*x.value[3]        b = self.value[0]*x.value[1]+self.value[1]*x.value[0]+self.value[2]*x.value[3]-self.value[3]*x.value[2]        c = self.value[0]*x.value[2]-self.value[1]*x.value[3]+self.value[2]*x.value[0]+self.value[3]*x.value[1]        d = self.value[0]*x.value[3]+self.value[1]*x.value[2]-self.value[2]*x.value[1]+self.value[3]*x.value[0]        return ComComplex([a,b,c,d])    def __mod__(self,x):        return ComComplex([i % x for i in self.value])    def __pow__(self, x, n=None):        tmp = ComComplex(self.value)        a = ComComplex([1,0,0,0])        while x:            if x &amp; 1:                a *= tmp            tmp *= tmp            if n:                a %= n                tmp %= n            x &gt;&gt;= 1        return afrom Crypto.Util.number import *from secret import flag, hintp = getPrime(256)q = getPrime(256)r = getPrime(256)n = p * q * rP = getPrime(512)assert len(hint) == 20hints = ComComplex([bytes_to_long(hint[i:i+5]) for i in range(0,20,5)])keys = ComComplex([0, p, q, r])print('hint =',hints)print('gift =',hints*keys%P)print('P =',P)e = 65547m = ComComplex([bytes_to_long(flag[i:i+len(flag)//4+1]) for i in range(0,len(flag),len(flag)//4+1)])c = pow(m, e, n)print('n =', n)print('c =', c)'''hint = 375413371936+452903063925i+418564633198j+452841062207kgift = 8123312244520119413231609191866976836916616973013918670932199631084038015924368317077919454611785179950870055560079987034735836668109705445946887481003729+20508867471664499348708768798854433383217801696267611753941328714877299161068885700412171i+22802458968832151777449744120185122420871929971817937643641589637402679927558503881707868j+40224499597522456323122179021760594618350780974297095023316834212332206526399536884102863kP = 8123312244520119413231609191866976836916616973013918670932199631182724263362174895104545305364960781233690810077210539091362134310623408173268475389315109n = 408713495380933615345467409596399184629824932933932227692519320046890365817329617301604051766392980053993030281090124694858194866782889226223493799859404283664530068697313752856923001112586828837146686963124061670340088332769524367c = 212391106108596254648968182832931369624606731443797421732310126161911908195602305474921714075911012622738456373731638115041135121458776339519085497285769160263024788009541257401354037620169924991531279387552806754098200127027800103+24398526281840329222660628769015610312084745844610670698920371305353888694519135578269023873988641161449924124665731242993290561874625654977013162008430854786349580090169988458393820787665342793716311005178101342140536536153873825i+45426319565874516841189981758358042952736832934179778483602503215353130229731883231784466068253520728052302138781204883495827539943655851877172681021818282251414044916889460602783324944030929987991059211909160860125047647337380125j+96704582331728201332157222706704482771142627223521415975953255983058954606417974983056516338287792260492498273014507582247155218239742778886055575426154960475637748339582574453542182586573424942835640846567809581805953259331957385k'''\n首先，定义了一个四元数的运算，首先这里的p,q,r都是可以求的，解线性方程和四元数求模逆都是可行的方法，\n\nq^{-1}=\\frac{q^*}{|q|^2},其中q^*是q的共轭四元数(虚位取反即可)\\\\\npart1 求pqr\nF=GF(P)hint = [F(x) for x in [375413371936, 452903063925, 418564633198, 452841062207]]H = matrix(F,[    [hint[0],-hint[1],-hint[2],-hint[3]],    [hint[1],hint[0],-hint[3],hint[2]],    [hint[2],hint[3],hint[0],-hint[1]],    [hint[3],-hint[2],hint[1],hint[0]]])g = vector(GF(P),[gift[0],gift[1],gift[2],gift[3]])v = H.solve_right(g)p=int(v[1])q=int(v[2])r=int(v[3])#解方程\n\n\n\npart2 分析RSA\n\n这里e=65547=9*7283 且算一下就能发现e phi不互素，,然后这里模指不互素的原理还没有搞太明白，先贴一下exp，晚一些再补充一下\nclass ComComplex:    def __init__(self, value=[0,0,0,0]):        self.value = value    def __str__(self):        s = str(self.value[0])        for k,i in enumerate(self.value[1:]):            if i &gt;= 0:                s += '+'            s += str(i) +'ijk'[k]        return s    def __add__(self,x):        return ComComplex([i+j for i,j in zip(self.value,x.value)])    def __mul__(self,x):        a = self.value[0]*x.value[0]-self.value[1]*x.value[1]-self.value[2]*x.value[2]-self.value[3]*x.value[3]        b = self.value[0]*x.value[1]+self.value[1]*x.value[0]+self.value[2]*x.value[3]-self.value[3]*x.value[2]        c = self.value[0]*x.value[2]-self.value[1]*x.value[3]+self.value[2]*x.value[0]+self.value[3]*x.value[1]        d = self.value[0]*x.value[3]+self.value[1]*x.value[2]-self.value[2]*x.value[1]+self.value[3]*x.value[0]        return ComComplex([a,b,c,d])    def __mod__(self,x):        return ComComplex([i % x for i in self.value])    def __pow__(self, x, n=None):        tmp = ComComplex(self.value)        a = ComComplex([1,0,0,0])        while x:            if x &amp; 1:                a *= tmp            tmp *= tmp            if n:                a %= n                tmp %= n            x &gt;&gt;= 1        return a    def inv(self, mod):        inv_len = inverse(sum(i**2 for i in self.value), mod)        return ComComplex([self.value[0] * inv_len % mod, -self.value[1] * inv_len % mod, -self.value[2] * inv_len % mod, -self.value[3] * inv_len % mod])# 计算模逆元from Crypto.Util.number import *from sage.all import *hint = [375413371936,452903063925,418564633198,452841062207]gift = [8123312244520119413231609191866976836916616973013918670932199631084038015924368317077919454611785179950870055560079987034735836668109705445946887481003729,20508867471664499348708768798854433383217801696267611753941328714877299161068885700412171,22802458968832151777449744120185122420871929971817937643641589637402679927558503881707868,40224499597522456323122179021760594618350780974297095023316834212332206526399536884102863]P = 8123312244520119413231609191866976836916616973013918670932199631182724263362174895104545305364960781233690810077210539091362134310623408173268475389315109n = 408713495380933615345467409596399184629824932933932227692519320046890365817329617301604051766392980053993030281090124694858194866782889226223493799859404283664530068697313752856923001112586828837146686963124061670340088332769524367c = [212391106108596254648968182832931369624606731443797421732310126161911908195602305474921714075911012622738456373731638115041135121458776339519085497285769160263024788009541257401354037620169924991531279387552806754098200127027800103,24398526281840329222660628769015610312084745844610670698920371305353888694519135578269023873988641161449924124665731242993290561874625654977013162008430854786349580090169988458393820787665342793716311005178101342140536536153873825,45426319565874516841189981758358042952736832934179778483602503215353130229731883231784466068253520728052302138781204883495827539943655851877172681021818282251414044916889460602783324944030929987991059211909160860125047647337380125,96704582331728201332157222706704482771142627223521415975953255983058954606417974983056516338287792260492498273014507582247155218239742778886055575426154960475637748339582574453542182586573424942835640846567809581805953259331957385]e=65547# 65547 = 7283*9c = ComComplex([c[0],c[1],c[2],c[3]])F=GF(P)hint = [F(x) for x in [375413371936, 452903063925, 418564633198, 452841062207]]H = matrix(F,[    [hint[0],-hint[1],-hint[2],-hint[3]],    [hint[1],hint[0],-hint[3],hint[2]],    [hint[2],hint[3],hint[0],-hint[1]],    [hint[3],-hint[2],hint[1],hint[0]]])g = vector(GF(P),[gift[0],gift[1],gift[2],gift[3]])v = H.solve_right(g)p=int(v[1])q=int(v[2])r=int(v[3])phi =q*(q-1)*(q**2-1)# print(GCD(e,(p-1)*(q-1)*(r-1)))# print(GCD(e,p-1))print(GCD(e,q-1)) # 去计算q的欧拉函数？print(gcd(e,phi))d=inverse(e,phi//3)m = pow(c,d,q)# 实际上还是在这个四元数下计算得到的结果print(m)# print(GCD(e,r-1))for i in m.value:    print(long_to_bytes(int(i)).decode(),end='')# flag{Quaternion_15_ComComComComplexXXX!!!?}\n","categories":["复现"],"tags":["CTF","RSA","MT19937"]}]