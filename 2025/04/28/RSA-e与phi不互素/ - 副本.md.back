---
title: MoeCTF2024-å¤ç°
date: 2025-05-12 12:01:36
tags:
  - CTF
  - LLL
  - RSA
categories:
  - å¤ç°
mathjax: true
description: å¤ç°
---

> å¤ç°äº†ä¸€ä¸‹åé¢çš„å‡ é“é¢˜ç›®ï¼Œå‰é¢çš„é¢˜å†™çš„æ—¶é—´æœ‰ç‚¹ä¹…è¿œäº†ï¼Œ~~ä¸»è¦æ˜¯æˆ‘æ‡’~~





## Ezmatirx

é¢˜å¹²
```python
from Crypto.Util.number import *

from secret import FLAG,secrets,SECERT_T

  
  

assert len(secrets) == 16

assert FLAG == b'moectf{' + secrets + b'}'

assert len(SECERT_T) <= 127

  
  

class LFSR:

    def __init__(self):

        self._s = list(map(int,list("{:0128b}".format(bytes_to_long(secrets)))))

        for _ in range(8*len(secrets)):

            self.clock()

    def clock(self):

        b = self._s[0]

        c = 0

        for t in SECERT_T:c ^= self._s[t]

        self._s = self._s[1:] + [c]

        return b

    def stream(self, length):

        return [self.clock() for _ in range(length)]

  
  

c = LFSR()

stream = c.stream(256)

print("".join(map(str,stream))[:-5])

# 11111110011011010000110110100011110110110101111000101011001010110011110011000011110001101011001100000011011101110000111001100111011100010111001100111101010011000110110101011101100001010101011011101000110001111110100000011110010011010010100100000000110
```

`LFSR`é—®é¢˜ è€ƒè™‘ä½¿ç”¨BMç®—æ³•  æ¥æ¢å¤æŠ½å¤´`Secret_T`ï¼Œæ¿å­å¦‚ä¸‹
```python
def berlekamp_massey(s):

    n = len(s)

    c, b = [0] * n, [0] * n

    c[0], b[0] = 1, 1

    l, m, d = 0, -1, 0

    for i in range(n):

        d = s[i]

        for j in range(1, l + 1):

            d ^= c[j] & s[i - j]

        if d == 1:

            t = c.copy()

            p = [0] * n

            for j in range(n - i + m):

                if j < len(b):

                    p[j + i - m] = b[j]

            c = [c[k] ^ p[k] for k in range(n)]

            if 2 * l <= i:

                l, m, b = i + 1 - l, i, t

    return [i for i, bit in enumerate(c[:l + 1]) if bit]
```
ç„¶ålfsré€†ä¸å‡ºæ¥ï¼Œç¾ç¾ä¸ä¼šäº† ï¼Œä»”ç»†ä¸€æƒ³BMç®—æ³•å¥½åƒè¦æ±‚ä½ æœ‰çš„è¾“å‡ºåºåˆ—æ˜¯çŠ¶æ€nçš„è‡³å°‘ä¸¤å€ï¼Œè¿™é‡Œåªæœ‰251ä¸ªï¼Œä¼°è®¡ä¸å¤Ÿçš„ï¼Œåæ­£è¾“å‡ºä¹Ÿå°±æ˜¯01ä¸²ï¼Œç›´æ¥çˆ†ç ´è¿™äº”ä½ä¸å°±è¡Œå•¦ ç„¶åæ£€æµ‹ä¸€ä¸‹ ä¸‹æ ‡æœ‰å°äº0æˆ–è€…å¤§äº128çš„ä¸¢æ‰å°±è¡Œ ç„¶åå¯¹è·å¾—çš„tapsæ‹¿æ¥é€†lfsr 
exp

```python
def xor(state,taps):

    res = 0

    for i in taps:

        res^=state[i]

    return res

  

s_original = '11111110011011010000110110100011110110110101111000101011001010110011110011000011110001101011001100000011011101110000111001100111011100010111001100111101010011000110110101011101100001010101011011101000110001111110100000011110010011010010100100000000110'

  

for i in range(128):

    s = s_original

    s = s + bin(i)[2:].zfill(5)

    # print(s)

    # print(len(s))

    ss = list(map(int, s))

    taps = berlekamp_massey(ss)

    taps = [int(i)-1 for i in taps][1:]

    mark = 0

    for i in taps:

        if i<0 or i > 127:

            mark = 1

    if mark :

        continue

    # print(taps)

    lst = ss[:128][::-1]

    for i in range(128):

        tmp = lst[0]

        for i in range(1,128):

            lst[i-1] = lst[i]

        lst[127] = 0

        res = xor(lst,taps)

        if res != tmp:

            lst[127] = 1

    flag = long_to_bytes(int(''.join(map(str, lst[::-1])), 2))

    maybe = 1

    for i in flag:

        if not chr(i) in string.printable:

            maybe = 0

            break

    if maybe:

        print(flag)
```
```
b'e4sy_lin3ar_sys!'
b'e4sy_lin3ar_sys!'
b'e4sy_lin3ar_sys!'
```
`moectf{e4sy_lin3ar_sys!}` 
è¿™æ˜¯æˆ‘ä»¬è‡ªå·±çš„æ–¹æ³• å®˜æ–¹ä¹Ÿç»™äº†ç”¨çŸ©é˜µæ€è·¯æ¥æ±‚è§£çš„wp ~~è¯è¯´æ ‡é¢˜éƒ½æ˜¯Matrixç¡®å®è¯¥è¿™æ ·åšçš„ï¼‰~~

è¿™é‡Œæˆ‘ä»¬åˆ†æè¿™ä¸ª128ä½çš„çº¿æ€§åé¦ˆå¯„å­˜å™¨ 
æŠŠé—®é¢˜æ‹“å®½ åœ¨ä¸€ä¸ª$GF(2)$åŸŸä¸­æˆ‘ä»¬å¯¹äºä¸€ä¸ªnçº§çš„lfsr æˆ‘ä»¬è®¾å®ƒçš„é€’æ¨å…¬å¼æ˜¯ 
$$
a_{i+n}=\sum\limits^{n-1}_{k=0}a_{i+k}c_{k+1}
$$
$$
S_i=(a_i,a_{i+1},\dots,a_{i+n-1})
$$
å¯¹åº”çš„æ¬¡æ€æ˜¯
$$
S_{i+1}=(a_{i+1},a_{i+2},\dots,a_{i+n})
$$
å¯ä»¥æ„å»ºçŸ©é˜µè¿ç®—å¼
$$
(a_i, a_{i+1}, \cdots, a_{i+n-1}) \cdot 
\begin{pmatrix}
0 & 0 & \cdots & 0 & c_1 \\
1 & 0 & \cdots & 0 & c_{2} \\
0 & 1 & \cdots & 0 & c_{3} \\
\vdots & \vdots & \ddots & \vdots & \vdots \\
0 & 0 & \cdots & 1 & c_{n}
\end{pmatrix}
= (a_{i+1}, a_{i+2}, \cdots, a_{i+n})
$$
ç®€è®°ä¸º
$$
S_{i}C = S_{i+1}
$$
å¯è§æˆ‘ä»¬æŠŠè¿™é‡Œçš„åˆ—æ”¾åœ¨ä¸€ä¸ªæ— é™é•¿çš„ç›´çº¿ä¸Šï¼Œå¯¹è¿™ä¸ªåºåˆ—å³ä¹˜çŸ©é˜µ$C$å°±èƒ½å®ç°æˆ‘ä»¬çš„â€œçº¿æ€§ç§»ä½â€ï¼ŒåŒæ—¶å¯¹äºæ¯ä¸€ä¸ªè¾“å‡ºï¼Œæˆ‘ä»¬éƒ½æœ‰
$$
a_{i+n}=S_i*(c_{1},c_{2},\dots,c_{n})^{T}
$$
æˆ‘ä»¬æŠŠè¿™é‡Œçš„
$$
(c_{1},c_{2},\dots,c_{n})
$$
è§†ä¸ºæœªçŸ¥é‡ï¼Œå½“æˆ‘ä»¬æ”¶é›†åˆ°äº†
$$
a_{1}\sim  a_{2n}
$$
çš„æ‰€æœ‰æ•°æ®ï¼Œæˆ‘ä»¬å°±èƒ½æ„é€ å‡º$n$ä¸ªæ–¹ç¨‹
$$
\begin{flalign}
a_{1+n} &= S_1 \cdot (c_{1}, c_{2}, \dots, c_{n})^{T} & \\
a_{2+n} &= S_2 \cdot (c_{1}, c_{2}, \dots, c_{n})^{T} & \\
& \vdots & \\
a_{2n} &= S_n \cdot (c_{1}, c_{2}, \dots, c_{n})^{T} &
\end{flalign}
$$
ç°åœ¨æˆ‘ä»¬æ„é€ æ»¡ç§©æ–¹ç¨‹ç»„
$$
\begin{pmatrix} S_{1} \\ S_2 \\ \vdots \\ S_{n}\end{pmatrix}\begin{pmatrix}c_{1} \\ c_{2} \\ \vdots \\ c_n\end{pmatrix}=\begin{pmatrix}a_{n+1} \\ a_{n+2} \\ \vdots \\ a_{2n}\end{pmatrix}
$$
æ˜¾ç„¶å·¦è¾¹æ˜¯æ»¡ç§©çš„ï¼Œä¹˜é€†çŸ©é˜µå°±èƒ½è®¡ç®—å‡º$C$äº†
å›åˆ°è¿™é¢˜ï¼Œæ”¶é›†çš„è¿‡ç¨‹æ˜¯ä¸æ˜¯å°±ç†æ‰€å½“ç„¶äº†å‘¢ï¼Ÿ
æ¥ç‚¹è„šæœ¬
```python
# sage
F = GF(2)

V = VectorSpace(F,n)

vec = V(list(map(int, list(output[n:]))))# è¿™é‡Œåº”è¯¥ä¿è¯outputåˆšå¥½æœ‰2nä½ï¼Œä¸ç„¶é…ä¸é½

M = []

for i in range(n-1,2*n-1):

    m = []

    for j in range(n):

        m.append(output[i-j])

    M.append(m)

M = Matrix(F,M)

print(M.rank())

sol = M.solve_right(vec)

print(len(sol))

taps = [idx for idx, val in enumerate(sol) if val == 1]

print("taps:", taps)

print("len(taps):", len(taps))
```
æ³¨æ„è¿™é‡Œçš„lfsræ–°ä½åœ¨æ”¾åœ¨åé¢ï¼Œæ˜¯å·¦ç§»åŠ æ”¾ä½çš„
æˆåŠŸæ‰¾åˆ°$C$ä¹‹åï¼Œæˆ‘ä»¬å°±èƒ½
$$
S_{i-1}=S_{i}C^{-1}
$$
ç¾ç¾è¿ç®—æ‰¾å›åˆæ€ï¼Œæ¿å­å¦‚ä¸‹
```python
poly = list(sol)

B = Matrix(F,n,n)

for i in range(n):

    B[i,n-1] = poly[n-1-i]

for i in range(n-1):

    B[i+1,i] = 1

B_inv = B**(-1)

t = V(list(map(int,list(output[:n]))))

print(long_to_bytes(int("".join(map(str,t*B_inv**(n))),2)))
```

è¯´å®è¯æ¨å¯¼å‘å³ç§» æ”¾æœ€ä½ä½çš„ä¹Ÿæ˜¯ç±»ä¼¼çš„æ€è·¯ï¼Œè¿™é‡Œå°±ä¸å¤šå†™äº†~~ä¸»è¦æ˜¯æ‡’~~

## EzPack

```python
from Crypto.Util.number import *

from secret import flag

import random  
  
p = 2050446265000552948792079248541986570794560388346670845037360320379574792744856498763181701382659864976718683844252858211123523214530581897113968018397826268834076569364339813627884756499465068203125112750486486807221544715872861263738186430034771887175398652172387692870928081940083735448965507812844169983643977

# print(p.bit_length()) 1038

assert len(flag) == 42

  
  

def encode(msg):

    return bin(bytes_to_long(msg))[2:].zfill(8*len(msg))


def genkey(len):

    sums = 0

    keys = []

    for i in range(len):

        k = random.randint(1,7777)

        x = sums + k

        keys.append(x)

        sums += x

    return keys

  
  

key = genkey(42*8) # 336

  
  

def enc(m, keys):

    msg = encode(m)

    print(len(keys))

    print(len(msg))

    assert len(msg) == len(keys)

    s = sum((k if (int(p,2) == 1) else 1) for p, k in zip(msg, keys))

    print(msg)

    for p0,k in zip(msg,keys):

        print(int(p0,2))

    return pow(7,s,p)

  
  

cipher = enc(flag,key)

  

with open("output.txt", "w") as fs:

    fs.write(str(key)+'\n')

    fs.write(str(cipher))
```

èƒŒåŒ…é—®é¢˜ é¢˜ç›®åŠ å¯†æµç¨‹ä¸ºæŠŠ`flag`ç¼–ç ä¸ºäºŒè¿›åˆ¶01ä¸²$m$ ç„¶åç”ŸæˆèƒŒåŒ…åºåˆ—$key$,æ»¡è¶³
$$
k_i>k_{i-1}+k_{i-2}+\dots+k_1
$$
ç„¶åæ ¹æ®è¿™ä¸ª$m$ä¸²ï¼Œæ„å»º
$$
s=\sum\limits^{n}_{i=1}m_ik_i
$$
å†è¿”å›
$$
c\equiv\;7^{s}\;mod\;p
$$
é‚£ä¹ˆå¾ˆæ˜¾ç„¶ï¼Œæˆ‘ä»¬å…ˆæƒ³åŠæ³•è§£å†³è¿™ä¸ªç¦»æ•£å¯¹æ•°é—®é¢˜ï¼Œæ±‚è§£$s$
å¯¹`p-1`è¿›è¡Œåˆ†è§£ï¼Œç»“æœå¦‚ä¸‹
```text
factors = [2, 2, 2, 3, 7, 636277, 677857, 682777, 735809, 860059, 903949, 908441, 954851, 1017139, 1032341, 1163131, 1190737, 1227157, 1341323, 1395671, 1463611, 1556201, 1569401, 1713749, 1930931, 2219563, 2476283, 2477281, 2590633, 2756587, 2833643, 3095713, 3281449, 3688063, 4008793, 4285993, 5443981, 5720053, 5822981, 6201869, 6892217, 7093841, 7319857, 8227237, 9381107, 9477463, 10078729, 10084297, 10764907, 12416167, 14095651, 14294663, 14788051]
```
å¯è§ååˆ†çš„å…‰æ»‘ï¼Œç›´æ¥ä½¿ç”¨sageå†…ç½®çš„Pohlig-Hellmanç®—æ³•è§£å°±è¡Œï¼Œå‡ ä¹æ˜¯ç§’å‡º
```python
c = 1210552586072154479867426776758107463169244511186991628141504400199024936339296845132507655589933479768044598418932176690108379140298480790405551573061005655909291462247675584868840035141893556748770266337895571889128422577613223452797329555381197215533551339146807187891070847348454214231505098834813871022509186

p = 2050446265000552948792079248541986570794560388346670845037360320379574792744856498763181701382659864976718683844252858211123523214530581897113968018397826268834076569364339813627884756499465068203125112750486486807221544715872861263738186430034771887175398652172387692870928081940083735448965507812844169983643977

g = 7

R = GF(p)

x = R(c).log(g)

print("è§£å¾—çš„ x =", x)
```
å®˜æ–¹ä¹Ÿç»™äº†ä½¿ç”¨Pohlig-Hellmanç®—æ³•çš„æ¿å­ï¼Œåœ¨è¿™é‡Œè´´ä¸€ä¸‹
```python
F = GF(p)
a = F(7)
X = F(cipher)
n = a.order()
primes = [2^3,3,7,636277,677857,682777,735809,860059,903949,908441,954851, 1017139, 1032341, 1163131, 1190737, 1227157, 1341323, 1395671, 1463611, 1556201, 1569401, 1713749, 1930931, 2219563, 2476283, 2477281, 2590633, 2756587, 2833643, 3095713, 3281449, 3688063, 4008793, 4285993, 5443981, 5720053, 5822981, 6201869, 6892217, 7093841, 7319857, 8227237, 9381107, 9477463, 10078729, 10084297, 10764907, 12416167, 14095651, 14294663,14788051] dlogs = []
for fac in primes: 
	t = int(n//fac) 
	dlog = discrete_log(X**t, a**t) 
	dlogs += [dlog] 
	print("factor:"+str(fac)+",Discrete Log:"+str(dlog))
	
nc = crt(dlogs,primes)
print(nc)
assert pow(7,nc,p) == cipher
```
å¤§è‡´æ€è·¯å°±æ˜¯è½¬åŒ–åˆ°æ¨¡å°å› å­ä¸‹è¿›è¡Œæ±‚è§£å¯¹æ•°ï¼Œå†å¯¹ç»“æœæ‰“CRTï¼Œè¿™é‡Œä¸ç»†è®²
ç„¶åå°±æ˜¯æ±‚è§£è¿™ä¸ªèƒŒåŒ…äº†ï¼Œè¿™é‡Œæ˜¯çº¿æ€§çš„ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘å¦‚ä¸‹æ€è·¯
[èƒŒåŒ…å¯†ç  | DexterJie'Blog](https://dexterjie.github.io/2024/07/29/%E8%83%8C%E5%8C%85%E5%AF%86%E7%A0%81/)

```python
def solve_knapsack(key, target):

    key = key.copy()

    # é¢„å¤„ç†ï¼šè®¡ç®— k-1 å¹¶æ’åºï¼ˆä»å¤§åˆ°å°ï¼‰

    items = [(k - 1) for k in key]

    items.sort(reverse=True)

    # è´ªå¿ƒé€‰æ‹©

    selected = []

    remaining = target

    for num in items:

        if remaining >= num:

            selected.append(num)

            remaining -= num

    if remaining != 0:

        return None

    # è¿”å›å¯¹åº” bit=0 çš„ä½ç½®

    bitmask = [1] * len(key)

    for num in selected:

        idx = next(i for i, k in enumerate(key) if (k - 1) == num)

        bitmask[idx] = 0

    return bitmask

sum = sum(m)

target = sum - x

  
  

bitmask = solve_knapsack(m, target)

# Step 3: æ¢å¤æ˜æ–‡

msg = ''.join(str(b) for b in bitmask)

flag = long_to_bytes(int(msg, 2))

print("Flag:", flag.decode())

# moectf{429eaa156f6961d6bc655c1887ebb779ec}
```

## OneMoreBit

```python

from Crypto.Util.number import getStrongPrime, bytes_to_long, GCD, inverse

from Crypto.Util.Padding import pad

from secret import flag

import random

def genKey(nbits,dbits):

    p = getStrongPrime(nbits//2)

    q = getStrongPrime(nbits//2)

    n = p*q

    phi = (p-1)*(q-1)

    while True:

        d = random.getrandbits(dbits)  

        if d.bit_length() == dbits:

            if GCD(d, phi) == 1:

                e = inverse(d, phi)

                pk = (n, e)

                sk = (p, q, d)

                return pk, sk

nbits = 1024

dbits = 258

message = pad(flag,16)

msg = pad(message, 16)

m = bytes_to_long(msg)

pk= genKey(nbits, dbits)[0]

n, e = pk

ciphertext = pow(m, e, n)

  

with open("data.txt","w") as f:

    f.write(f"pk = {pk}\n")

    f.write(f"ciphertext = {ciphertext}\n")

    f.close()
```

è¿™é‡Œç”¨çš„æ˜¯`getStrongPrime`æ¥ç”Ÿæˆçš„ç´ æ•°ï¼Œå…·ä½“å°±æ˜¯
$$
p
$$
ä¸ºç´ æ•°
$$
\frac{p-1}{2}
$$
ä¹Ÿæ˜¯å¤§ç´ æ•°
$$
p-1;p+1
$$å…‰æ»‘åº¦å¾ˆä½

ç”Ÿæˆä¸¤ä¸ª512ä½å¼ºç´ æ•°$p,q$ 
ç„¶åç”Ÿæˆ258ä½çš„ç§é’¥$d$ ä¿è¯$(d,\phi)=1$,ç„¶ååè¿‡æ¥ç”Ÿæˆå…¬é’¥æŒ‡æ•°$e$ å‘Šè¯‰ä½ å…¬é’¥$(e,n)$
è¿™é‡Œè‚¯å®šä¸è®©ä½ åˆ†è§£$n$çš„
è¿™é‡Œæ³¨æ„åˆ°$d$ä¸æ˜¯256ä½è€Œæ˜¯258ä½ï¼Œè€Œä¸”æ˜¯ç”±$d$è¿™æ ·ç”Ÿæˆ$e$çš„ï¼Œç»“åˆé¢˜ç›®åå­—ï¼Œæœ‰ä»€ä¹ˆæ€è·¯å—ğŸ¤”
å¦‚æœ$d$å°ä¸€ç‚¹æˆ‘ä»¬è€ƒè™‘æ‹“å±•ç»´çº³æ”»å‡»ï¼Œä½†æ˜¯è¿™é‡Œåˆšå¥½å¤§äº†ä¸€äº›
ç®€å•æœç´¢ä¹‹åæ‰¾åˆ°äº†`Boneh-Durfee`æ”»å‡»æ–¹æ³•
[mimoo/RSA-and-LLL-attacks: attacking RSA via lattice reductions (LLL) (github.com)](https://github.com/mimoo/RSA-and-LLL-attacks)
sir,this way
æ¢­ä¸€ä¸‹è„šæœ¬å°±èƒ½è½»æ¾è§£å‡ºdäº†ï¼Œä½†æ˜¯å‘¢å®é™…ä¸Šæ ‡ç­”ä½¿ç”¨çš„æ˜¯`The Verheul and van Tilborg attack`
è®ºæ–‡åœ¨è¿™é‡Œ [0811.0063 (arxiv.org)](https://arxiv.org/pdf/0811.0063)
å¯è§å°±ç®—æ˜¯æ³„éœ²ç§é’¥ä½æ•°ä¹Ÿæ˜¯éå¸¸éå¸¸å±é™©çš„

## EzLCG

```python
from sage.all import *

from random import getrandbits, randint

from secrets import randbelow

from Crypto.Util.number import getPrime,isPrime,inverse

from Crypto.Util.Padding import pad

from Crypto.Cipher import AES

from secret import priKey, flag

from hashlib import sha1

import os

  
  

q = getPrime(160)

while True:

    t0 = q*getrandbits(864)

    if isPrime(t0+1):

        p = t0 + 1

        break

  
  

x = priKey

assert p % q == 1

h = randint(1,p-1)

g = pow(h,(p-1)//q,p)

y = pow(g,x,p)

  
  

def sign(z, k):

    r = pow(g,k,p) % q

    s = (inverse(k,q)*(z+r*priKey)) % q

    return (r,s)

  
  

def verify(m,s,r):

    z = int.from_bytes(sha1(m).digest(), 'big')

    u1 = (inverse(s,q)*z) % q

    u2 = (inverse(s,q)*r) % q

    r0 = ((pow(g,u1,p)*pow(y,u2,p)) % p) % q

    return r0 == r

  
  

def lcg(a, b, q, x):

    while True:

        x = (a * x + b) % q

        yield x

  
  

msg = [os.urandom(16) for i in range(5)]

  

a, b, x = [randbelow(q) for _ in range(3)]

prng = lcg(a, b, q, x)

sigs = []

for m, k in zip(msg,prng):

    z = int.from_bytes(sha1(m).digest(), "big") % q

    r, s = sign(z, k)

    assert verify(m, s, r)

    sigs.append((r,s))

  
  

print(f"{g = }")

print(f"{h = }")

print(f"{q = }")

print(f"{p = }")

print(f"{msg = }")

print(f"{sigs = }")

key = sha1(str(priKey).encode()).digest()[:16]

iv = os.urandom(16)

cipher = AES.new(key, AES.MODE_CBC,iv)

ct = cipher.encrypt(pad(flag,16))

print(f"{iv = }")

print(f"{ct = }")

  
  

'''

g = 81569684196645348869992756399797937971436996812346070571468655785762437078898141875334855024163673443340626854915520114728947696423441493858938345078236621180324085934092037313264170158390556505922997447268262289413542862021771393535087410035145796654466502374252061871227164352744675750669230756678480403551

h = 13360659280755238232904342818943446234394025788199830559222919690197648501739683227053179022521444870802363019867146013415532648906174842607370958566866152133141600828695657346665923432059572078189013989803088047702130843109809724983853650634669946823993666248096402349533564966478014376877154404963309438891

q = 1303803697251710037027345981217373884089065173721

p = 135386571420682237420633670579115261427110680959831458510661651985522155814624783887385220768310381778722922186771694358185961218902544998325115481951071052630790578356532158887162956411742570802131927372034113509208643043526086803989709252621829703679985669846412125110620244866047891680775125948940542426381

msg = [b'I\xf0\xccy\xd5~\xed\xf8A\xe4\xdf\x91+\xd4_é¢˜ç›®ç”¨ä¸€ä¸ªç§é’¥$', b'~\xa0\x9bCB\xef\xc3SY4W\xf9Aa\rO', b'\xe6\x96\xf4\xac\n9\xa7\xc4\xef\x82S\xe9 XpJ', b'3,\xbb\xe2-\xcc\xa1o\xe6\x93+\xe8\xea=\x17\xd1', b'\x8c\x19PHN\xa8\xbc\xfc\xa20r\xe5\x0bMwJ']

sigs = [(913082810060387697659458045074628688804323008021, 601727298768376770098471394299356176250915124698), (406607720394287512952923256499351875907319590223, 946312910102100744958283218486828279657252761118), (1053968308548067185640057861411672512429603583019, 1284314986796793233060997182105901455285337520635), (878633001726272206179866067197006713383715110096, 1117986485818472813081237963762660460310066865326), (144589405182012718667990046652227725217611617110, 1028458755419859011294952635587376476938670485840)]

iv = b'M\xdf\x0e\x7f\xeaj\x17PE\x97\x8e\xee\xaf:\xa0\xc7'

ct = b"\xa8a\xff\xf1[(\x7f\xf9\x93\xeb0J\xc43\x99\xb25:\xf5>\x1c?\xbd\x8a\xcd)i)\xdd\x87l1\xf5L\xc5\xc5'N\x18\x8d\xa5\x9e\x84\xfe\x80\x9dm\xcc"

'''
```
$xæ„å»ºäº†ä¸€ä¸ªç”Ÿæˆå™¨ä¸ç­¾åç³»ç»Ÿç„¶åå‘Šè¯‰è¿™ä¸ªçš„å…¬é’¥$LCGï¼ŒDSA
DSA$(g,h)å¥½å‡ ç»„ç­¾åçš„ç»“æœ$ï¼Œ$(r,s)p,q,m,H(m),g,hä¹Ÿå°±æ˜¯è¯´ç»™å‡º$ï¼Œ$k_{i}æˆ‘ä»¬èƒ½å¿«é€Ÿç®—å‡º$,$r_{i}å†æ ¹æ®$ï¼Œ$z_{i}æˆ‘ä»¬èƒ½æ„å»ºä¸€ä¸ªæœ‰å…³$,$x,k_{1},k_{2},\dots,k_{5}çš„æ–¹ç¨‹æƒ³åŠæ³•ä»å…¶ä¸­æ¢å¤$ï¼Œ$x$ ï¼Ÿ
æˆ‘ä»¬è¯¥ä»£å…¥çš„ä»£å…¥ï¼Œä¸éš¾å¾—åˆ°
$$
k_{i}s_{i}\equiv\;(z_{i}+r_{i}\;\;x)\;mod\;q
$$
$$
k_{i+1}s_{i+1}\equiv\;(z_{i+1}+r_{i+1}\;\;x)\;mod\;q
$$
ç»“åˆLCGçš„ç®€æ˜“çº¿æ€§å…³ç³»
$$
k_{i+1}\equiv\;ak_{i}+b\;mod\;q
$$
æˆ‘ä»¬å…ˆæ¶ˆå»$b$,è€ƒè™‘
$$
k_{i}\equiv\;ak_{i-1}+b\;mod\;q
$$
å³
$$
k_{i+1}-k_{i}\;\equiv\;a(k_{i}-k_{i-1})\;mod\;q
$$
åˆ
$$
k_{i}\equiv\;s_{i}^{-1}(z_{i}+r_{i}\;\;x)\;mod\;q
$$
ä»£å…¥
$$
s_{i+1}^{-1}(z_{i+1}+r_{i+1}\;\;x)\;-s_{i}^{-1}(z_{i}+r_{i}x)\;\equiv\;a(s_{i}^{-1}(z_{i}+r_{i}\;\;x)\;-s_{i-1}^{-1}(z_{i-1}+r_{i-1}x))\;mod\;q
$$
æˆ‘ä»¬æŠŠæ‰€æœ‰å’Œ$x$æœ‰å…³çš„éƒ½æ”¾åˆ°å·¦è¾¹ï¼Œå…¶ä»–çš„æ”¾åˆ°å³è¾¹,ä½†æ˜¯åœ¨è¿™æ ·çš„è¯ï¼ŒåŒæ—¶å°±æœ‰äº†$a,x$ä¸¤ä¸ªæœªçŸ¥é‡...


å‘ƒå‘ƒï¼Œå¥½åƒä¸æ˜¯è¿™æ ·æ„é€ çš„,çœ‹ä¸€ä¸‹wp,
$$
(k_{i+2}-k_{i+1})(k_{i}-k_{i-1})\;\equiv\;(k_{i+1}-k_{i})^{2}\;mod\;q
$$
è€Œæˆ‘ä»¬åˆçŸ¥é“
$$
k_{i} \;\equiv\;u_{i}+v_{i}x\;mod\;p
$$
æ‰€ä»¥ç”±ä¸Šå¼ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°å…³äº$x$çš„äºŒæ¬¡æ–¹ç¨‹ï¼Œè€ƒè™‘ç”¨coppersmith
$$
(u_{i+2}-u_{i+1}+(v_{i+2}-v_{i+1})x)((u_{i}-u_{i-1}+(v_{i}-v_{i-1})x))\;\equiv\;((u_{i+1}-u_{i}+(v_{i+1}-v_{i})x))^2\;mod\;p
$$
å–$i=1$å³å¯
```python
from random import getrandbits, randint

from secrets import randbelow

from Crypto.Util.number import getPrime,isPrime,inverse

from Crypto.Util.Padding import pad

from Crypto.Cipher import AES

from hashlib import sha1

g = 81569684196645348869992756399797937971436996812346070571468655785762437078898141875334855024163673443340626854915520114728947696423441493858938345078236621180324085934092037313264170158390556505922997447268262289413542862021771393535087410035145796654466502374252061871227164352744675750669230756678480403551

h = 13360659280755238232904342818943446234394025788199830559222919690197648501739683227053179022521444870802363019867146013415532648906174842607370958566866152133141600828695657346665923432059572078189013989803088047702130843109809724983853650634669946823993666248096402349533564966478014376877154404963309438891

q = 1303803697251710037027345981217373884089065173721

p = 135386571420682237420633670579115261427110680959831458510661651985522155814624783887385220768310381778722922186771694358185961218902544998325115481951071052630790578356532158887162956411742570802131927372034113509208643043526086803989709252621829703679985669846412125110620244866047891680775125948940542426381

msg = [b'I\xf0\xccy\xd5~\xed\xf8A\xe4\xdf\x91+\xd4_è¿™é‡Œç”¨æ ¼å­åè€Œå¾ˆéº»çƒ¦ä¸æ˜¯å¾ˆå¤§å‘Šè¯‰äº†ä¸€ä¸ª$', b'~\xa0\x9bCB\xef\xc3SY4W\xf9Aa\rO', b'\xe6\x96\xf4\xac\n9\xa7\xc4\xef\x82S\xe9 XpJ', b'3,\xbb\xe2-\xcc\xa1o\xe6\x93+\xe8\xea=\x17\xd1', b'\x8c\x19PHN\xa8\xbc\xfc\xa20r\xe5\x0bMwJ']

sigs = [(913082810060387697659458045074628688804323008021, 601727298768376770098471394299356176250915124698), (406607720394287512952923256499351875907319590223, 946312910102100744958283218486828279657252761118), (1053968308548067185640057861411672512429603583019, 1284314986796793233060997182105901455285337520635), (878633001726272206179866067197006713383715110096, 1117986485818472813081237963762660460310066865326), (144589405182012718667990046652227725217611617110, 1028458755419859011294952635587376476938670485840)]

iv = b'M\xdf\x0e\x7f\xeaj\x17PE\x97\x8e\xee\xaf:\xa0\xc7'

ct = b"\xa8a\xff\xf1[(\x7f\xf9\x93\xeb0J\xc43\x99\xb25:\xf5>\x1c?\xbd\x8a\xcd)i)\xdd\x87l1\xf5L\xc5\xc5'N\x18\x8d\xa5\x9e\x84\xfe\x80\x9dm\xcc"

  
  

z=[]

for m in msg:

    z.append(int.from_bytes(sha1(m).digest(), 'big'))

# print(z)

r=[]

s=[]

for (i,j) in sigs:

    r.append(i)

    s.append(j)

# print(s)

# print(r)

u=[]

v=[]

  

for i in range(len(msg)):

    u.append((inverse(s[i],q)*z[i]))

    v.append((inverse(s[i],q)*r[i]))

  

F=GF(q)

R.<x>=Zmod(q)[]

f = (u[3]-u[2]+(v[3]-v[2])*x)*((u[1]-u[0]+(v[1]-v[0])*x))-((u[2]-u[1]+(v[2]-v[1])*x))**2

f=f.monic()

xx = f.roots()

print(xx)

for i in xx:

    x=i[0]

    key = sha1(str(x).encode()).digest()[:16]

    cipher = AES.new(key, AES.MODE_CBC,iv)

    flag=cipher.decrypt(ct)

    print(flag)
    # b'moectf{w3ak_n0nce_is_h4rmful_to_h3alth}\t\t\t\t\t\t\t\t\t'
```
ï¼‰ï¼‰

## babelifting

```python
from Crypto.Util.number import *

from secret import flag
 

p = getPrime(512)

q = getPrime(512)

n = p*q

e = 0x1001 #

d = inverse(e, (p-1)*(q-1))

bit_leak = 400

d_leak = d & ((1<<bit_leak)-1)

msg = bytes_to_long(flag)

cipher = pow(msg,e,n)

pk = (n, e)

  

with open('output.txt','w') as f:

    f.write(f"pk = {pk}\n")

    f.write(f"cipher = {cipher}\n")

    f.write(f"hint = {d_leak}\n")

    f.close()
```
$d$çš„ä½æ•°çš„æ³„éœ²ï¼Œå·²çŸ¥ä½400ä½ï¼Œæœç´¢æ‰¾åˆ°åšå®¢
[dä½ä½æ”»å‡» & dé«˜ä½æ”»å‡»-CSDNåšå®¢](https://blog.csdn.net/XiongSiqi_blog/article/details/130171830)
[ã€CTF-RSAã€‘sageè„šæœ¬_d ä½ä½æ”»å‡» - å“”å“©å“”å“© (bilibili.com)](https://www.bilibili.com/opus/587017245055589683)
æ€è·¯ç®€è¿°å¦‚ä¸‹
å·²çŸ¥
$$
ed\;\equiv\;1\;mod\;\phi(n)
$$
å³
$$
ed\;=1+k(p-1)(q-1)\;,(k<e)
$$
ä¸¤è¾¹å¯¹$2^{400}$å–æ¨¡ï¼Œå¾—åˆ°
$$
ed_{l}\;\equiv\;1+k(p-1)(q-1)\;mod\;2^{400}
$$
æ¶ˆå»$q$å¯å¾—
$$
ed_{l}\;\equiv\;1+k(p-1)(\frac{n}{p}-1)\;mod\;2^{400}$$
å±•å¼€ä¸€ä¸‹å°±æ˜¯
$$
kp^{2}+(ed_{l}-1-k(n+1))p+kn\;\equiv\;0\;mod\;2^{400}
$$
æˆ‘ä»¬æšä¸¾æ‰€æœ‰å¯èƒ½çš„$k<e$ èƒ½å¾—åˆ°ä¸€ä¸ªå…³äº$p$çš„äºŒæ¬¡æ–¹ç¨‹ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬èƒ½è§£å‡ºæ¥$p\;mod\;2^{400}$
å†è€ƒè™‘coppersmithå³å¯
æ³¨æ„åˆ°è¿™é‡Œ400ä½å¤ªé«˜ï¼Œè€Œä¸”$n$ä¹Ÿä¸å¤§ï¼Œç»“åˆé¢˜å¹²ï¼Œæˆ‘ä»¬è€ƒè™‘HenselLiftingçš„æ–¹æ³•æ¥æ±‚è§£
[æ¨¡p^kçš„åŒä½™æ–¹ç¨‹å’Œç¦»æ•£å¯¹æ•°æ±‚è§£_åŒä½™å¤šé¡¹å¼ä¸crypto-CSDNåšå®¢](https://blog.csdn.net/qwerzbc66/article/details/144989042)

```python
p = 2
k = 100
m = pow(p, k)

x = var('x')
fx = 31635333913961551790218176796 * x ^ 2 + 343355432375781642567844278672 * x + 569420970791634503307822359156

# solve the equation f(x)=0 over m=p^k
solutions = solve_mod([fx == 0], m)  
for solution in solutions:
    print(int(fx(int(solution[0]))) % m == 0) # True

```

å®˜æ–¹çš„è„šæœ¬è²Œä¼¼æœ‰ç‚¹å°é—®é¢˜ï¼Œæˆ‘è¿™é‡Œè·‘çš„è¯ä¼šç‚¸å†…å­˜ï¼Œæ²¡æ³•æŒ‰ç…§é¢„æœŸè·‘å‡ºæ¥ï¼Œæˆ‘çš„expä¿®æ”¹åå¦‚ä¸‹
```python
# sage 10.6
from Crypto.Util.number import *

from tqdm import trange

  

n, e = (53282434320648520638797489235916411774754088938038649364676595382708882567582074768467750091758871986943425295325684397148357683679972957390367050797096129400800737430005406586421368399203345142990796139798355888856700153024507788780229752591276439736039630358687617540130010809829171308760432760545372777123, 4097)

cipher = 14615370570055065930014711673507863471799103656443111041437374352195976523098242549568514149286911564703856030770733394303895224311305717058669800588144055600432004216871763513804811217695900972286301248213735105234803253084265599843829792871483051020532819945635641611821829176170902766901550045863639612054

dl = 1550452349150409256147460237724995145109078733341405037037945312861833198753379389784394833566301246926188176937280242129

  

# Initialize list for potential p values

mp = []

  

def find_p(pl, n,e):

    R.<y> = PolynomialRing(Zmod(n), implementation='NTL')

    g = y*2^400 + pl  # Changed from 398 to 400 to match your original approach

    g = g.monic()

    try:

        # Adjusted parameters

        gg = g.small_roots(X=2^112, beta=0.5, epsilon=0.05)

        if gg:

            for root in gg:

                p_candidate = int(root)*2^400 + int(pl)

                if n % p_candidate == 0:  # Verify it's a factor

                    q = n // p_candidate

                    phi = (p_candidate-1)*(q-1)

                    try:

                        d = inverse_mod(e, phi)

                        m = pow(cipher, d, n)

                        print(long_to_bytes(int(m)))

                        mp.append(p_candidate)

                    except ValueError:

                        continue

    except Exception as e:

        print(f"Error in small_roots: {e}")

        return

  

# Main loop

for k in trange(1, e+1):

    try:

        # Using solve_mod properly


        R_mod = Zmod(2^400)

        x_mod = R_mod['x'].gen()

        poly = k*x_mod^2 + (e*dl - 1 - (n+1)*k)*x_mod + k*n

        roots = poly.roots(multiplicities=False)

        for pl in roots:

            find_p(int(pl), n,e)

    except Exception as e:

        print(f"Error in k={k}: {e}")

        continue

  

print("Found p candidates:", mp)

# b'moectf{7h3_st4rt_0f_c0pp3rsmith!}'
```
å¤§æ¦‚ä¸¤åˆ†é’Ÿå§ï¼Œå…¨è·‘å®Œæ•°æ®è¦ååˆ†é’Ÿå¤š

## HiddenPoly

```python
from Crypto.Util.Padding import pad

from Crypto.Util.number import *

from Crypto.Cipher import AES

import os

  
  

q = 264273181570520944116363476632762225021

key = os.urandom(16) #16å­—èŠ‚çš„å­—ç¬¦ä¸²key

iv = os.urandom(16)

root = 122536272320154909907460423807891938232

f = sum([a*root**i for i,a in enumerate(key)])

assert key.isascii()

assert f % q == 0

  

with open('flag.txt','rb') as f:

    flag = f.read()

  

cipher = AES.new(key,AES.MODE_CBC, iv)

ciphertext = cipher.encrypt(pad(flag,16)).hex()

  

with open('output.txt','w') as f:

    f.write(f"{iv = }" + "\n")

    f.write(f"{ciphertext = }" + "\n")

  

iv = b'Gc\xf2\xfd\x94\xdc\xc8\xbb\xf4\x84\xb1\xfd\x96\xcd6\\'

ciphertext = 'd23eac665cdb57a8ae7764bb4497eb2f79729537e596600ded7a068c407e67ea75e6d76eb9e23e21634b84a96424130e'
```

ç»™ä½ äº†
$$
f=\sum\limits ^{15}_{i=0}a_{i}\;root^{i}
$$
è€Œä¸”æœ‰
$$
f\equiv\;0\;mod\;q
$$
ä¹Ÿå°±æ˜¯
$$
\sum\limits ^{15}_{i=0}a_{i}\;root^{i}\;\equiv\;0\;mod\;q
$$
æ¥ä¸‹æ¥æˆ‘ä»¬ç”±è¿™ä¸ªå¼å­è¦å°è¯•æ¢å¤å‡º$key$ è€ƒè™‘è¿™é‡Œçš„$a_{i}$ååˆ†æ»´å°ï¼Œæˆ‘ä»¬é€ ä¸ªæ ¼å­ï¼Œå…ˆæ•´ä¸€ä¸ªè¿ç®—å¼å‡ºæ¥
$$
(a_0,a_1,\dots,a_{15},-k)
\begin{pmatrix}
1 & 0 & \cdots & 0 & root^0 \\
0 & 1 & \cdots & 0 & root^1 \\
\vdots & \vdots & \ddots & \vdots & \vdots \\
0 & 0 & \cdots & 1 & root^{15} \\
0 & 0 & \cdots & 0 & q
\end{pmatrix}=(a_0,a_1,\dots,a_{15},0)
$$
æˆ‘ä»¬å¯ä»¥ç»™æ ¼å‘é‡æœ€åä¸€åˆ—é…ä¸€ä¸ªå¤§ä¸€ç‚¹çš„ç³»æ•°ï¼Œæ¥ä½¿å¾—å³è¾¹è½åœ¨æœ€å°å‘é‡ä¸­
å®éªŒä¸€ä¸‹ä½ å–$k>128$å°±å¤Ÿç”¨äº†
å¾—åˆ°äº†$key$ åé¢å°±æ˜¯å–œé—»ä¹è§çš„è§£å¯†äº†ï¼Œexpå¦‚ä¸‹
```python
  

from Crypto.Util.Padding import pad

from Crypto.Util.number import *

from Crypto.Cipher import AES

root = 122536272320154909907460423807891938232

q = 264273181570520944116363476632762225021

k = 2^9

M = matrix(ZZ, 17, 17)

for i in range(16):

    M[i,i]=1

    M[i,16]=k*root^i

M[16,16]=k*q

L=M.LLL()

# print(L)

key = b'\x0f!r\x1a\x071c8Qtjf\x05C\x1e\x1d'

iv = b'Gc\xf2\xfd\x94\xdc\xc8\xbb\xf4\x84\xb1\xfd\x96\xcd6\\'

ciphertext = 'd23eac665cdb57a8ae7764bb4497eb2f79729537e596600ded7a068c407e67ea75e6d76eb9e23e21634b84a96424130e'

ciphertext = bytes.fromhex(ciphertext)

  

cipher = AES.new(key, AES.MODE_CBC, iv)

  

plaintext = cipher.decrypt(ciphertext)

  

print("Decrypted plaintext (raw):", plaintext)
b'moectf{th3_first_blood_0f_LLL!@#$}\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e'
```
è‡³æ­¤å†ç»å‰å‰ååå¤§å‡ ä¸ªæœˆï¼Œmoectf2024å·²ç»å…¨éƒ¨å¤ç°ï¼Œå†™å®Œè¿™ç¯‡blogä¹‹åå°±å¾—å»å‡†å¤‡æœŸæœ«äº†ï¼‰ï¼‰



